import{g as fn,a as ho,r as Ca,b as nt}from"./index-TKBHeeUH.js";import{r as Oa,a as po}from"./index-Cz58Qiy-.js";const ar=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;function Nr(n){return n instanceof Uint8Array||ArrayBuffer.isView(n)&&n.constructor.name==="Uint8Array"}function Mr(n){if(!Number.isSafeInteger(n)||n<0)throw new Error("positive integer expected, got "+n)}function Ke(n,...t){if(!Nr(n))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(n.length))throw new Error("Uint8Array expected of length "+t+", got length="+n.length)}function go(n){if(typeof n!="function"||typeof n.create!="function")throw new Error("Hash should be wrapped by utils.createHasher");Mr(n.outputLen),Mr(n.blockLen)}function mr(n,t=!0){if(n.destroyed)throw new Error("Hash instance has been destroyed");if(t&&n.finished)throw new Error("Hash#digest() has already been called")}function yo(n,t){Ke(n);const e=t.outputLen;if(n.length<e)throw new Error("digestInto() expects output buffer of length at least "+e)}function Na(n){return new Uint32Array(n.buffer,n.byteOffset,Math.floor(n.byteLength/4))}function je(...n){for(let t=0;t<n.length;t++)n[t].fill(0)}function Wn(n){return new DataView(n.buffer,n.byteOffset,n.byteLength)}function xe(n,t){return n<<32-t|n>>>t}const Ua=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function za(n){return n<<24&4278190080|n<<8&16711680|n>>>8&65280|n>>>24&255}function Ka(n){for(let t=0;t<n.length;t++)n[t]=za(n[t]);return n}const yi=Ua?n=>n:Ka,mo=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",qa=Array.from({length:256},(n,t)=>t.toString(16).padStart(2,"0"));function Qe(n){if(Ke(n),mo)return n.toHex();let t="";for(let e=0;e<n.length;e++)t+=qa[n[e]];return t}const Pe={_0:48,_9:57,A:65,F:70,a:97,f:102};function mi(n){if(n>=Pe._0&&n<=Pe._9)return n-Pe._0;if(n>=Pe.A&&n<=Pe.F)return n-(Pe.A-10);if(n>=Pe.a&&n<=Pe.f)return n-(Pe.a-10)}function Qr(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);if(mo)return Uint8Array.fromHex(n);const t=n.length,e=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);const r=new Uint8Array(e);for(let i=0,s=0;i<e;i++,s+=2){const o=mi(n.charCodeAt(s)),h=mi(n.charCodeAt(s+1));if(o===void 0||h===void 0){const l=n[s]+n[s+1];throw new Error('hex string expected, got non-hex character "'+l+'" at index '+s)}r[i]=o*16+h}return r}function Da(n){if(typeof n!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(n))}function ln(n){return typeof n=="string"&&(n=Da(n)),Ke(n),n}function Ee(...n){let t=0;for(let r=0;r<n.length;r++){const i=n[r];Ke(i),t+=i.length}const e=new Uint8Array(t);for(let r=0,i=0;r<n.length;r++){const s=n[r];e.set(s,i),i+=s.length}return e}class Is{}function As(n){const t=r=>n().update(ln(r)).digest(),e=n();return t.outputLen=e.outputLen,t.blockLen=e.blockLen,t.create=()=>n(),t}function Bs(n=32){if(ar&&typeof ar.getRandomValues=="function")return ar.getRandomValues(new Uint8Array(n));if(ar&&typeof ar.randomBytes=="function")return Uint8Array.from(ar.randomBytes(n));throw new Error("crypto.getRandomValues must be defined")}function Fa(n,t,e,r){if(typeof n.setBigUint64=="function")return n.setBigUint64(t,e,r);const i=BigInt(32),s=BigInt(4294967295),o=Number(e>>i&s),h=Number(e&s),l=r?4:0,y=r?0:4;n.setUint32(t+l,o,r),n.setUint32(t+y,h,r)}function Wa(n,t,e){return n&t^~n&e}function Va(n,t,e){return n&t^n&e^t&e}class bo extends Is{constructor(t,e,r,i){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=t,this.outputLen=e,this.padOffset=r,this.isLE=i,this.buffer=new Uint8Array(t),this.view=Wn(this.buffer)}update(t){mr(this),t=ln(t),Ke(t);const{view:e,buffer:r,blockLen:i}=this,s=t.length;for(let o=0;o<s;){const h=Math.min(i-this.pos,s-o);if(h===i){const l=Wn(t);for(;i<=s-o;o+=i)this.process(l,o);continue}r.set(t.subarray(o,o+h),this.pos),this.pos+=h,o+=h,this.pos===i&&(this.process(e,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){mr(this),yo(t,this),this.finished=!0;const{buffer:e,view:r,blockLen:i,isLE:s}=this;let{pos:o}=this;e[o++]=128,je(this.buffer.subarray(o)),this.padOffset>i-o&&(this.process(r,0),o=0);for(let I=o;I<i;I++)e[I]=0;Fa(r,i-8,BigInt(this.length*8),s),this.process(r,0);const h=Wn(t),l=this.outputLen;if(l%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const y=l/4,S=this.get();if(y>S.length)throw new Error("_sha2: outputLen bigger than state");for(let I=0;I<y;I++)h.setUint32(4*I,S[I],s)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const r=t.slice(0,e);return this.destroy(),r}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:r,length:i,finished:s,destroyed:o,pos:h}=this;return t.destroyed=o,t.finished=s,t.length=i,t.pos=h,i%e&&t.buffer.set(r),t}clone(){return this._cloneInto()}}const qe=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),fe=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),Wr=BigInt(2**32-1),bi=BigInt(32);function Ha(n,t=!1){return t?{h:Number(n&Wr),l:Number(n>>bi&Wr)}:{h:Number(n>>bi&Wr)|0,l:Number(n&Wr)|0}}function wo(n,t=!1){const e=n.length;let r=new Uint32Array(e),i=new Uint32Array(e);for(let s=0;s<e;s++){const{h:o,l:h}=Ha(n[s],t);[r[s],i[s]]=[o,h]}return[r,i]}const wi=(n,t,e)=>n>>>e,vi=(n,t,e)=>n<<32-e|t>>>e,cr=(n,t,e)=>n>>>e|t<<32-e,ur=(n,t,e)=>n<<32-e|t>>>e,Vr=(n,t,e)=>n<<64-e|t>>>e-32,Hr=(n,t,e)=>n>>>e-32|t<<64-e,$a=(n,t,e)=>n<<e|t>>>32-e,ja=(n,t,e)=>t<<e|n>>>32-e,Ga=(n,t,e)=>t<<e-32|n>>>64-e,Za=(n,t,e)=>n<<e-32|t>>>64-e;function Le(n,t,e,r){const i=(t>>>0)+(r>>>0);return{h:n+e+(i/2**32|0)|0,l:i|0}}const Ya=(n,t,e)=>(n>>>0)+(t>>>0)+(e>>>0),Xa=(n,t,e,r)=>t+e+r+(n/2**32|0)|0,Ja=(n,t,e,r)=>(n>>>0)+(t>>>0)+(e>>>0)+(r>>>0),Qa=(n,t,e,r,i)=>t+e+r+i+(n/2**32|0)|0,tc=(n,t,e,r,i)=>(n>>>0)+(t>>>0)+(e>>>0)+(r>>>0)+(i>>>0),ec=(n,t,e,r,i,s)=>t+e+r+i+s+(n/2**32|0)|0,rc=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),De=new Uint32Array(64);class nc extends bo{constructor(t=32){super(64,t,8,!1),this.A=qe[0]|0,this.B=qe[1]|0,this.C=qe[2]|0,this.D=qe[3]|0,this.E=qe[4]|0,this.F=qe[5]|0,this.G=qe[6]|0,this.H=qe[7]|0}get(){const{A:t,B:e,C:r,D:i,E:s,F:o,G:h,H:l}=this;return[t,e,r,i,s,o,h,l]}set(t,e,r,i,s,o,h,l){this.A=t|0,this.B=e|0,this.C=r|0,this.D=i|0,this.E=s|0,this.F=o|0,this.G=h|0,this.H=l|0}process(t,e){for(let I=0;I<16;I++,e+=4)De[I]=t.getUint32(e,!1);for(let I=16;I<64;I++){const x=De[I-15],k=De[I-2],R=xe(x,7)^xe(x,18)^x>>>3,A=xe(k,17)^xe(k,19)^k>>>10;De[I]=A+De[I-7]+R+De[I-16]|0}let{A:r,B:i,C:s,D:o,E:h,F:l,G:y,H:S}=this;for(let I=0;I<64;I++){const x=xe(h,6)^xe(h,11)^xe(h,25),k=S+x+Wa(h,l,y)+rc[I]+De[I]|0,A=(xe(r,2)^xe(r,13)^xe(r,22))+Va(r,i,s)|0;S=y,y=l,l=h,h=o+k|0,o=s,s=i,i=r,r=k+A|0}r=r+this.A|0,i=i+this.B|0,s=s+this.C|0,o=o+this.D|0,h=h+this.E|0,l=l+this.F|0,y=y+this.G|0,S=S+this.H|0,this.set(r,i,s,o,h,l,y,S)}roundClean(){je(De)}destroy(){this.set(0,0,0,0,0,0,0,0),je(this.buffer)}}const vo=wo(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(n=>BigInt(n))),sc=vo[0],ic=vo[1],Fe=new Uint32Array(80),We=new Uint32Array(80);class oc extends bo{constructor(t=64){super(128,t,16,!1),this.Ah=fe[0]|0,this.Al=fe[1]|0,this.Bh=fe[2]|0,this.Bl=fe[3]|0,this.Ch=fe[4]|0,this.Cl=fe[5]|0,this.Dh=fe[6]|0,this.Dl=fe[7]|0,this.Eh=fe[8]|0,this.El=fe[9]|0,this.Fh=fe[10]|0,this.Fl=fe[11]|0,this.Gh=fe[12]|0,this.Gl=fe[13]|0,this.Hh=fe[14]|0,this.Hl=fe[15]|0}get(){const{Ah:t,Al:e,Bh:r,Bl:i,Ch:s,Cl:o,Dh:h,Dl:l,Eh:y,El:S,Fh:I,Fl:x,Gh:k,Gl:R,Hh:A,Hl:T}=this;return[t,e,r,i,s,o,h,l,y,S,I,x,k,R,A,T]}set(t,e,r,i,s,o,h,l,y,S,I,x,k,R,A,T){this.Ah=t|0,this.Al=e|0,this.Bh=r|0,this.Bl=i|0,this.Ch=s|0,this.Cl=o|0,this.Dh=h|0,this.Dl=l|0,this.Eh=y|0,this.El=S|0,this.Fh=I|0,this.Fl=x|0,this.Gh=k|0,this.Gl=R|0,this.Hh=A|0,this.Hl=T|0}process(t,e){for(let U=0;U<16;U++,e+=4)Fe[U]=t.getUint32(e),We[U]=t.getUint32(e+=4);for(let U=16;U<80;U++){const W=Fe[U-15]|0,G=We[U-15]|0,$=cr(W,G,1)^cr(W,G,8)^wi(W,G,7),rt=ur(W,G,1)^ur(W,G,8)^vi(W,G,7),Q=Fe[U-2]|0,M=We[U-2]|0,P=cr(Q,M,19)^Vr(Q,M,61)^wi(Q,M,6),N=ur(Q,M,19)^Hr(Q,M,61)^vi(Q,M,6),K=Ja(rt,N,We[U-7],We[U-16]),p=Qa(K,$,P,Fe[U-7],Fe[U-16]);Fe[U]=p|0,We[U]=K|0}let{Ah:r,Al:i,Bh:s,Bl:o,Ch:h,Cl:l,Dh:y,Dl:S,Eh:I,El:x,Fh:k,Fl:R,Gh:A,Gl:T,Hh:C,Hl:D}=this;for(let U=0;U<80;U++){const W=cr(I,x,14)^cr(I,x,18)^Vr(I,x,41),G=ur(I,x,14)^ur(I,x,18)^Hr(I,x,41),$=I&k^~I&A,rt=x&R^~x&T,Q=tc(D,G,rt,ic[U],We[U]),M=ec(Q,C,W,$,sc[U],Fe[U]),P=Q|0,N=cr(r,i,28)^Vr(r,i,34)^Vr(r,i,39),K=ur(r,i,28)^Hr(r,i,34)^Hr(r,i,39),p=r&s^r&h^s&h,a=i&o^i&l^o&l;C=A|0,D=T|0,A=k|0,T=R|0,k=I|0,R=x|0,{h:I,l:x}=Le(y|0,S|0,M|0,P|0),y=h|0,S=l|0,h=s|0,l=o|0,s=r|0,o=i|0;const f=Ya(P,K,a);r=Xa(f,M,N,p),i=f|0}({h:r,l:i}=Le(this.Ah|0,this.Al|0,r|0,i|0)),{h:s,l:o}=Le(this.Bh|0,this.Bl|0,s|0,o|0),{h,l}=Le(this.Ch|0,this.Cl|0,h|0,l|0),{h:y,l:S}=Le(this.Dh|0,this.Dl|0,y|0,S|0),{h:I,l:x}=Le(this.Eh|0,this.El|0,I|0,x|0),{h:k,l:R}=Le(this.Fh|0,this.Fl|0,k|0,R|0),{h:A,l:T}=Le(this.Gh|0,this.Gl|0,A|0,T|0),{h:C,l:D}=Le(this.Hh|0,this.Hl|0,C|0,D|0),this.set(r,i,s,o,h,l,y,S,I,x,k,R,A,T,C,D)}roundClean(){je(Fe,We)}destroy(){je(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const ko=As(()=>new nc),ac=As(()=>new oc);const Rs=BigInt(0),ys=BigInt(1);function tr(n,t=""){if(typeof n!="boolean"){const e=t&&`"${t}"`;throw new Error(e+"expected boolean, got type="+typeof n)}return n}function ve(n,t,e=""){const r=Nr(n),i=n?.length,s=t!==void 0;if(!r||s&&i!==t){const o=e&&`"${e}" `,h=s?` of length ${t}`:"",l=r?`length=${i}`:`type=${typeof n}`;throw new Error(o+"expected Uint8Array"+h+", got "+l)}return n}function $r(n){const t=n.toString(16);return t.length&1?"0"+t:t}function So(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);return n===""?Rs:BigInt("0x"+n)}function hn(n){return So(Qe(n))}function Tr(n){return Ke(n),So(Qe(Uint8Array.from(n).reverse()))}function Ms(n,t){return Qr(n.toString(16).padStart(t*2,"0"))}function xo(n,t){return Ms(n,t).reverse()}function kt(n,t,e){let r;if(typeof t=="string")try{r=Qr(t)}catch(s){throw new Error(n+" must be hex string or Uint8Array, cause: "+s)}else if(Nr(t))r=Uint8Array.from(t);else throw new Error(n+" must be hex string or Uint8Array");const i=r.length;if(typeof e=="number"&&i!==e)throw new Error(n+" of length "+e+" expected, got "+i);return r}function ki(n){return Uint8Array.from(n)}const Vn=n=>typeof n=="bigint"&&Rs<=n;function cc(n,t,e){return Vn(n)&&Vn(t)&&Vn(e)&&t<=n&&n<e}function ms(n,t,e,r){if(!cc(t,e,r))throw new Error("expected valid "+n+": "+e+" <= n < "+r+", got "+t)}function _o(n){let t;for(t=0;n>Rs;n>>=ys,t+=1);return t}const Ur=n=>(ys<<BigInt(n))-ys;function uc(n,t,e){if(typeof n!="number"||n<2)throw new Error("hashLen must be a number");if(typeof t!="number"||t<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");const r=k=>new Uint8Array(k),i=k=>Uint8Array.of(k);let s=r(n),o=r(n),h=0;const l=()=>{s.fill(1),o.fill(0),h=0},y=(...k)=>e(o,s,...k),S=(k=r(0))=>{o=y(i(0),k),s=y(),k.length!==0&&(o=y(i(1),k),s=y())},I=()=>{if(h++>=1e3)throw new Error("drbg: tried 1000 values");let k=0;const R=[];for(;k<t;){s=y();const A=s.slice();R.push(A),k+=s.length}return Ee(...R)};return(k,R)=>{l(),S(k);let A;for(;!(A=R(I()));)S();return l(),A}}function zr(n,t,e={}){if(!n||typeof n!="object")throw new Error("expected valid options object");function r(i,s,o){const h=n[i];if(o&&h===void 0)return;const l=typeof h;if(l!==s||h===null)throw new Error(`param "${i}" is invalid: expected ${s}, got ${l}`)}Object.entries(t).forEach(([i,s])=>r(i,s,!1)),Object.entries(e).forEach(([i,s])=>r(i,s,!0))}function tn(n){const t=new WeakMap;return(e,...r)=>{const i=t.get(e);if(i!==void 0)return i;const s=n(e,...r);return t.set(e,s),s}}const be=BigInt(0),ue=BigInt(1),Ze=BigInt(2),Eo=BigInt(3),Io=BigInt(4),Ao=BigInt(5),fc=BigInt(7),Bo=BigInt(8),lc=BigInt(9),Ro=BigInt(16);function ne(n,t){const e=n%t;return e>=be?e:t+e}function vt(n,t,e){let r=n;for(;t-- >be;)r*=r,r%=e;return r}function Si(n,t){if(n===be)throw new Error("invert: expected non-zero number");if(t<=be)throw new Error("invert: expected positive modulus, got "+t);let e=ne(n,t),r=t,i=be,s=ue;for(;e!==be;){const h=r/e,l=r%e,y=i-s*h;r=e,e=l,i=s,s=y}if(r!==ue)throw new Error("invert: does not exist");return ne(i,t)}function Ts(n,t,e){if(!n.eql(n.sqr(t),e))throw new Error("Cannot find square root")}function Mo(n,t){const e=(n.ORDER+ue)/Io,r=n.pow(t,e);return Ts(n,r,t),r}function hc(n,t){const e=(n.ORDER-Ao)/Bo,r=n.mul(t,Ze),i=n.pow(r,e),s=n.mul(t,i),o=n.mul(n.mul(s,Ze),i),h=n.mul(s,n.sub(o,n.ONE));return Ts(n,h,t),h}function dc(n){const t=nr(n),e=To(n),r=e(t,t.neg(t.ONE)),i=e(t,r),s=e(t,t.neg(r)),o=(n+fc)/Ro;return(h,l)=>{let y=h.pow(l,o),S=h.mul(y,r);const I=h.mul(y,i),x=h.mul(y,s),k=h.eql(h.sqr(S),l),R=h.eql(h.sqr(I),l);y=h.cmov(y,S,k),S=h.cmov(x,I,R);const A=h.eql(h.sqr(S),l),T=h.cmov(y,S,A);return Ts(h,T,l),T}}function To(n){if(n<Eo)throw new Error("sqrt is not defined for small field");let t=n-ue,e=0;for(;t%Ze===be;)t/=Ze,e++;let r=Ze;const i=nr(n);for(;xi(i,r)===1;)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(e===1)return Mo;let s=i.pow(r,t);const o=(t+ue)/Ze;return function(l,y){if(l.is0(y))return y;if(xi(l,y)!==1)throw new Error("Cannot find square root");let S=e,I=l.mul(l.ONE,s),x=l.pow(y,t),k=l.pow(y,o);for(;!l.eql(x,l.ONE);){if(l.is0(x))return l.ZERO;let R=1,A=l.sqr(x);for(;!l.eql(A,l.ONE);)if(R++,A=l.sqr(A),R===S)throw new Error("Cannot find square root");const T=ue<<BigInt(S-R-1),C=l.pow(I,T);S=R,I=l.sqr(C),x=l.mul(x,I),k=l.mul(k,C)}return k}}function pc(n){return n%Io===Eo?Mo:n%Bo===Ao?hc:n%Ro===lc?dc(n):To(n)}const gc=(n,t)=>(ne(n,t)&ue)===ue,yc=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function mc(n){const t={ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"},e=yc.reduce((r,i)=>(r[i]="function",r),t);return zr(n,e),n}function bc(n,t,e){if(e<be)throw new Error("invalid exponent, negatives unsupported");if(e===be)return n.ONE;if(e===ue)return t;let r=n.ONE,i=t;for(;e>be;)e&ue&&(r=n.mul(r,i)),i=n.sqr(i),e>>=ue;return r}function Po(n,t,e=!1){const r=new Array(t.length).fill(e?n.ZERO:void 0),i=t.reduce((o,h,l)=>n.is0(h)?o:(r[l]=o,n.mul(o,h)),n.ONE),s=n.inv(i);return t.reduceRight((o,h,l)=>n.is0(h)?o:(r[l]=n.mul(o,r[l]),n.mul(o,h)),s),r}function xi(n,t){const e=(n.ORDER-ue)/Ze,r=n.pow(t,e),i=n.eql(r,n.ONE),s=n.eql(r,n.ZERO),o=n.eql(r,n.neg(n.ONE));if(!i&&!s&&!o)throw new Error("invalid Legendre symbol result");return i?1:s?0:-1}function Lo(n,t){t!==void 0&&Mr(t);const e=t!==void 0?t:n.toString(2).length,r=Math.ceil(e/8);return{nBitLength:e,nByteLength:r}}function nr(n,t,e=!1,r={}){if(n<=be)throw new Error("invalid field: expected ORDER > 0, got "+n);let i,s,o=!1,h;if(typeof t=="object"&&t!=null){if(r.sqrt||e)throw new Error("cannot specify opts in two arguments");const x=t;x.BITS&&(i=x.BITS),x.sqrt&&(s=x.sqrt),typeof x.isLE=="boolean"&&(e=x.isLE),typeof x.modFromBytes=="boolean"&&(o=x.modFromBytes),h=x.allowedLengths}else typeof t=="number"&&(i=t),r.sqrt&&(s=r.sqrt);const{nBitLength:l,nByteLength:y}=Lo(n,i);if(y>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let S;const I=Object.freeze({ORDER:n,isLE:e,BITS:l,BYTES:y,MASK:Ur(l),ZERO:be,ONE:ue,allowedLengths:h,create:x=>ne(x,n),isValid:x=>{if(typeof x!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof x);return be<=x&&x<n},is0:x=>x===be,isValidNot0:x=>!I.is0(x)&&I.isValid(x),isOdd:x=>(x&ue)===ue,neg:x=>ne(-x,n),eql:(x,k)=>x===k,sqr:x=>ne(x*x,n),add:(x,k)=>ne(x+k,n),sub:(x,k)=>ne(x-k,n),mul:(x,k)=>ne(x*k,n),pow:(x,k)=>bc(I,x,k),div:(x,k)=>ne(x*Si(k,n),n),sqrN:x=>x*x,addN:(x,k)=>x+k,subN:(x,k)=>x-k,mulN:(x,k)=>x*k,inv:x=>Si(x,n),sqrt:s||(x=>(S||(S=pc(n)),S(I,x))),toBytes:x=>e?xo(x,y):Ms(x,y),fromBytes:(x,k=!0)=>{if(h){if(!h.includes(x.length)||x.length>y)throw new Error("Field.fromBytes: expected "+h+" bytes, got "+x.length);const A=new Uint8Array(y);A.set(x,e?0:A.length-x.length),x=A}if(x.length!==y)throw new Error("Field.fromBytes: expected "+y+" bytes, got "+x.length);let R=e?Tr(x):hn(x);if(o&&(R=ne(R,n)),!k&&!I.isValid(R))throw new Error("invalid field element: outside of range 0..ORDER");return R},invertBatch:x=>Po(I,x),cmov:(x,k,R)=>R?k:x});return Object.freeze(I)}function Co(n){if(typeof n!="bigint")throw new Error("field order must be bigint");const t=n.toString(2).length;return Math.ceil(t/8)}function Oo(n){const t=Co(n);return t+Math.ceil(t/2)}function wc(n,t,e=!1){const r=n.length,i=Co(t),s=Oo(t);if(r<16||r<s||r>1024)throw new Error("expected "+s+"-1024 bytes of input, got "+r);const o=e?Tr(n):hn(n),h=ne(o,t-ue)+ue;return e?xo(h,i):Ms(h,i)}const br=BigInt(0),Ye=BigInt(1);function en(n,t){const e=t.negate();return n?e:t}function Xe(n,t){const e=Po(n.Fp,t.map(r=>r.Z));return t.map((r,i)=>n.fromAffine(r.toAffine(e[i])))}function No(n,t){if(!Number.isSafeInteger(n)||n<=0||n>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+n)}function Hn(n,t){No(n,t);const e=Math.ceil(t/n)+1,r=2**(n-1),i=2**n,s=Ur(n),o=BigInt(n);return{windows:e,windowSize:r,mask:s,maxNumber:i,shiftBy:o}}function _i(n,t,e){const{windowSize:r,mask:i,maxNumber:s,shiftBy:o}=e;let h=Number(n&i),l=n>>o;h>r&&(h-=s,l+=Ye);const y=t*r,S=y+Math.abs(h)-1,I=h===0,x=h<0,k=t%2!==0;return{nextN:l,offset:S,isZero:I,isNeg:x,isNegF:k,offsetF:y}}function vc(n,t){if(!Array.isArray(n))throw new Error("array expected");n.forEach((e,r)=>{if(!(e instanceof t))throw new Error("invalid point at index "+r)})}function kc(n,t){if(!Array.isArray(n))throw new Error("array of scalars expected");n.forEach((e,r)=>{if(!t.isValid(e))throw new Error("invalid scalar at index "+r)})}const $n=new WeakMap,Uo=new WeakMap;function jn(n){return Uo.get(n)||1}function Ei(n){if(n!==br)throw new Error("invalid wNAF")}class zo{constructor(t,e){this.BASE=t.BASE,this.ZERO=t.ZERO,this.Fn=t.Fn,this.bits=e}_unsafeLadder(t,e,r=this.ZERO){let i=t;for(;e>br;)e&Ye&&(r=r.add(i)),i=i.double(),e>>=Ye;return r}precomputeWindow(t,e){const{windows:r,windowSize:i}=Hn(e,this.bits),s=[];let o=t,h=o;for(let l=0;l<r;l++){h=o,s.push(h);for(let y=1;y<i;y++)h=h.add(o),s.push(h);o=h.double()}return s}wNAF(t,e,r){if(!this.Fn.isValid(r))throw new Error("invalid scalar");let i=this.ZERO,s=this.BASE;const o=Hn(t,this.bits);for(let h=0;h<o.windows;h++){const{nextN:l,offset:y,isZero:S,isNeg:I,isNegF:x,offsetF:k}=_i(r,h,o);r=l,S?s=s.add(en(x,e[k])):i=i.add(en(I,e[y]))}return Ei(r),{p:i,f:s}}wNAFUnsafe(t,e,r,i=this.ZERO){const s=Hn(t,this.bits);for(let o=0;o<s.windows&&r!==br;o++){const{nextN:h,offset:l,isZero:y,isNeg:S}=_i(r,o,s);if(r=h,!y){const I=e[l];i=i.add(S?I.negate():I)}}return Ei(r),i}getPrecomputes(t,e,r){let i=$n.get(e);return i||(i=this.precomputeWindow(e,t),t!==1&&(typeof r=="function"&&(i=r(i)),$n.set(e,i))),i}cached(t,e,r){const i=jn(t);return this.wNAF(i,this.getPrecomputes(i,t,r),e)}unsafe(t,e,r,i){const s=jn(t);return s===1?this._unsafeLadder(t,e,i):this.wNAFUnsafe(s,this.getPrecomputes(s,t,r),e,i)}createCache(t,e){No(e,this.bits),Uo.set(t,e),$n.delete(t)}hasCache(t){return jn(t)!==1}}function Sc(n,t,e,r){let i=t,s=n.ZERO,o=n.ZERO;for(;e>br||r>br;)e&Ye&&(s=s.add(i)),r&Ye&&(o=o.add(i)),i=i.double(),e>>=Ye,r>>=Ye;return{p1:s,p2:o}}function Ko(n,t,e,r){vc(e,n),kc(r,t);const i=e.length,s=r.length;if(i!==s)throw new Error("arrays of points and scalars must have equal length");const o=n.ZERO,h=_o(BigInt(i));let l=1;h>12?l=h-3:h>4?l=h-2:h>0&&(l=2);const y=Ur(l),S=new Array(Number(y)+1).fill(o),I=Math.floor((t.BITS-1)/l)*l;let x=o;for(let k=I;k>=0;k-=l){S.fill(o);for(let A=0;A<s;A++){const T=r[A],C=Number(T>>BigInt(k)&y);S[C]=S[C].add(e[A])}let R=o;for(let A=S.length-1,T=o;A>0;A--)T=T.add(S[A]),R=R.add(T);if(x=x.add(R),k!==0)for(let A=0;A<l;A++)x=x.double()}return x}function Ii(n,t,e){if(t){if(t.ORDER!==n)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return mc(t),t}else return nr(n,{isLE:e})}function qo(n,t,e={},r){if(r===void 0&&(r=n==="edwards"),!t||typeof t!="object")throw new Error(`expected valid ${n} CURVE object`);for(const l of["p","n","h"]){const y=t[l];if(!(typeof y=="bigint"&&y>br))throw new Error(`CURVE.${l} must be positive bigint`)}const i=Ii(t.p,e.Fp,r),s=Ii(t.n,e.Fn,r),h=["Gx","Gy","a",n==="weierstrass"?"b":"d"];for(const l of h)if(!i.isValid(t[l]))throw new Error(`CURVE.${l} must be valid field element of CURVE.Fp`);return t=Object.freeze(Object.assign({},t)),{CURVE:t,Fp:i,Fn:s}}const Ve=BigInt(0),se=BigInt(1),Gn=BigInt(2),xc=BigInt(8);function _c(n,t,e,r){const i=n.sqr(e),s=n.sqr(r),o=n.add(n.mul(t.a,i),s),h=n.add(n.ONE,n.mul(t.d,n.mul(i,s)));return n.eql(o,h)}function Ec(n,t={}){const e=qo("edwards",n,t,t.FpFnLE),{Fp:r,Fn:i}=e;let s=e.CURVE;const{h:o}=s;zr(t,{},{uvRatio:"function"});const h=Gn<<BigInt(i.BYTES*8)-se,l=T=>r.create(T),y=t.uvRatio||((T,C)=>{try{return{isValid:!0,value:r.sqrt(r.div(T,C))}}catch{return{isValid:!1,value:Ve}}});if(!_c(r,s,s.Gx,s.Gy))throw new Error("bad curve params: generator point");function S(T,C,D=!1){const U=D?se:Ve;return ms("coordinate "+T,C,U,h),C}function I(T){if(!(T instanceof R))throw new Error("ExtendedPoint expected")}const x=tn((T,C)=>{const{X:D,Y:U,Z:W}=T,G=T.is0();C==null&&(C=G?xc:r.inv(W));const $=l(D*C),rt=l(U*C),Q=r.mul(W,C);if(G)return{x:Ve,y:se};if(Q!==se)throw new Error("invZ was invalid");return{x:$,y:rt}}),k=tn(T=>{const{a:C,d:D}=s;if(T.is0())throw new Error("bad point: ZERO");const{X:U,Y:W,Z:G,T:$}=T,rt=l(U*U),Q=l(W*W),M=l(G*G),P=l(M*M),N=l(rt*C),K=l(M*l(N+Q)),p=l(P+l(D*l(rt*Q)));if(K!==p)throw new Error("bad point: equation left != right (1)");const a=l(U*W),f=l(G*$);if(a!==f)throw new Error("bad point: equation left != right (2)");return!0});class R{constructor(C,D,U,W){this.X=S("x",C),this.Y=S("y",D),this.Z=S("z",U,!0),this.T=S("t",W),Object.freeze(this)}static CURVE(){return s}static fromAffine(C){if(C instanceof R)throw new Error("extended point not allowed");const{x:D,y:U}=C||{};return S("x",D),S("y",U),new R(D,U,se,l(D*U))}static fromBytes(C,D=!1){const U=r.BYTES,{a:W,d:G}=s;C=ki(ve(C,U,"point")),tr(D,"zip215");const $=ki(C),rt=C[U-1];$[U-1]=rt&-129;const Q=Tr($),M=D?h:r.ORDER;ms("point.y",Q,Ve,M);const P=l(Q*Q),N=l(P-se),K=l(G*P-W);let{isValid:p,value:a}=y(N,K);if(!p)throw new Error("bad point: invalid y coordinate");const f=(a&se)===se,d=(rt&128)!==0;if(!D&&a===Ve&&d)throw new Error("bad point: x=0 and x_0=1");return d!==f&&(a=l(-a)),R.fromAffine({x:a,y:Q})}static fromHex(C,D=!1){return R.fromBytes(kt("point",C),D)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(C=8,D=!0){return A.createCache(this,C),D||this.multiply(Gn),this}assertValidity(){k(this)}equals(C){I(C);const{X:D,Y:U,Z:W}=this,{X:G,Y:$,Z:rt}=C,Q=l(D*rt),M=l(G*W),P=l(U*rt),N=l($*W);return Q===M&&P===N}is0(){return this.equals(R.ZERO)}negate(){return new R(l(-this.X),this.Y,this.Z,l(-this.T))}double(){const{a:C}=s,{X:D,Y:U,Z:W}=this,G=l(D*D),$=l(U*U),rt=l(Gn*l(W*W)),Q=l(C*G),M=D+U,P=l(l(M*M)-G-$),N=Q+$,K=N-rt,p=Q-$,a=l(P*K),f=l(N*p),d=l(P*p),m=l(K*N);return new R(a,f,m,d)}add(C){I(C);const{a:D,d:U}=s,{X:W,Y:G,Z:$,T:rt}=this,{X:Q,Y:M,Z:P,T:N}=C,K=l(W*Q),p=l(G*M),a=l(rt*U*N),f=l($*P),d=l((W+G)*(Q+M)-K-p),m=f-a,w=f+a,_=l(p-D*K),B=l(d*m),b=l(w*_),c=l(d*_),u=l(m*w);return new R(B,b,u,c)}subtract(C){return this.add(C.negate())}multiply(C){if(!i.isValidNot0(C))throw new Error("invalid scalar: expected 1 <= sc < curve.n");const{p:D,f:U}=A.cached(this,C,W=>Xe(R,W));return Xe(R,[D,U])[0]}multiplyUnsafe(C,D=R.ZERO){if(!i.isValid(C))throw new Error("invalid scalar: expected 0 <= sc < curve.n");return C===Ve?R.ZERO:this.is0()||C===se?this:A.unsafe(this,C,U=>Xe(R,U),D)}isSmallOrder(){return this.multiplyUnsafe(o).is0()}isTorsionFree(){return A.unsafe(this,s.n).is0()}toAffine(C){return x(this,C)}clearCofactor(){return o===se?this:this.multiplyUnsafe(o)}toBytes(){const{x:C,y:D}=this.toAffine(),U=r.toBytes(D);return U[U.length-1]|=C&se?128:0,U}toHex(){return Qe(this.toBytes())}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get ex(){return this.X}get ey(){return this.Y}get ez(){return this.Z}get et(){return this.T}static normalizeZ(C){return Xe(R,C)}static msm(C,D){return Ko(R,i,C,D)}_setWindowSize(C){this.precompute(C)}toRawBytes(){return this.toBytes()}}R.BASE=new R(s.Gx,s.Gy,se,l(s.Gx*s.Gy)),R.ZERO=new R(Ve,se,se,Ve),R.Fp=r,R.Fn=i;const A=new zo(R,i.BITS);return R.BASE.precompute(8),R}function Ic(n,t,e={}){if(typeof t!="function")throw new Error('"hash" function param is required');zr(e,{},{adjustScalarBytes:"function",randomBytes:"function",domain:"function",prehash:"function",mapToCurve:"function"});const{prehash:r}=e,{BASE:i,Fp:s,Fn:o}=n,h=e.randomBytes||Bs,l=e.adjustScalarBytes||(M=>M),y=e.domain||((M,P,N)=>{if(tr(N,"phflag"),P.length||N)throw new Error("Contexts/pre-hash are not supported");return M});function S(M){return o.create(Tr(M))}function I(M){const P=U.secretKey;M=kt("private key",M,P);const N=kt("hashed private key",t(M),2*P),K=l(N.slice(0,P)),p=N.slice(P,2*P),a=S(K);return{head:K,prefix:p,scalar:a}}function x(M){const{head:P,prefix:N,scalar:K}=I(M),p=i.multiply(K),a=p.toBytes();return{head:P,prefix:N,scalar:K,point:p,pointBytes:a}}function k(M){return x(M).pointBytes}function R(M=Uint8Array.of(),...P){const N=Ee(...P);return S(t(y(N,kt("context",M),!!r)))}function A(M,P,N={}){M=kt("message",M),r&&(M=r(M));const{prefix:K,scalar:p,pointBytes:a}=x(P),f=R(N.context,K,M),d=i.multiply(f).toBytes(),m=R(N.context,d,a,M),w=o.create(f+m*p);if(!o.isValid(w))throw new Error("sign failed: invalid s");const _=Ee(d,o.toBytes(w));return ve(_,U.signature,"result")}const T={zip215:!0};function C(M,P,N,K=T){const{context:p,zip215:a}=K,f=U.signature;M=kt("signature",M,f),P=kt("message",P),N=kt("publicKey",N,U.publicKey),a!==void 0&&tr(a,"zip215"),r&&(P=r(P));const d=f/2,m=M.subarray(0,d),w=Tr(M.subarray(d,f));let _,B,b;try{_=n.fromBytes(N,a),B=n.fromBytes(m,a),b=i.multiplyUnsafe(w)}catch{return!1}if(!a&&_.isSmallOrder())return!1;const c=R(p,B.toBytes(),_.toBytes(),P);return B.add(_.multiplyUnsafe(c)).subtract(b).clearCofactor().is0()}const D=s.BYTES,U={secretKey:D,publicKey:D,signature:2*D,seed:D};function W(M=h(U.seed)){return ve(M,U.seed,"seed")}function G(M){const P=Q.randomSecretKey(M);return{secretKey:P,publicKey:k(P)}}function $(M){return Nr(M)&&M.length===o.BYTES}function rt(M,P){try{return!!n.fromBytes(M,P)}catch{return!1}}const Q={getExtendedPublicKey:x,randomSecretKey:W,isValidSecretKey:$,isValidPublicKey:rt,toMontgomery(M){const{y:P}=n.fromBytes(M),N=U.publicKey,K=N===32;if(!K&&N!==57)throw new Error("only defined for 25519 and 448");const p=K?s.div(se+P,se-P):s.div(P-se,P+se);return s.toBytes(p)},toMontgomerySecret(M){const P=U.secretKey;ve(M,P);const N=t(M.subarray(0,P));return l(N).subarray(0,P)},randomPrivateKey:W,precompute(M=8,P=n.BASE){return P.precompute(M,!1)}};return Object.freeze({keygen:G,getPublicKey:k,sign:A,verify:C,utils:Q,Point:n,lengths:U})}function Ac(n){const t={a:n.a,d:n.d,p:n.Fp.ORDER,n:n.n,h:n.h,Gx:n.Gx,Gy:n.Gy},e=n.Fp,r=nr(t.n,n.nBitLength,!0),i={Fp:e,Fn:r,uvRatio:n.uvRatio},s={randomBytes:n.randomBytes,adjustScalarBytes:n.adjustScalarBytes,domain:n.domain,prehash:n.prehash,mapToCurve:n.mapToCurve};return{CURVE:t,curveOpts:i,hash:n.hash,eddsaOpts:s}}function Bc(n,t){const e=t.Point;return Object.assign({},t,{ExtendedPoint:e,CURVE:n,nBitLength:e.Fn.BITS,nByteLength:e.Fn.BYTES})}function Rc(n){const{CURVE:t,curveOpts:e,hash:r,eddsaOpts:i}=Ac(n),s=Ec(t,e),o=Ic(s,r,i);return Bc(n,o)}const Mc=BigInt(1),Ai=BigInt(2);BigInt(3);const Tc=BigInt(5),Pc=BigInt(8),Ps=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),Do={p:Ps,n:BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),h:Pc,a:BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),d:BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),Gx:BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),Gy:BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")};function Lc(n){const t=BigInt(10),e=BigInt(20),r=BigInt(40),i=BigInt(80),s=Ps,h=n*n%s*n%s,l=vt(h,Ai,s)*h%s,y=vt(l,Mc,s)*n%s,S=vt(y,Tc,s)*y%s,I=vt(S,t,s)*S%s,x=vt(I,e,s)*I%s,k=vt(x,r,s)*x%s,R=vt(k,i,s)*k%s,A=vt(R,i,s)*k%s,T=vt(A,t,s)*S%s;return{pow_p_5_8:vt(T,Ai,s)*n%s,b2:h}}function Cc(n){return n[0]&=248,n[31]&=127,n[31]|=64,n}const Bi=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");function Oc(n,t){const e=Ps,r=ne(t*t*t,e),i=ne(r*r*t,e),s=Lc(n*i).pow_p_5_8;let o=ne(n*r*s,e);const h=ne(t*o*o,e),l=o,y=ne(o*Bi,e),S=h===n,I=h===ne(-n,e),x=h===ne(-n*Bi,e);return S&&(o=l),(I||x)&&(o=y),gc(o,e)&&(o=ne(-o,e)),{isValid:S||I,value:o}}const Nc=nr(Do.p,{isLE:!0}),Uc={...Do,Fp:Nc,hash:ac,adjustScalarBytes:Cc,uvRatio:Oc},Sr=Rc(Uc);var Yr={exports:{}},zc=Yr.exports,Ri;function Fo(){return Ri||(Ri=1,(function(n){(function(t,e){function r(p,a){if(!p)throw new Error(a||"Assertion failed")}function i(p,a){p.super_=a;var f=function(){};f.prototype=a.prototype,p.prototype=new f,p.prototype.constructor=p}function s(p,a,f){if(s.isBN(p))return p;this.negative=0,this.words=null,this.length=0,this.red=null,p!==null&&((a==="le"||a==="be")&&(f=a,a=10),this._init(p||0,a||10,f||"be"))}typeof t=="object"?t.exports=s:e.BN=s,s.BN=s,s.wordSize=26;var o;try{typeof window<"u"&&typeof window.Buffer<"u"?o=window.Buffer:o=Oa.Buffer}catch{}s.isBN=function(a){return a instanceof s?!0:a!==null&&typeof a=="object"&&a.constructor.wordSize===s.wordSize&&Array.isArray(a.words)},s.max=function(a,f){return a.cmp(f)>0?a:f},s.min=function(a,f){return a.cmp(f)<0?a:f},s.prototype._init=function(a,f,d){if(typeof a=="number")return this._initNumber(a,f,d);if(typeof a=="object")return this._initArray(a,f,d);f==="hex"&&(f=16),r(f===(f|0)&&f>=2&&f<=36),a=a.toString().replace(/\s+/g,"");var m=0;a[0]==="-"&&(m++,this.negative=1),m<a.length&&(f===16?this._parseHex(a,m,d):(this._parseBase(a,f,m),d==="le"&&this._initArray(this.toArray(),f,d)))},s.prototype._initNumber=function(a,f,d){a<0&&(this.negative=1,a=-a),a<67108864?(this.words=[a&67108863],this.length=1):a<4503599627370496?(this.words=[a&67108863,a/67108864&67108863],this.length=2):(r(a<9007199254740992),this.words=[a&67108863,a/67108864&67108863,1],this.length=3),d==="le"&&this._initArray(this.toArray(),f,d)},s.prototype._initArray=function(a,f,d){if(r(typeof a.length=="number"),a.length<=0)return this.words=[0],this.length=1,this;this.length=Math.ceil(a.length/3),this.words=new Array(this.length);for(var m=0;m<this.length;m++)this.words[m]=0;var w,_,B=0;if(d==="be")for(m=a.length-1,w=0;m>=0;m-=3)_=a[m]|a[m-1]<<8|a[m-2]<<16,this.words[w]|=_<<B&67108863,this.words[w+1]=_>>>26-B&67108863,B+=24,B>=26&&(B-=26,w++);else if(d==="le")for(m=0,w=0;m<a.length;m+=3)_=a[m]|a[m+1]<<8|a[m+2]<<16,this.words[w]|=_<<B&67108863,this.words[w+1]=_>>>26-B&67108863,B+=24,B>=26&&(B-=26,w++);return this._strip()};function h(p,a){var f=p.charCodeAt(a);if(f>=48&&f<=57)return f-48;if(f>=65&&f<=70)return f-55;if(f>=97&&f<=102)return f-87;r(!1,"Invalid character in "+p)}function l(p,a,f){var d=h(p,f);return f-1>=a&&(d|=h(p,f-1)<<4),d}s.prototype._parseHex=function(a,f,d){this.length=Math.ceil((a.length-f)/6),this.words=new Array(this.length);for(var m=0;m<this.length;m++)this.words[m]=0;var w=0,_=0,B;if(d==="be")for(m=a.length-1;m>=f;m-=2)B=l(a,f,m)<<w,this.words[_]|=B&67108863,w>=18?(w-=18,_+=1,this.words[_]|=B>>>26):w+=8;else{var b=a.length-f;for(m=b%2===0?f+1:f;m<a.length;m+=2)B=l(a,f,m)<<w,this.words[_]|=B&67108863,w>=18?(w-=18,_+=1,this.words[_]|=B>>>26):w+=8}this._strip()};function y(p,a,f,d){for(var m=0,w=0,_=Math.min(p.length,f),B=a;B<_;B++){var b=p.charCodeAt(B)-48;m*=d,b>=49?w=b-49+10:b>=17?w=b-17+10:w=b,r(b>=0&&w<d,"Invalid character"),m+=w}return m}s.prototype._parseBase=function(a,f,d){this.words=[0],this.length=1;for(var m=0,w=1;w<=67108863;w*=f)m++;m--,w=w/f|0;for(var _=a.length-d,B=_%m,b=Math.min(_,_-B)+d,c=0,u=d;u<b;u+=m)c=y(a,u,u+m,f),this.imuln(w),this.words[0]+c<67108864?this.words[0]+=c:this._iaddn(c);if(B!==0){var g=1;for(c=y(a,u,a.length,f),u=0;u<B;u++)g*=f;this.imuln(g),this.words[0]+c<67108864?this.words[0]+=c:this._iaddn(c)}this._strip()},s.prototype.copy=function(a){a.words=new Array(this.length);for(var f=0;f<this.length;f++)a.words[f]=this.words[f];a.length=this.length,a.negative=this.negative,a.red=this.red};function S(p,a){p.words=a.words,p.length=a.length,p.negative=a.negative,p.red=a.red}if(s.prototype._move=function(a){S(a,this)},s.prototype.clone=function(){var a=new s(null);return this.copy(a),a},s.prototype._expand=function(a){for(;this.length<a;)this.words[this.length++]=0;return this},s.prototype._strip=function(){for(;this.length>1&&this.words[this.length-1]===0;)this.length--;return this._normSign()},s.prototype._normSign=function(){return this.length===1&&this.words[0]===0&&(this.negative=0),this},typeof Symbol<"u"&&typeof Symbol.for=="function")try{s.prototype[Symbol.for("nodejs.util.inspect.custom")]=I}catch{s.prototype.inspect=I}else s.prototype.inspect=I;function I(){return(this.red?"<BN-R: ":"<BN: ")+this.toString(16)+">"}var x=["","0","00","000","0000","00000","000000","0000000","00000000","000000000","0000000000","00000000000","000000000000","0000000000000","00000000000000","000000000000000","0000000000000000","00000000000000000","000000000000000000","0000000000000000000","00000000000000000000","000000000000000000000","0000000000000000000000","00000000000000000000000","000000000000000000000000","0000000000000000000000000"],k=[0,0,25,16,12,11,10,9,8,8,7,7,7,7,6,6,6,6,6,6,6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5],R=[0,0,33554432,43046721,16777216,48828125,60466176,40353607,16777216,43046721,1e7,19487171,35831808,62748517,7529536,11390625,16777216,24137569,34012224,47045881,64e6,4084101,5153632,6436343,7962624,9765625,11881376,14348907,17210368,20511149,243e5,28629151,33554432,39135393,45435424,52521875,60466176];s.prototype.toString=function(a,f){a=a||10,f=f|0||1;var d;if(a===16||a==="hex"){d="";for(var m=0,w=0,_=0;_<this.length;_++){var B=this.words[_],b=((B<<m|w)&16777215).toString(16);w=B>>>24-m&16777215,m+=2,m>=26&&(m-=26,_--),w!==0||_!==this.length-1?d=x[6-b.length]+b+d:d=b+d}for(w!==0&&(d=w.toString(16)+d);d.length%f!==0;)d="0"+d;return this.negative!==0&&(d="-"+d),d}if(a===(a|0)&&a>=2&&a<=36){var c=k[a],u=R[a];d="";var g=this.clone();for(g.negative=0;!g.isZero();){var v=g.modrn(u).toString(a);g=g.idivn(u),g.isZero()?d=v+d:d=x[c-v.length]+v+d}for(this.isZero()&&(d="0"+d);d.length%f!==0;)d="0"+d;return this.negative!==0&&(d="-"+d),d}r(!1,"Base should be between 2 and 36")},s.prototype.toNumber=function(){var a=this.words[0];return this.length===2?a+=this.words[1]*67108864:this.length===3&&this.words[2]===1?a+=4503599627370496+this.words[1]*67108864:this.length>2&&r(!1,"Number can only safely store up to 53 bits"),this.negative!==0?-a:a},s.prototype.toJSON=function(){return this.toString(16,2)},o&&(s.prototype.toBuffer=function(a,f){return this.toArrayLike(o,a,f)}),s.prototype.toArray=function(a,f){return this.toArrayLike(Array,a,f)};var A=function(a,f){return a.allocUnsafe?a.allocUnsafe(f):new a(f)};s.prototype.toArrayLike=function(a,f,d){this._strip();var m=this.byteLength(),w=d||Math.max(1,m);r(m<=w,"byte array longer than desired length"),r(w>0,"Requested array length <= 0");var _=A(a,w),B=f==="le"?"LE":"BE";return this["_toArrayLike"+B](_,m),_},s.prototype._toArrayLikeLE=function(a,f){for(var d=0,m=0,w=0,_=0;w<this.length;w++){var B=this.words[w]<<_|m;a[d++]=B&255,d<a.length&&(a[d++]=B>>8&255),d<a.length&&(a[d++]=B>>16&255),_===6?(d<a.length&&(a[d++]=B>>24&255),m=0,_=0):(m=B>>>24,_+=2)}if(d<a.length)for(a[d++]=m;d<a.length;)a[d++]=0},s.prototype._toArrayLikeBE=function(a,f){for(var d=a.length-1,m=0,w=0,_=0;w<this.length;w++){var B=this.words[w]<<_|m;a[d--]=B&255,d>=0&&(a[d--]=B>>8&255),d>=0&&(a[d--]=B>>16&255),_===6?(d>=0&&(a[d--]=B>>24&255),m=0,_=0):(m=B>>>24,_+=2)}if(d>=0)for(a[d--]=m;d>=0;)a[d--]=0},Math.clz32?s.prototype._countBits=function(a){return 32-Math.clz32(a)}:s.prototype._countBits=function(a){var f=a,d=0;return f>=4096&&(d+=13,f>>>=13),f>=64&&(d+=7,f>>>=7),f>=8&&(d+=4,f>>>=4),f>=2&&(d+=2,f>>>=2),d+f},s.prototype._zeroBits=function(a){if(a===0)return 26;var f=a,d=0;return(f&8191)===0&&(d+=13,f>>>=13),(f&127)===0&&(d+=7,f>>>=7),(f&15)===0&&(d+=4,f>>>=4),(f&3)===0&&(d+=2,f>>>=2),(f&1)===0&&d++,d},s.prototype.bitLength=function(){var a=this.words[this.length-1],f=this._countBits(a);return(this.length-1)*26+f};function T(p){for(var a=new Array(p.bitLength()),f=0;f<a.length;f++){var d=f/26|0,m=f%26;a[f]=p.words[d]>>>m&1}return a}s.prototype.zeroBits=function(){if(this.isZero())return 0;for(var a=0,f=0;f<this.length;f++){var d=this._zeroBits(this.words[f]);if(a+=d,d!==26)break}return a},s.prototype.byteLength=function(){return Math.ceil(this.bitLength()/8)},s.prototype.toTwos=function(a){return this.negative!==0?this.abs().inotn(a).iaddn(1):this.clone()},s.prototype.fromTwos=function(a){return this.testn(a-1)?this.notn(a).iaddn(1).ineg():this.clone()},s.prototype.isNeg=function(){return this.negative!==0},s.prototype.neg=function(){return this.clone().ineg()},s.prototype.ineg=function(){return this.isZero()||(this.negative^=1),this},s.prototype.iuor=function(a){for(;this.length<a.length;)this.words[this.length++]=0;for(var f=0;f<a.length;f++)this.words[f]=this.words[f]|a.words[f];return this._strip()},s.prototype.ior=function(a){return r((this.negative|a.negative)===0),this.iuor(a)},s.prototype.or=function(a){return this.length>a.length?this.clone().ior(a):a.clone().ior(this)},s.prototype.uor=function(a){return this.length>a.length?this.clone().iuor(a):a.clone().iuor(this)},s.prototype.iuand=function(a){var f;this.length>a.length?f=a:f=this;for(var d=0;d<f.length;d++)this.words[d]=this.words[d]&a.words[d];return this.length=f.length,this._strip()},s.prototype.iand=function(a){return r((this.negative|a.negative)===0),this.iuand(a)},s.prototype.and=function(a){return this.length>a.length?this.clone().iand(a):a.clone().iand(this)},s.prototype.uand=function(a){return this.length>a.length?this.clone().iuand(a):a.clone().iuand(this)},s.prototype.iuxor=function(a){var f,d;this.length>a.length?(f=this,d=a):(f=a,d=this);for(var m=0;m<d.length;m++)this.words[m]=f.words[m]^d.words[m];if(this!==f)for(;m<f.length;m++)this.words[m]=f.words[m];return this.length=f.length,this._strip()},s.prototype.ixor=function(a){return r((this.negative|a.negative)===0),this.iuxor(a)},s.prototype.xor=function(a){return this.length>a.length?this.clone().ixor(a):a.clone().ixor(this)},s.prototype.uxor=function(a){return this.length>a.length?this.clone().iuxor(a):a.clone().iuxor(this)},s.prototype.inotn=function(a){r(typeof a=="number"&&a>=0);var f=Math.ceil(a/26)|0,d=a%26;this._expand(f),d>0&&f--;for(var m=0;m<f;m++)this.words[m]=~this.words[m]&67108863;return d>0&&(this.words[m]=~this.words[m]&67108863>>26-d),this._strip()},s.prototype.notn=function(a){return this.clone().inotn(a)},s.prototype.setn=function(a,f){r(typeof a=="number"&&a>=0);var d=a/26|0,m=a%26;return this._expand(d+1),f?this.words[d]=this.words[d]|1<<m:this.words[d]=this.words[d]&~(1<<m),this._strip()},s.prototype.iadd=function(a){var f;if(this.negative!==0&&a.negative===0)return this.negative=0,f=this.isub(a),this.negative^=1,this._normSign();if(this.negative===0&&a.negative!==0)return a.negative=0,f=this.isub(a),a.negative=1,f._normSign();var d,m;this.length>a.length?(d=this,m=a):(d=a,m=this);for(var w=0,_=0;_<m.length;_++)f=(d.words[_]|0)+(m.words[_]|0)+w,this.words[_]=f&67108863,w=f>>>26;for(;w!==0&&_<d.length;_++)f=(d.words[_]|0)+w,this.words[_]=f&67108863,w=f>>>26;if(this.length=d.length,w!==0)this.words[this.length]=w,this.length++;else if(d!==this)for(;_<d.length;_++)this.words[_]=d.words[_];return this},s.prototype.add=function(a){var f;return a.negative!==0&&this.negative===0?(a.negative=0,f=this.sub(a),a.negative^=1,f):a.negative===0&&this.negative!==0?(this.negative=0,f=a.sub(this),this.negative=1,f):this.length>a.length?this.clone().iadd(a):a.clone().iadd(this)},s.prototype.isub=function(a){if(a.negative!==0){a.negative=0;var f=this.iadd(a);return a.negative=1,f._normSign()}else if(this.negative!==0)return this.negative=0,this.iadd(a),this.negative=1,this._normSign();var d=this.cmp(a);if(d===0)return this.negative=0,this.length=1,this.words[0]=0,this;var m,w;d>0?(m=this,w=a):(m=a,w=this);for(var _=0,B=0;B<w.length;B++)f=(m.words[B]|0)-(w.words[B]|0)+_,_=f>>26,this.words[B]=f&67108863;for(;_!==0&&B<m.length;B++)f=(m.words[B]|0)+_,_=f>>26,this.words[B]=f&67108863;if(_===0&&B<m.length&&m!==this)for(;B<m.length;B++)this.words[B]=m.words[B];return this.length=Math.max(this.length,B),m!==this&&(this.negative=1),this._strip()},s.prototype.sub=function(a){return this.clone().isub(a)};function C(p,a,f){f.negative=a.negative^p.negative;var d=p.length+a.length|0;f.length=d,d=d-1|0;var m=p.words[0]|0,w=a.words[0]|0,_=m*w,B=_&67108863,b=_/67108864|0;f.words[0]=B;for(var c=1;c<d;c++){for(var u=b>>>26,g=b&67108863,v=Math.min(c,a.length-1),L=Math.max(0,c-p.length+1);L<=v;L++){var q=c-L|0;m=p.words[q]|0,w=a.words[L]|0,_=m*w+g,u+=_/67108864|0,g=_&67108863}f.words[c]=g|0,b=u|0}return b!==0?f.words[c]=b|0:f.length--,f._strip()}var D=function(a,f,d){var m=a.words,w=f.words,_=d.words,B=0,b,c,u,g=m[0]|0,v=g&8191,L=g>>>13,q=m[1]|0,X=q&8191,J=q>>>13,ht=m[2]|0,dt=ht&8191,mt=ht>>>13,Ir=m[3]|0,xt=Ir&8191,_t=Ir>>>13,ti=m[4]|0,Et=ti&8191,It=ti>>>13,ei=m[5]|0,At=ei&8191,Bt=ei>>>13,ri=m[6]|0,Rt=ri&8191,Mt=ri>>>13,ni=m[7]|0,Tt=ni&8191,Pt=ni>>>13,si=m[8]|0,Lt=si&8191,Ct=si>>>13,ii=m[9]|0,Ot=ii&8191,Nt=ii>>>13,oi=w[0]|0,Ut=oi&8191,zt=oi>>>13,ai=w[1]|0,Kt=ai&8191,qt=ai>>>13,ci=w[2]|0,Dt=ci&8191,Ft=ci>>>13,ui=w[3]|0,Wt=ui&8191,Vt=ui>>>13,fi=w[4]|0,Ht=fi&8191,$t=fi>>>13,li=w[5]|0,jt=li&8191,Gt=li>>>13,hi=w[6]|0,Zt=hi&8191,Yt=hi>>>13,di=w[7]|0,Xt=di&8191,Jt=di>>>13,pi=w[8]|0,Qt=pi&8191,te=pi>>>13,gi=w[9]|0,ee=gi&8191,re=gi>>>13;d.negative=a.negative^f.negative,d.length=19,b=Math.imul(v,Ut),c=Math.imul(v,zt),c=c+Math.imul(L,Ut)|0,u=Math.imul(L,zt);var _n=(B+b|0)+((c&8191)<<13)|0;B=(u+(c>>>13)|0)+(_n>>>26)|0,_n&=67108863,b=Math.imul(X,Ut),c=Math.imul(X,zt),c=c+Math.imul(J,Ut)|0,u=Math.imul(J,zt),b=b+Math.imul(v,Kt)|0,c=c+Math.imul(v,qt)|0,c=c+Math.imul(L,Kt)|0,u=u+Math.imul(L,qt)|0;var En=(B+b|0)+((c&8191)<<13)|0;B=(u+(c>>>13)|0)+(En>>>26)|0,En&=67108863,b=Math.imul(dt,Ut),c=Math.imul(dt,zt),c=c+Math.imul(mt,Ut)|0,u=Math.imul(mt,zt),b=b+Math.imul(X,Kt)|0,c=c+Math.imul(X,qt)|0,c=c+Math.imul(J,Kt)|0,u=u+Math.imul(J,qt)|0,b=b+Math.imul(v,Dt)|0,c=c+Math.imul(v,Ft)|0,c=c+Math.imul(L,Dt)|0,u=u+Math.imul(L,Ft)|0;var In=(B+b|0)+((c&8191)<<13)|0;B=(u+(c>>>13)|0)+(In>>>26)|0,In&=67108863,b=Math.imul(xt,Ut),c=Math.imul(xt,zt),c=c+Math.imul(_t,Ut)|0,u=Math.imul(_t,zt),b=b+Math.imul(dt,Kt)|0,c=c+Math.imul(dt,qt)|0,c=c+Math.imul(mt,Kt)|0,u=u+Math.imul(mt,qt)|0,b=b+Math.imul(X,Dt)|0,c=c+Math.imul(X,Ft)|0,c=c+Math.imul(J,Dt)|0,u=u+Math.imul(J,Ft)|0,b=b+Math.imul(v,Wt)|0,c=c+Math.imul(v,Vt)|0,c=c+Math.imul(L,Wt)|0,u=u+Math.imul(L,Vt)|0;var An=(B+b|0)+((c&8191)<<13)|0;B=(u+(c>>>13)|0)+(An>>>26)|0,An&=67108863,b=Math.imul(Et,Ut),c=Math.imul(Et,zt),c=c+Math.imul(It,Ut)|0,u=Math.imul(It,zt),b=b+Math.imul(xt,Kt)|0,c=c+Math.imul(xt,qt)|0,c=c+Math.imul(_t,Kt)|0,u=u+Math.imul(_t,qt)|0,b=b+Math.imul(dt,Dt)|0,c=c+Math.imul(dt,Ft)|0,c=c+Math.imul(mt,Dt)|0,u=u+Math.imul(mt,Ft)|0,b=b+Math.imul(X,Wt)|0,c=c+Math.imul(X,Vt)|0,c=c+Math.imul(J,Wt)|0,u=u+Math.imul(J,Vt)|0,b=b+Math.imul(v,Ht)|0,c=c+Math.imul(v,$t)|0,c=c+Math.imul(L,Ht)|0,u=u+Math.imul(L,$t)|0;var Bn=(B+b|0)+((c&8191)<<13)|0;B=(u+(c>>>13)|0)+(Bn>>>26)|0,Bn&=67108863,b=Math.imul(At,Ut),c=Math.imul(At,zt),c=c+Math.imul(Bt,Ut)|0,u=Math.imul(Bt,zt),b=b+Math.imul(Et,Kt)|0,c=c+Math.imul(Et,qt)|0,c=c+Math.imul(It,Kt)|0,u=u+Math.imul(It,qt)|0,b=b+Math.imul(xt,Dt)|0,c=c+Math.imul(xt,Ft)|0,c=c+Math.imul(_t,Dt)|0,u=u+Math.imul(_t,Ft)|0,b=b+Math.imul(dt,Wt)|0,c=c+Math.imul(dt,Vt)|0,c=c+Math.imul(mt,Wt)|0,u=u+Math.imul(mt,Vt)|0,b=b+Math.imul(X,Ht)|0,c=c+Math.imul(X,$t)|0,c=c+Math.imul(J,Ht)|0,u=u+Math.imul(J,$t)|0,b=b+Math.imul(v,jt)|0,c=c+Math.imul(v,Gt)|0,c=c+Math.imul(L,jt)|0,u=u+Math.imul(L,Gt)|0;var Rn=(B+b|0)+((c&8191)<<13)|0;B=(u+(c>>>13)|0)+(Rn>>>26)|0,Rn&=67108863,b=Math.imul(Rt,Ut),c=Math.imul(Rt,zt),c=c+Math.imul(Mt,Ut)|0,u=Math.imul(Mt,zt),b=b+Math.imul(At,Kt)|0,c=c+Math.imul(At,qt)|0,c=c+Math.imul(Bt,Kt)|0,u=u+Math.imul(Bt,qt)|0,b=b+Math.imul(Et,Dt)|0,c=c+Math.imul(Et,Ft)|0,c=c+Math.imul(It,Dt)|0,u=u+Math.imul(It,Ft)|0,b=b+Math.imul(xt,Wt)|0,c=c+Math.imul(xt,Vt)|0,c=c+Math.imul(_t,Wt)|0,u=u+Math.imul(_t,Vt)|0,b=b+Math.imul(dt,Ht)|0,c=c+Math.imul(dt,$t)|0,c=c+Math.imul(mt,Ht)|0,u=u+Math.imul(mt,$t)|0,b=b+Math.imul(X,jt)|0,c=c+Math.imul(X,Gt)|0,c=c+Math.imul(J,jt)|0,u=u+Math.imul(J,Gt)|0,b=b+Math.imul(v,Zt)|0,c=c+Math.imul(v,Yt)|0,c=c+Math.imul(L,Zt)|0,u=u+Math.imul(L,Yt)|0;var Mn=(B+b|0)+((c&8191)<<13)|0;B=(u+(c>>>13)|0)+(Mn>>>26)|0,Mn&=67108863,b=Math.imul(Tt,Ut),c=Math.imul(Tt,zt),c=c+Math.imul(Pt,Ut)|0,u=Math.imul(Pt,zt),b=b+Math.imul(Rt,Kt)|0,c=c+Math.imul(Rt,qt)|0,c=c+Math.imul(Mt,Kt)|0,u=u+Math.imul(Mt,qt)|0,b=b+Math.imul(At,Dt)|0,c=c+Math.imul(At,Ft)|0,c=c+Math.imul(Bt,Dt)|0,u=u+Math.imul(Bt,Ft)|0,b=b+Math.imul(Et,Wt)|0,c=c+Math.imul(Et,Vt)|0,c=c+Math.imul(It,Wt)|0,u=u+Math.imul(It,Vt)|0,b=b+Math.imul(xt,Ht)|0,c=c+Math.imul(xt,$t)|0,c=c+Math.imul(_t,Ht)|0,u=u+Math.imul(_t,$t)|0,b=b+Math.imul(dt,jt)|0,c=c+Math.imul(dt,Gt)|0,c=c+Math.imul(mt,jt)|0,u=u+Math.imul(mt,Gt)|0,b=b+Math.imul(X,Zt)|0,c=c+Math.imul(X,Yt)|0,c=c+Math.imul(J,Zt)|0,u=u+Math.imul(J,Yt)|0,b=b+Math.imul(v,Xt)|0,c=c+Math.imul(v,Jt)|0,c=c+Math.imul(L,Xt)|0,u=u+Math.imul(L,Jt)|0;var Tn=(B+b|0)+((c&8191)<<13)|0;B=(u+(c>>>13)|0)+(Tn>>>26)|0,Tn&=67108863,b=Math.imul(Lt,Ut),c=Math.imul(Lt,zt),c=c+Math.imul(Ct,Ut)|0,u=Math.imul(Ct,zt),b=b+Math.imul(Tt,Kt)|0,c=c+Math.imul(Tt,qt)|0,c=c+Math.imul(Pt,Kt)|0,u=u+Math.imul(Pt,qt)|0,b=b+Math.imul(Rt,Dt)|0,c=c+Math.imul(Rt,Ft)|0,c=c+Math.imul(Mt,Dt)|0,u=u+Math.imul(Mt,Ft)|0,b=b+Math.imul(At,Wt)|0,c=c+Math.imul(At,Vt)|0,c=c+Math.imul(Bt,Wt)|0,u=u+Math.imul(Bt,Vt)|0,b=b+Math.imul(Et,Ht)|0,c=c+Math.imul(Et,$t)|0,c=c+Math.imul(It,Ht)|0,u=u+Math.imul(It,$t)|0,b=b+Math.imul(xt,jt)|0,c=c+Math.imul(xt,Gt)|0,c=c+Math.imul(_t,jt)|0,u=u+Math.imul(_t,Gt)|0,b=b+Math.imul(dt,Zt)|0,c=c+Math.imul(dt,Yt)|0,c=c+Math.imul(mt,Zt)|0,u=u+Math.imul(mt,Yt)|0,b=b+Math.imul(X,Xt)|0,c=c+Math.imul(X,Jt)|0,c=c+Math.imul(J,Xt)|0,u=u+Math.imul(J,Jt)|0,b=b+Math.imul(v,Qt)|0,c=c+Math.imul(v,te)|0,c=c+Math.imul(L,Qt)|0,u=u+Math.imul(L,te)|0;var Pn=(B+b|0)+((c&8191)<<13)|0;B=(u+(c>>>13)|0)+(Pn>>>26)|0,Pn&=67108863,b=Math.imul(Ot,Ut),c=Math.imul(Ot,zt),c=c+Math.imul(Nt,Ut)|0,u=Math.imul(Nt,zt),b=b+Math.imul(Lt,Kt)|0,c=c+Math.imul(Lt,qt)|0,c=c+Math.imul(Ct,Kt)|0,u=u+Math.imul(Ct,qt)|0,b=b+Math.imul(Tt,Dt)|0,c=c+Math.imul(Tt,Ft)|0,c=c+Math.imul(Pt,Dt)|0,u=u+Math.imul(Pt,Ft)|0,b=b+Math.imul(Rt,Wt)|0,c=c+Math.imul(Rt,Vt)|0,c=c+Math.imul(Mt,Wt)|0,u=u+Math.imul(Mt,Vt)|0,b=b+Math.imul(At,Ht)|0,c=c+Math.imul(At,$t)|0,c=c+Math.imul(Bt,Ht)|0,u=u+Math.imul(Bt,$t)|0,b=b+Math.imul(Et,jt)|0,c=c+Math.imul(Et,Gt)|0,c=c+Math.imul(It,jt)|0,u=u+Math.imul(It,Gt)|0,b=b+Math.imul(xt,Zt)|0,c=c+Math.imul(xt,Yt)|0,c=c+Math.imul(_t,Zt)|0,u=u+Math.imul(_t,Yt)|0,b=b+Math.imul(dt,Xt)|0,c=c+Math.imul(dt,Jt)|0,c=c+Math.imul(mt,Xt)|0,u=u+Math.imul(mt,Jt)|0,b=b+Math.imul(X,Qt)|0,c=c+Math.imul(X,te)|0,c=c+Math.imul(J,Qt)|0,u=u+Math.imul(J,te)|0,b=b+Math.imul(v,ee)|0,c=c+Math.imul(v,re)|0,c=c+Math.imul(L,ee)|0,u=u+Math.imul(L,re)|0;var Ln=(B+b|0)+((c&8191)<<13)|0;B=(u+(c>>>13)|0)+(Ln>>>26)|0,Ln&=67108863,b=Math.imul(Ot,Kt),c=Math.imul(Ot,qt),c=c+Math.imul(Nt,Kt)|0,u=Math.imul(Nt,qt),b=b+Math.imul(Lt,Dt)|0,c=c+Math.imul(Lt,Ft)|0,c=c+Math.imul(Ct,Dt)|0,u=u+Math.imul(Ct,Ft)|0,b=b+Math.imul(Tt,Wt)|0,c=c+Math.imul(Tt,Vt)|0,c=c+Math.imul(Pt,Wt)|0,u=u+Math.imul(Pt,Vt)|0,b=b+Math.imul(Rt,Ht)|0,c=c+Math.imul(Rt,$t)|0,c=c+Math.imul(Mt,Ht)|0,u=u+Math.imul(Mt,$t)|0,b=b+Math.imul(At,jt)|0,c=c+Math.imul(At,Gt)|0,c=c+Math.imul(Bt,jt)|0,u=u+Math.imul(Bt,Gt)|0,b=b+Math.imul(Et,Zt)|0,c=c+Math.imul(Et,Yt)|0,c=c+Math.imul(It,Zt)|0,u=u+Math.imul(It,Yt)|0,b=b+Math.imul(xt,Xt)|0,c=c+Math.imul(xt,Jt)|0,c=c+Math.imul(_t,Xt)|0,u=u+Math.imul(_t,Jt)|0,b=b+Math.imul(dt,Qt)|0,c=c+Math.imul(dt,te)|0,c=c+Math.imul(mt,Qt)|0,u=u+Math.imul(mt,te)|0,b=b+Math.imul(X,ee)|0,c=c+Math.imul(X,re)|0,c=c+Math.imul(J,ee)|0,u=u+Math.imul(J,re)|0;var Cn=(B+b|0)+((c&8191)<<13)|0;B=(u+(c>>>13)|0)+(Cn>>>26)|0,Cn&=67108863,b=Math.imul(Ot,Dt),c=Math.imul(Ot,Ft),c=c+Math.imul(Nt,Dt)|0,u=Math.imul(Nt,Ft),b=b+Math.imul(Lt,Wt)|0,c=c+Math.imul(Lt,Vt)|0,c=c+Math.imul(Ct,Wt)|0,u=u+Math.imul(Ct,Vt)|0,b=b+Math.imul(Tt,Ht)|0,c=c+Math.imul(Tt,$t)|0,c=c+Math.imul(Pt,Ht)|0,u=u+Math.imul(Pt,$t)|0,b=b+Math.imul(Rt,jt)|0,c=c+Math.imul(Rt,Gt)|0,c=c+Math.imul(Mt,jt)|0,u=u+Math.imul(Mt,Gt)|0,b=b+Math.imul(At,Zt)|0,c=c+Math.imul(At,Yt)|0,c=c+Math.imul(Bt,Zt)|0,u=u+Math.imul(Bt,Yt)|0,b=b+Math.imul(Et,Xt)|0,c=c+Math.imul(Et,Jt)|0,c=c+Math.imul(It,Xt)|0,u=u+Math.imul(It,Jt)|0,b=b+Math.imul(xt,Qt)|0,c=c+Math.imul(xt,te)|0,c=c+Math.imul(_t,Qt)|0,u=u+Math.imul(_t,te)|0,b=b+Math.imul(dt,ee)|0,c=c+Math.imul(dt,re)|0,c=c+Math.imul(mt,ee)|0,u=u+Math.imul(mt,re)|0;var On=(B+b|0)+((c&8191)<<13)|0;B=(u+(c>>>13)|0)+(On>>>26)|0,On&=67108863,b=Math.imul(Ot,Wt),c=Math.imul(Ot,Vt),c=c+Math.imul(Nt,Wt)|0,u=Math.imul(Nt,Vt),b=b+Math.imul(Lt,Ht)|0,c=c+Math.imul(Lt,$t)|0,c=c+Math.imul(Ct,Ht)|0,u=u+Math.imul(Ct,$t)|0,b=b+Math.imul(Tt,jt)|0,c=c+Math.imul(Tt,Gt)|0,c=c+Math.imul(Pt,jt)|0,u=u+Math.imul(Pt,Gt)|0,b=b+Math.imul(Rt,Zt)|0,c=c+Math.imul(Rt,Yt)|0,c=c+Math.imul(Mt,Zt)|0,u=u+Math.imul(Mt,Yt)|0,b=b+Math.imul(At,Xt)|0,c=c+Math.imul(At,Jt)|0,c=c+Math.imul(Bt,Xt)|0,u=u+Math.imul(Bt,Jt)|0,b=b+Math.imul(Et,Qt)|0,c=c+Math.imul(Et,te)|0,c=c+Math.imul(It,Qt)|0,u=u+Math.imul(It,te)|0,b=b+Math.imul(xt,ee)|0,c=c+Math.imul(xt,re)|0,c=c+Math.imul(_t,ee)|0,u=u+Math.imul(_t,re)|0;var Nn=(B+b|0)+((c&8191)<<13)|0;B=(u+(c>>>13)|0)+(Nn>>>26)|0,Nn&=67108863,b=Math.imul(Ot,Ht),c=Math.imul(Ot,$t),c=c+Math.imul(Nt,Ht)|0,u=Math.imul(Nt,$t),b=b+Math.imul(Lt,jt)|0,c=c+Math.imul(Lt,Gt)|0,c=c+Math.imul(Ct,jt)|0,u=u+Math.imul(Ct,Gt)|0,b=b+Math.imul(Tt,Zt)|0,c=c+Math.imul(Tt,Yt)|0,c=c+Math.imul(Pt,Zt)|0,u=u+Math.imul(Pt,Yt)|0,b=b+Math.imul(Rt,Xt)|0,c=c+Math.imul(Rt,Jt)|0,c=c+Math.imul(Mt,Xt)|0,u=u+Math.imul(Mt,Jt)|0,b=b+Math.imul(At,Qt)|0,c=c+Math.imul(At,te)|0,c=c+Math.imul(Bt,Qt)|0,u=u+Math.imul(Bt,te)|0,b=b+Math.imul(Et,ee)|0,c=c+Math.imul(Et,re)|0,c=c+Math.imul(It,ee)|0,u=u+Math.imul(It,re)|0;var Un=(B+b|0)+((c&8191)<<13)|0;B=(u+(c>>>13)|0)+(Un>>>26)|0,Un&=67108863,b=Math.imul(Ot,jt),c=Math.imul(Ot,Gt),c=c+Math.imul(Nt,jt)|0,u=Math.imul(Nt,Gt),b=b+Math.imul(Lt,Zt)|0,c=c+Math.imul(Lt,Yt)|0,c=c+Math.imul(Ct,Zt)|0,u=u+Math.imul(Ct,Yt)|0,b=b+Math.imul(Tt,Xt)|0,c=c+Math.imul(Tt,Jt)|0,c=c+Math.imul(Pt,Xt)|0,u=u+Math.imul(Pt,Jt)|0,b=b+Math.imul(Rt,Qt)|0,c=c+Math.imul(Rt,te)|0,c=c+Math.imul(Mt,Qt)|0,u=u+Math.imul(Mt,te)|0,b=b+Math.imul(At,ee)|0,c=c+Math.imul(At,re)|0,c=c+Math.imul(Bt,ee)|0,u=u+Math.imul(Bt,re)|0;var zn=(B+b|0)+((c&8191)<<13)|0;B=(u+(c>>>13)|0)+(zn>>>26)|0,zn&=67108863,b=Math.imul(Ot,Zt),c=Math.imul(Ot,Yt),c=c+Math.imul(Nt,Zt)|0,u=Math.imul(Nt,Yt),b=b+Math.imul(Lt,Xt)|0,c=c+Math.imul(Lt,Jt)|0,c=c+Math.imul(Ct,Xt)|0,u=u+Math.imul(Ct,Jt)|0,b=b+Math.imul(Tt,Qt)|0,c=c+Math.imul(Tt,te)|0,c=c+Math.imul(Pt,Qt)|0,u=u+Math.imul(Pt,te)|0,b=b+Math.imul(Rt,ee)|0,c=c+Math.imul(Rt,re)|0,c=c+Math.imul(Mt,ee)|0,u=u+Math.imul(Mt,re)|0;var Kn=(B+b|0)+((c&8191)<<13)|0;B=(u+(c>>>13)|0)+(Kn>>>26)|0,Kn&=67108863,b=Math.imul(Ot,Xt),c=Math.imul(Ot,Jt),c=c+Math.imul(Nt,Xt)|0,u=Math.imul(Nt,Jt),b=b+Math.imul(Lt,Qt)|0,c=c+Math.imul(Lt,te)|0,c=c+Math.imul(Ct,Qt)|0,u=u+Math.imul(Ct,te)|0,b=b+Math.imul(Tt,ee)|0,c=c+Math.imul(Tt,re)|0,c=c+Math.imul(Pt,ee)|0,u=u+Math.imul(Pt,re)|0;var qn=(B+b|0)+((c&8191)<<13)|0;B=(u+(c>>>13)|0)+(qn>>>26)|0,qn&=67108863,b=Math.imul(Ot,Qt),c=Math.imul(Ot,te),c=c+Math.imul(Nt,Qt)|0,u=Math.imul(Nt,te),b=b+Math.imul(Lt,ee)|0,c=c+Math.imul(Lt,re)|0,c=c+Math.imul(Ct,ee)|0,u=u+Math.imul(Ct,re)|0;var Dn=(B+b|0)+((c&8191)<<13)|0;B=(u+(c>>>13)|0)+(Dn>>>26)|0,Dn&=67108863,b=Math.imul(Ot,ee),c=Math.imul(Ot,re),c=c+Math.imul(Nt,ee)|0,u=Math.imul(Nt,re);var Fn=(B+b|0)+((c&8191)<<13)|0;return B=(u+(c>>>13)|0)+(Fn>>>26)|0,Fn&=67108863,_[0]=_n,_[1]=En,_[2]=In,_[3]=An,_[4]=Bn,_[5]=Rn,_[6]=Mn,_[7]=Tn,_[8]=Pn,_[9]=Ln,_[10]=Cn,_[11]=On,_[12]=Nn,_[13]=Un,_[14]=zn,_[15]=Kn,_[16]=qn,_[17]=Dn,_[18]=Fn,B!==0&&(_[19]=B,d.length++),d};Math.imul||(D=C);function U(p,a,f){f.negative=a.negative^p.negative,f.length=p.length+a.length;for(var d=0,m=0,w=0;w<f.length-1;w++){var _=m;m=0;for(var B=d&67108863,b=Math.min(w,a.length-1),c=Math.max(0,w-p.length+1);c<=b;c++){var u=w-c,g=p.words[u]|0,v=a.words[c]|0,L=g*v,q=L&67108863;_=_+(L/67108864|0)|0,q=q+B|0,B=q&67108863,_=_+(q>>>26)|0,m+=_>>>26,_&=67108863}f.words[w]=B,d=_,_=m}return d!==0?f.words[w]=d:f.length--,f._strip()}function W(p,a,f){return U(p,a,f)}s.prototype.mulTo=function(a,f){var d,m=this.length+a.length;return this.length===10&&a.length===10?d=D(this,a,f):m<63?d=C(this,a,f):m<1024?d=U(this,a,f):d=W(this,a,f),d},s.prototype.mul=function(a){var f=new s(null);return f.words=new Array(this.length+a.length),this.mulTo(a,f)},s.prototype.mulf=function(a){var f=new s(null);return f.words=new Array(this.length+a.length),W(this,a,f)},s.prototype.imul=function(a){return this.clone().mulTo(a,this)},s.prototype.imuln=function(a){var f=a<0;f&&(a=-a),r(typeof a=="number"),r(a<67108864);for(var d=0,m=0;m<this.length;m++){var w=(this.words[m]|0)*a,_=(w&67108863)+(d&67108863);d>>=26,d+=w/67108864|0,d+=_>>>26,this.words[m]=_&67108863}return d!==0&&(this.words[m]=d,this.length++),this.length=a===0?1:this.length,f?this.ineg():this},s.prototype.muln=function(a){return this.clone().imuln(a)},s.prototype.sqr=function(){return this.mul(this)},s.prototype.isqr=function(){return this.imul(this.clone())},s.prototype.pow=function(a){var f=T(a);if(f.length===0)return new s(1);for(var d=this,m=0;m<f.length&&f[m]===0;m++,d=d.sqr());if(++m<f.length)for(var w=d.sqr();m<f.length;m++,w=w.sqr())f[m]!==0&&(d=d.mul(w));return d},s.prototype.iushln=function(a){r(typeof a=="number"&&a>=0);var f=a%26,d=(a-f)/26,m=67108863>>>26-f<<26-f,w;if(f!==0){var _=0;for(w=0;w<this.length;w++){var B=this.words[w]&m,b=(this.words[w]|0)-B<<f;this.words[w]=b|_,_=B>>>26-f}_&&(this.words[w]=_,this.length++)}if(d!==0){for(w=this.length-1;w>=0;w--)this.words[w+d]=this.words[w];for(w=0;w<d;w++)this.words[w]=0;this.length+=d}return this._strip()},s.prototype.ishln=function(a){return r(this.negative===0),this.iushln(a)},s.prototype.iushrn=function(a,f,d){r(typeof a=="number"&&a>=0);var m;f?m=(f-f%26)/26:m=0;var w=a%26,_=Math.min((a-w)/26,this.length),B=67108863^67108863>>>w<<w,b=d;if(m-=_,m=Math.max(0,m),b){for(var c=0;c<_;c++)b.words[c]=this.words[c];b.length=_}if(_!==0)if(this.length>_)for(this.length-=_,c=0;c<this.length;c++)this.words[c]=this.words[c+_];else this.words[0]=0,this.length=1;var u=0;for(c=this.length-1;c>=0&&(u!==0||c>=m);c--){var g=this.words[c]|0;this.words[c]=u<<26-w|g>>>w,u=g&B}return b&&u!==0&&(b.words[b.length++]=u),this.length===0&&(this.words[0]=0,this.length=1),this._strip()},s.prototype.ishrn=function(a,f,d){return r(this.negative===0),this.iushrn(a,f,d)},s.prototype.shln=function(a){return this.clone().ishln(a)},s.prototype.ushln=function(a){return this.clone().iushln(a)},s.prototype.shrn=function(a){return this.clone().ishrn(a)},s.prototype.ushrn=function(a){return this.clone().iushrn(a)},s.prototype.testn=function(a){r(typeof a=="number"&&a>=0);var f=a%26,d=(a-f)/26,m=1<<f;if(this.length<=d)return!1;var w=this.words[d];return!!(w&m)},s.prototype.imaskn=function(a){r(typeof a=="number"&&a>=0);var f=a%26,d=(a-f)/26;if(r(this.negative===0,"imaskn works only with positive numbers"),this.length<=d)return this;if(f!==0&&d++,this.length=Math.min(d,this.length),f!==0){var m=67108863^67108863>>>f<<f;this.words[this.length-1]&=m}return this._strip()},s.prototype.maskn=function(a){return this.clone().imaskn(a)},s.prototype.iaddn=function(a){return r(typeof a=="number"),r(a<67108864),a<0?this.isubn(-a):this.negative!==0?this.length===1&&(this.words[0]|0)<=a?(this.words[0]=a-(this.words[0]|0),this.negative=0,this):(this.negative=0,this.isubn(a),this.negative=1,this):this._iaddn(a)},s.prototype._iaddn=function(a){this.words[0]+=a;for(var f=0;f<this.length&&this.words[f]>=67108864;f++)this.words[f]-=67108864,f===this.length-1?this.words[f+1]=1:this.words[f+1]++;return this.length=Math.max(this.length,f+1),this},s.prototype.isubn=function(a){if(r(typeof a=="number"),r(a<67108864),a<0)return this.iaddn(-a);if(this.negative!==0)return this.negative=0,this.iaddn(a),this.negative=1,this;if(this.words[0]-=a,this.length===1&&this.words[0]<0)this.words[0]=-this.words[0],this.negative=1;else for(var f=0;f<this.length&&this.words[f]<0;f++)this.words[f]+=67108864,this.words[f+1]-=1;return this._strip()},s.prototype.addn=function(a){return this.clone().iaddn(a)},s.prototype.subn=function(a){return this.clone().isubn(a)},s.prototype.iabs=function(){return this.negative=0,this},s.prototype.abs=function(){return this.clone().iabs()},s.prototype._ishlnsubmul=function(a,f,d){var m=a.length+d,w;this._expand(m);var _,B=0;for(w=0;w<a.length;w++){_=(this.words[w+d]|0)+B;var b=(a.words[w]|0)*f;_-=b&67108863,B=(_>>26)-(b/67108864|0),this.words[w+d]=_&67108863}for(;w<this.length-d;w++)_=(this.words[w+d]|0)+B,B=_>>26,this.words[w+d]=_&67108863;if(B===0)return this._strip();for(r(B===-1),B=0,w=0;w<this.length;w++)_=-(this.words[w]|0)+B,B=_>>26,this.words[w]=_&67108863;return this.negative=1,this._strip()},s.prototype._wordDiv=function(a,f){var d=this.length-a.length,m=this.clone(),w=a,_=w.words[w.length-1]|0,B=this._countBits(_);d=26-B,d!==0&&(w=w.ushln(d),m.iushln(d),_=w.words[w.length-1]|0);var b=m.length-w.length,c;if(f!=="mod"){c=new s(null),c.length=b+1,c.words=new Array(c.length);for(var u=0;u<c.length;u++)c.words[u]=0}var g=m.clone()._ishlnsubmul(w,1,b);g.negative===0&&(m=g,c&&(c.words[b]=1));for(var v=b-1;v>=0;v--){var L=(m.words[w.length+v]|0)*67108864+(m.words[w.length+v-1]|0);for(L=Math.min(L/_|0,67108863),m._ishlnsubmul(w,L,v);m.negative!==0;)L--,m.negative=0,m._ishlnsubmul(w,1,v),m.isZero()||(m.negative^=1);c&&(c.words[v]=L)}return c&&c._strip(),m._strip(),f!=="div"&&d!==0&&m.iushrn(d),{div:c||null,mod:m}},s.prototype.divmod=function(a,f,d){if(r(!a.isZero()),this.isZero())return{div:new s(0),mod:new s(0)};var m,w,_;return this.negative!==0&&a.negative===0?(_=this.neg().divmod(a,f),f!=="mod"&&(m=_.div.neg()),f!=="div"&&(w=_.mod.neg(),d&&w.negative!==0&&w.iadd(a)),{div:m,mod:w}):this.negative===0&&a.negative!==0?(_=this.divmod(a.neg(),f),f!=="mod"&&(m=_.div.neg()),{div:m,mod:_.mod}):(this.negative&a.negative)!==0?(_=this.neg().divmod(a.neg(),f),f!=="div"&&(w=_.mod.neg(),d&&w.negative!==0&&w.isub(a)),{div:_.div,mod:w}):a.length>this.length||this.cmp(a)<0?{div:new s(0),mod:this}:a.length===1?f==="div"?{div:this.divn(a.words[0]),mod:null}:f==="mod"?{div:null,mod:new s(this.modrn(a.words[0]))}:{div:this.divn(a.words[0]),mod:new s(this.modrn(a.words[0]))}:this._wordDiv(a,f)},s.prototype.div=function(a){return this.divmod(a,"div",!1).div},s.prototype.mod=function(a){return this.divmod(a,"mod",!1).mod},s.prototype.umod=function(a){return this.divmod(a,"mod",!0).mod},s.prototype.divRound=function(a){var f=this.divmod(a);if(f.mod.isZero())return f.div;var d=f.div.negative!==0?f.mod.isub(a):f.mod,m=a.ushrn(1),w=a.andln(1),_=d.cmp(m);return _<0||w===1&&_===0?f.div:f.div.negative!==0?f.div.isubn(1):f.div.iaddn(1)},s.prototype.modrn=function(a){var f=a<0;f&&(a=-a),r(a<=67108863);for(var d=(1<<26)%a,m=0,w=this.length-1;w>=0;w--)m=(d*m+(this.words[w]|0))%a;return f?-m:m},s.prototype.modn=function(a){return this.modrn(a)},s.prototype.idivn=function(a){var f=a<0;f&&(a=-a),r(a<=67108863);for(var d=0,m=this.length-1;m>=0;m--){var w=(this.words[m]|0)+d*67108864;this.words[m]=w/a|0,d=w%a}return this._strip(),f?this.ineg():this},s.prototype.divn=function(a){return this.clone().idivn(a)},s.prototype.egcd=function(a){r(a.negative===0),r(!a.isZero());var f=this,d=a.clone();f.negative!==0?f=f.umod(a):f=f.clone();for(var m=new s(1),w=new s(0),_=new s(0),B=new s(1),b=0;f.isEven()&&d.isEven();)f.iushrn(1),d.iushrn(1),++b;for(var c=d.clone(),u=f.clone();!f.isZero();){for(var g=0,v=1;(f.words[0]&v)===0&&g<26;++g,v<<=1);if(g>0)for(f.iushrn(g);g-- >0;)(m.isOdd()||w.isOdd())&&(m.iadd(c),w.isub(u)),m.iushrn(1),w.iushrn(1);for(var L=0,q=1;(d.words[0]&q)===0&&L<26;++L,q<<=1);if(L>0)for(d.iushrn(L);L-- >0;)(_.isOdd()||B.isOdd())&&(_.iadd(c),B.isub(u)),_.iushrn(1),B.iushrn(1);f.cmp(d)>=0?(f.isub(d),m.isub(_),w.isub(B)):(d.isub(f),_.isub(m),B.isub(w))}return{a:_,b:B,gcd:d.iushln(b)}},s.prototype._invmp=function(a){r(a.negative===0),r(!a.isZero());var f=this,d=a.clone();f.negative!==0?f=f.umod(a):f=f.clone();for(var m=new s(1),w=new s(0),_=d.clone();f.cmpn(1)>0&&d.cmpn(1)>0;){for(var B=0,b=1;(f.words[0]&b)===0&&B<26;++B,b<<=1);if(B>0)for(f.iushrn(B);B-- >0;)m.isOdd()&&m.iadd(_),m.iushrn(1);for(var c=0,u=1;(d.words[0]&u)===0&&c<26;++c,u<<=1);if(c>0)for(d.iushrn(c);c-- >0;)w.isOdd()&&w.iadd(_),w.iushrn(1);f.cmp(d)>=0?(f.isub(d),m.isub(w)):(d.isub(f),w.isub(m))}var g;return f.cmpn(1)===0?g=m:g=w,g.cmpn(0)<0&&g.iadd(a),g},s.prototype.gcd=function(a){if(this.isZero())return a.abs();if(a.isZero())return this.abs();var f=this.clone(),d=a.clone();f.negative=0,d.negative=0;for(var m=0;f.isEven()&&d.isEven();m++)f.iushrn(1),d.iushrn(1);do{for(;f.isEven();)f.iushrn(1);for(;d.isEven();)d.iushrn(1);var w=f.cmp(d);if(w<0){var _=f;f=d,d=_}else if(w===0||d.cmpn(1)===0)break;f.isub(d)}while(!0);return d.iushln(m)},s.prototype.invm=function(a){return this.egcd(a).a.umod(a)},s.prototype.isEven=function(){return(this.words[0]&1)===0},s.prototype.isOdd=function(){return(this.words[0]&1)===1},s.prototype.andln=function(a){return this.words[0]&a},s.prototype.bincn=function(a){r(typeof a=="number");var f=a%26,d=(a-f)/26,m=1<<f;if(this.length<=d)return this._expand(d+1),this.words[d]|=m,this;for(var w=m,_=d;w!==0&&_<this.length;_++){var B=this.words[_]|0;B+=w,w=B>>>26,B&=67108863,this.words[_]=B}return w!==0&&(this.words[_]=w,this.length++),this},s.prototype.isZero=function(){return this.length===1&&this.words[0]===0},s.prototype.cmpn=function(a){var f=a<0;if(this.negative!==0&&!f)return-1;if(this.negative===0&&f)return 1;this._strip();var d;if(this.length>1)d=1;else{f&&(a=-a),r(a<=67108863,"Number is too big");var m=this.words[0]|0;d=m===a?0:m<a?-1:1}return this.negative!==0?-d|0:d},s.prototype.cmp=function(a){if(this.negative!==0&&a.negative===0)return-1;if(this.negative===0&&a.negative!==0)return 1;var f=this.ucmp(a);return this.negative!==0?-f|0:f},s.prototype.ucmp=function(a){if(this.length>a.length)return 1;if(this.length<a.length)return-1;for(var f=0,d=this.length-1;d>=0;d--){var m=this.words[d]|0,w=a.words[d]|0;if(m!==w){m<w?f=-1:m>w&&(f=1);break}}return f},s.prototype.gtn=function(a){return this.cmpn(a)===1},s.prototype.gt=function(a){return this.cmp(a)===1},s.prototype.gten=function(a){return this.cmpn(a)>=0},s.prototype.gte=function(a){return this.cmp(a)>=0},s.prototype.ltn=function(a){return this.cmpn(a)===-1},s.prototype.lt=function(a){return this.cmp(a)===-1},s.prototype.lten=function(a){return this.cmpn(a)<=0},s.prototype.lte=function(a){return this.cmp(a)<=0},s.prototype.eqn=function(a){return this.cmpn(a)===0},s.prototype.eq=function(a){return this.cmp(a)===0},s.red=function(a){return new N(a)},s.prototype.toRed=function(a){return r(!this.red,"Already a number in reduction context"),r(this.negative===0,"red works only with positives"),a.convertTo(this)._forceRed(a)},s.prototype.fromRed=function(){return r(this.red,"fromRed works only with numbers in reduction context"),this.red.convertFrom(this)},s.prototype._forceRed=function(a){return this.red=a,this},s.prototype.forceRed=function(a){return r(!this.red,"Already a number in reduction context"),this._forceRed(a)},s.prototype.redAdd=function(a){return r(this.red,"redAdd works only with red numbers"),this.red.add(this,a)},s.prototype.redIAdd=function(a){return r(this.red,"redIAdd works only with red numbers"),this.red.iadd(this,a)},s.prototype.redSub=function(a){return r(this.red,"redSub works only with red numbers"),this.red.sub(this,a)},s.prototype.redISub=function(a){return r(this.red,"redISub works only with red numbers"),this.red.isub(this,a)},s.prototype.redShl=function(a){return r(this.red,"redShl works only with red numbers"),this.red.shl(this,a)},s.prototype.redMul=function(a){return r(this.red,"redMul works only with red numbers"),this.red._verify2(this,a),this.red.mul(this,a)},s.prototype.redIMul=function(a){return r(this.red,"redMul works only with red numbers"),this.red._verify2(this,a),this.red.imul(this,a)},s.prototype.redSqr=function(){return r(this.red,"redSqr works only with red numbers"),this.red._verify1(this),this.red.sqr(this)},s.prototype.redISqr=function(){return r(this.red,"redISqr works only with red numbers"),this.red._verify1(this),this.red.isqr(this)},s.prototype.redSqrt=function(){return r(this.red,"redSqrt works only with red numbers"),this.red._verify1(this),this.red.sqrt(this)},s.prototype.redInvm=function(){return r(this.red,"redInvm works only with red numbers"),this.red._verify1(this),this.red.invm(this)},s.prototype.redNeg=function(){return r(this.red,"redNeg works only with red numbers"),this.red._verify1(this),this.red.neg(this)},s.prototype.redPow=function(a){return r(this.red&&!a.red,"redPow(normalNum)"),this.red._verify1(this),this.red.pow(this,a)};var G={k256:null,p224:null,p192:null,p25519:null};function $(p,a){this.name=p,this.p=new s(a,16),this.n=this.p.bitLength(),this.k=new s(1).iushln(this.n).isub(this.p),this.tmp=this._tmp()}$.prototype._tmp=function(){var a=new s(null);return a.words=new Array(Math.ceil(this.n/13)),a},$.prototype.ireduce=function(a){var f=a,d;do this.split(f,this.tmp),f=this.imulK(f),f=f.iadd(this.tmp),d=f.bitLength();while(d>this.n);var m=d<this.n?-1:f.ucmp(this.p);return m===0?(f.words[0]=0,f.length=1):m>0?f.isub(this.p):f.strip!==void 0?f.strip():f._strip(),f},$.prototype.split=function(a,f){a.iushrn(this.n,0,f)},$.prototype.imulK=function(a){return a.imul(this.k)};function rt(){$.call(this,"k256","ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")}i(rt,$),rt.prototype.split=function(a,f){for(var d=4194303,m=Math.min(a.length,9),w=0;w<m;w++)f.words[w]=a.words[w];if(f.length=m,a.length<=9){a.words[0]=0,a.length=1;return}var _=a.words[9];for(f.words[f.length++]=_&d,w=10;w<a.length;w++){var B=a.words[w]|0;a.words[w-10]=(B&d)<<4|_>>>22,_=B}_>>>=22,a.words[w-10]=_,_===0&&a.length>10?a.length-=10:a.length-=9},rt.prototype.imulK=function(a){a.words[a.length]=0,a.words[a.length+1]=0,a.length+=2;for(var f=0,d=0;d<a.length;d++){var m=a.words[d]|0;f+=m*977,a.words[d]=f&67108863,f=m*64+(f/67108864|0)}return a.words[a.length-1]===0&&(a.length--,a.words[a.length-1]===0&&a.length--),a};function Q(){$.call(this,"p224","ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")}i(Q,$);function M(){$.call(this,"p192","ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")}i(M,$);function P(){$.call(this,"25519","7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")}i(P,$),P.prototype.imulK=function(a){for(var f=0,d=0;d<a.length;d++){var m=(a.words[d]|0)*19+f,w=m&67108863;m>>>=26,a.words[d]=w,f=m}return f!==0&&(a.words[a.length++]=f),a},s._prime=function(a){if(G[a])return G[a];var f;if(a==="k256")f=new rt;else if(a==="p224")f=new Q;else if(a==="p192")f=new M;else if(a==="p25519")f=new P;else throw new Error("Unknown prime "+a);return G[a]=f,f};function N(p){if(typeof p=="string"){var a=s._prime(p);this.m=a.p,this.prime=a}else r(p.gtn(1),"modulus must be greater than 1"),this.m=p,this.prime=null}N.prototype._verify1=function(a){r(a.negative===0,"red works only with positives"),r(a.red,"red works only with red numbers")},N.prototype._verify2=function(a,f){r((a.negative|f.negative)===0,"red works only with positives"),r(a.red&&a.red===f.red,"red works only with red numbers")},N.prototype.imod=function(a){return this.prime?this.prime.ireduce(a)._forceRed(this):(S(a,a.umod(this.m)._forceRed(this)),a)},N.prototype.neg=function(a){return a.isZero()?a.clone():this.m.sub(a)._forceRed(this)},N.prototype.add=function(a,f){this._verify2(a,f);var d=a.add(f);return d.cmp(this.m)>=0&&d.isub(this.m),d._forceRed(this)},N.prototype.iadd=function(a,f){this._verify2(a,f);var d=a.iadd(f);return d.cmp(this.m)>=0&&d.isub(this.m),d},N.prototype.sub=function(a,f){this._verify2(a,f);var d=a.sub(f);return d.cmpn(0)<0&&d.iadd(this.m),d._forceRed(this)},N.prototype.isub=function(a,f){this._verify2(a,f);var d=a.isub(f);return d.cmpn(0)<0&&d.iadd(this.m),d},N.prototype.shl=function(a,f){return this._verify1(a),this.imod(a.ushln(f))},N.prototype.imul=function(a,f){return this._verify2(a,f),this.imod(a.imul(f))},N.prototype.mul=function(a,f){return this._verify2(a,f),this.imod(a.mul(f))},N.prototype.isqr=function(a){return this.imul(a,a.clone())},N.prototype.sqr=function(a){return this.mul(a,a)},N.prototype.sqrt=function(a){if(a.isZero())return a.clone();var f=this.m.andln(3);if(r(f%2===1),f===3){var d=this.m.add(new s(1)).iushrn(2);return this.pow(a,d)}for(var m=this.m.subn(1),w=0;!m.isZero()&&m.andln(1)===0;)w++,m.iushrn(1);r(!m.isZero());var _=new s(1).toRed(this),B=_.redNeg(),b=this.m.subn(1).iushrn(1),c=this.m.bitLength();for(c=new s(2*c*c).toRed(this);this.pow(c,b).cmp(B)!==0;)c.redIAdd(B);for(var u=this.pow(c,m),g=this.pow(a,m.addn(1).iushrn(1)),v=this.pow(a,m),L=w;v.cmp(_)!==0;){for(var q=v,X=0;q.cmp(_)!==0;X++)q=q.redSqr();r(X<L);var J=this.pow(u,new s(1).iushln(L-X-1));g=g.redMul(J),u=J.redSqr(),v=v.redMul(u),L=X}return g},N.prototype.invm=function(a){var f=a._invmp(this.m);return f.negative!==0?(f.negative=0,this.imod(f).redNeg()):this.imod(f)},N.prototype.pow=function(a,f){if(f.isZero())return new s(1).toRed(this);if(f.cmpn(1)===0)return a.clone();var d=4,m=new Array(1<<d);m[0]=new s(1).toRed(this),m[1]=a;for(var w=2;w<m.length;w++)m[w]=this.mul(m[w-1],a);var _=m[0],B=0,b=0,c=f.bitLength()%26;for(c===0&&(c=26),w=f.length-1;w>=0;w--){for(var u=f.words[w],g=c-1;g>=0;g--){var v=u>>g&1;if(_!==m[0]&&(_=this.sqr(_)),v===0&&B===0){b=0;continue}B<<=1,B|=v,b++,!(b!==d&&(w!==0||g!==0))&&(_=this.mul(_,m[B]),b=0,B=0)}c=26}return _},N.prototype.convertTo=function(a){var f=a.umod(this.m);return f===a?f.clone():f},N.prototype.convertFrom=function(a){var f=a.clone();return f.red=null,f},s.mont=function(a){return new K(a)};function K(p){N.call(this,p),this.shift=this.m.bitLength(),this.shift%26!==0&&(this.shift+=26-this.shift%26),this.r=new s(1).iushln(this.shift),this.r2=this.imod(this.r.sqr()),this.rinv=this.r._invmp(this.m),this.minv=this.rinv.mul(this.r).isubn(1).div(this.m),this.minv=this.minv.umod(this.r),this.minv=this.r.sub(this.minv)}i(K,N),K.prototype.convertTo=function(a){return this.imod(a.ushln(this.shift))},K.prototype.convertFrom=function(a){var f=this.imod(a.mul(this.rinv));return f.red=null,f},K.prototype.imul=function(a,f){if(a.isZero()||f.isZero())return a.words[0]=0,a.length=1,a;var d=a.imul(f),m=d.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),w=d.isub(m).iushrn(this.shift),_=w;return w.cmp(this.m)>=0?_=w.isub(this.m):w.cmpn(0)<0&&(_=w.iadd(this.m)),_._forceRed(this)},K.prototype.mul=function(a,f){if(a.isZero()||f.isZero())return new s(0)._forceRed(this);var d=a.mul(f),m=d.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),w=d.isub(m).iushrn(this.shift),_=w;return w.cmp(this.m)>=0?_=w.isub(this.m):w.cmpn(0)<0&&(_=w.iadd(this.m)),_._forceRed(this)},K.prototype.invm=function(a){var f=this.imod(a._invmp(this.m).mul(this.r2));return f._forceRed(this)}})(n,zc)})(Yr)),Yr.exports}var Kc=Fo();const Mi=fn(Kc);var Zn,Ti;function qc(){if(Ti)return Zn;Ti=1;var n=po().Buffer;function t(e){if(e.length>=255)throw new TypeError("Alphabet too long");for(var r=new Uint8Array(256),i=0;i<r.length;i++)r[i]=255;for(var s=0;s<e.length;s++){var o=e.charAt(s),h=o.charCodeAt(0);if(r[h]!==255)throw new TypeError(o+" is ambiguous");r[h]=s}var l=e.length,y=e.charAt(0),S=Math.log(l)/Math.log(256),I=Math.log(256)/Math.log(l);function x(A){if((Array.isArray(A)||A instanceof Uint8Array)&&(A=n.from(A)),!n.isBuffer(A))throw new TypeError("Expected Buffer");if(A.length===0)return"";for(var T=0,C=0,D=0,U=A.length;D!==U&&A[D]===0;)D++,T++;for(var W=(U-D)*I+1>>>0,G=new Uint8Array(W);D!==U;){for(var $=A[D],rt=0,Q=W-1;($!==0||rt<C)&&Q!==-1;Q--,rt++)$+=256*G[Q]>>>0,G[Q]=$%l>>>0,$=$/l>>>0;if($!==0)throw new Error("Non-zero carry");C=rt,D++}for(var M=W-C;M!==W&&G[M]===0;)M++;for(var P=y.repeat(T);M<W;++M)P+=e.charAt(G[M]);return P}function k(A){if(typeof A!="string")throw new TypeError("Expected String");if(A.length===0)return n.alloc(0);for(var T=0,C=0,D=0;A[T]===y;)C++,T++;for(var U=(A.length-T)*S+1>>>0,W=new Uint8Array(U);T<A.length;){var G=A.charCodeAt(T);if(G>255)return;var $=r[G];if($===255)return;for(var rt=0,Q=U-1;($!==0||rt<D)&&Q!==-1;Q--,rt++)$+=l*W[Q]>>>0,W[Q]=$%256>>>0,$=$/256>>>0;if($!==0)throw new Error("Non-zero carry");D=rt,T++}for(var M=U-D;M!==U&&W[M]===0;)M++;var P=n.allocUnsafe(C+(U-M));P.fill(0,0,C);for(var N=C;M!==U;)P[N++]=W[M++];return P}function R(A){var T=k(A);if(T)return T;throw new Error("Non-base"+l+" character")}return{encode:x,decodeUnsafe:k,decode:R}}return Zn=t,Zn}var Yn,Pi;function Dc(){if(Pi)return Yn;Pi=1;var n=qc(),t="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";return Yn=n(t),Yn}var Fc=Dc();const ce=fn(Fc),Li=ko;var lt={},Xn,Ci;function Wc(){if(Ci)return Xn;Ci=1;var n=po().Buffer;function t(e){if(e.length>=255)throw new TypeError("Alphabet too long");for(var r=new Uint8Array(256),i=0;i<r.length;i++)r[i]=255;for(var s=0;s<e.length;s++){var o=e.charAt(s),h=o.charCodeAt(0);if(r[h]!==255)throw new TypeError(o+" is ambiguous");r[h]=s}var l=e.length,y=e.charAt(0),S=Math.log(l)/Math.log(256),I=Math.log(256)/Math.log(l);function x(A){if((Array.isArray(A)||A instanceof Uint8Array)&&(A=n.from(A)),!n.isBuffer(A))throw new TypeError("Expected Buffer");if(A.length===0)return"";for(var T=0,C=0,D=0,U=A.length;D!==U&&A[D]===0;)D++,T++;for(var W=(U-D)*I+1>>>0,G=new Uint8Array(W);D!==U;){for(var $=A[D],rt=0,Q=W-1;($!==0||rt<C)&&Q!==-1;Q--,rt++)$+=256*G[Q]>>>0,G[Q]=$%l>>>0,$=$/l>>>0;if($!==0)throw new Error("Non-zero carry");C=rt,D++}for(var M=W-C;M!==W&&G[M]===0;)M++;for(var P=y.repeat(T);M<W;++M)P+=e.charAt(G[M]);return P}function k(A){if(typeof A!="string")throw new TypeError("Expected String");if(A.length===0)return n.alloc(0);for(var T=0,C=0,D=0;A[T]===y;)C++,T++;for(var U=(A.length-T)*S+1>>>0,W=new Uint8Array(U);T<A.length;){var G=A.charCodeAt(T);if(G>255)return;var $=r[G];if($===255)return;for(var rt=0,Q=U-1;($!==0||rt<D)&&Q!==-1;Q--,rt++)$+=l*W[Q]>>>0,W[Q]=$%256>>>0,$=$/256>>>0;if($!==0)throw new Error("Non-zero carry");D=rt,T++}for(var M=U-D;M!==U&&W[M]===0;)M++;var P=n.allocUnsafe(C+(U-M));P.fill(0,0,C);for(var N=C;M!==U;)P[N++]=W[M++];return P}function R(A){var T=k(A);if(T)return T;throw new Error("Non-base"+l+" character")}return{encode:x,decodeUnsafe:k,decode:R}}return Xn=t,Xn}var Jn,Oi;function Vc(){if(Oi)return Jn;Oi=1;var n=Wc(),t="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";return Jn=n(t),Jn}function Ne(n,t,e){return t<=n&&n<=e}function dn(n){if(n===void 0)return{};if(n===Object(n))return n;throw TypeError("Could not convert argument to dictionary")}function Hc(n){for(var t=String(n),e=t.length,r=0,i=[];r<e;){var s=t.charCodeAt(r);if(s<55296||s>57343)i.push(s);else if(56320<=s&&s<=57343)i.push(65533);else if(55296<=s&&s<=56319)if(r===e-1)i.push(65533);else{var o=n.charCodeAt(r+1);if(56320<=o&&o<=57343){var h=s&1023,l=o&1023;i.push(65536+(h<<10)+l),r+=1}else i.push(65533)}r+=1}return i}function $c(n){for(var t="",e=0;e<n.length;++e){var r=n[e];r<=65535?t+=String.fromCharCode(r):(r-=65536,t+=String.fromCharCode((r>>10)+55296,(r&1023)+56320))}return t}var rn=-1;function Ls(n){this.tokens=[].slice.call(n)}Ls.prototype={endOfStream:function(){return!this.tokens.length},read:function(){return this.tokens.length?this.tokens.shift():rn},prepend:function(n){if(Array.isArray(n))for(var t=n;t.length;)this.tokens.unshift(t.pop());else this.tokens.unshift(n)},push:function(n){if(Array.isArray(n))for(var t=n;t.length;)this.tokens.push(t.shift());else this.tokens.push(n)}};var wr=-1;function Qn(n,t){if(n)throw TypeError("Decoder error");return t||65533}var nn="utf-8";function sn(n,t){if(!(this instanceof sn))return new sn(n,t);if(n=n!==void 0?String(n).toLowerCase():nn,n!==nn)throw new Error("Encoding not supported. Only utf-8 is supported");t=dn(t),this._streaming=!1,this._BOMseen=!1,this._decoder=null,this._fatal=!!t.fatal,this._ignoreBOM=!!t.ignoreBOM,Object.defineProperty(this,"encoding",{value:"utf-8"}),Object.defineProperty(this,"fatal",{value:this._fatal}),Object.defineProperty(this,"ignoreBOM",{value:this._ignoreBOM})}sn.prototype={decode:function(t,e){var r;typeof t=="object"&&t instanceof ArrayBuffer?r=new Uint8Array(t):typeof t=="object"&&"buffer"in t&&t.buffer instanceof ArrayBuffer?r=new Uint8Array(t.buffer,t.byteOffset,t.byteLength):r=new Uint8Array(0),e=dn(e),this._streaming||(this._decoder=new jc({fatal:this._fatal}),this._BOMseen=!1),this._streaming=!!e.stream;for(var i=new Ls(r),s=[],o;!i.endOfStream()&&(o=this._decoder.handler(i,i.read()),o!==wr);)o!==null&&(Array.isArray(o)?s.push.apply(s,o):s.push(o));if(!this._streaming){do{if(o=this._decoder.handler(i,i.read()),o===wr)break;o!==null&&(Array.isArray(o)?s.push.apply(s,o):s.push(o))}while(!i.endOfStream());this._decoder=null}return s.length&&["utf-8"].indexOf(this.encoding)!==-1&&!this._ignoreBOM&&!this._BOMseen&&(s[0]===65279?(this._BOMseen=!0,s.shift()):this._BOMseen=!0),$c(s)}};function on(n,t){if(!(this instanceof on))return new on(n,t);if(n=n!==void 0?String(n).toLowerCase():nn,n!==nn)throw new Error("Encoding not supported. Only utf-8 is supported");t=dn(t),this._streaming=!1,this._encoder=null,this._options={fatal:!!t.fatal},Object.defineProperty(this,"encoding",{value:"utf-8"})}on.prototype={encode:function(t,e){t=t?String(t):"",e=dn(e),this._streaming||(this._encoder=new Gc(this._options)),this._streaming=!!e.stream;for(var r=[],i=new Ls(Hc(t)),s;!i.endOfStream()&&(s=this._encoder.handler(i,i.read()),s!==wr);)Array.isArray(s)?r.push.apply(r,s):r.push(s);if(!this._streaming){for(;s=this._encoder.handler(i,i.read()),s!==wr;)Array.isArray(s)?r.push.apply(r,s):r.push(s);this._encoder=null}return new Uint8Array(r)}};function jc(n){var t=n.fatal,e=0,r=0,i=0,s=128,o=191;this.handler=function(h,l){if(l===rn&&i!==0)return i=0,Qn(t);if(l===rn)return wr;if(i===0){if(Ne(l,0,127))return l;if(Ne(l,194,223))i=1,e=l-192;else if(Ne(l,224,239))l===224&&(s=160),l===237&&(o=159),i=2,e=l-224;else if(Ne(l,240,244))l===240&&(s=144),l===244&&(o=143),i=3,e=l-240;else return Qn(t);return e=e<<6*i,null}if(!Ne(l,s,o))return e=i=r=0,s=128,o=191,h.prepend(l),Qn(t);if(s=128,o=191,r+=1,e+=l-128<<6*(i-r),r!==i)return null;var y=e;return e=i=r=0,y}}function Gc(n){n.fatal,this.handler=function(t,e){if(e===rn)return wr;if(Ne(e,0,127))return e;var r,i;Ne(e,128,2047)?(r=1,i=192):Ne(e,2048,65535)?(r=2,i=224):Ne(e,65536,1114111)&&(r=3,i=240);for(var s=[(e>>6*r)+i];r>0;){var o=e>>6*(r-1);s.push(128|o&63),r-=1}return s}}const Zc=Object.freeze(Object.defineProperty({__proto__:null,TextDecoder:sn,TextEncoder:on},Symbol.toStringTag,{value:"Module"})),Yc=ho(Zc);var Ni;function Xc(){if(Ni)return lt;Ni=1;var n=lt&&lt.__createBinding||(Object.create?(function(M,P,N,K){K===void 0&&(K=N),Object.defineProperty(M,K,{enumerable:!0,get:function(){return P[N]}})}):(function(M,P,N,K){K===void 0&&(K=N),M[K]=P[N]})),t=lt&&lt.__setModuleDefault||(Object.create?(function(M,P){Object.defineProperty(M,"default",{enumerable:!0,value:P})}):function(M,P){M.default=P}),e=lt&&lt.__decorate||function(M,P,N,K){var p=arguments.length,a=p<3?P:K===null?K=Object.getOwnPropertyDescriptor(P,N):K,f;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")a=Reflect.decorate(M,P,N,K);else for(var d=M.length-1;d>=0;d--)(f=M[d])&&(a=(p<3?f(a):p>3?f(P,N,a):f(P,N))||a);return p>3&&a&&Object.defineProperty(P,N,a),a},r=lt&&lt.__importStar||function(M){if(M&&M.__esModule)return M;var P={};if(M!=null)for(var N in M)N!=="default"&&Object.hasOwnProperty.call(M,N)&&n(P,M,N);return t(P,M),P},i=lt&&lt.__importDefault||function(M){return M&&M.__esModule?M:{default:M}};Object.defineProperty(lt,"__esModule",{value:!0}),lt.deserializeUnchecked=lt.deserialize=lt.serialize=lt.BinaryReader=lt.BinaryWriter=lt.BorshError=lt.baseDecode=lt.baseEncode=void 0;const s=i(Fo()),o=i(Vc()),h=r(Yc),l=typeof TextDecoder!="function"?h.TextDecoder:TextDecoder,y=new l("utf-8",{fatal:!0});function S(M){return typeof M=="string"&&(M=Buffer.from(M,"utf8")),o.default.encode(Buffer.from(M))}lt.baseEncode=S;function I(M){return Buffer.from(o.default.decode(M))}lt.baseDecode=I;const x=1024;class k extends Error{constructor(P){super(P),this.fieldPath=[],this.originalMessage=P}addToFieldPath(P){this.fieldPath.splice(0,0,P),this.message=this.originalMessage+": "+this.fieldPath.join(".")}}lt.BorshError=k;class R{constructor(){this.buf=Buffer.alloc(x),this.length=0}maybeResize(){this.buf.length<16+this.length&&(this.buf=Buffer.concat([this.buf,Buffer.alloc(x)]))}writeU8(P){this.maybeResize(),this.buf.writeUInt8(P,this.length),this.length+=1}writeU16(P){this.maybeResize(),this.buf.writeUInt16LE(P,this.length),this.length+=2}writeU32(P){this.maybeResize(),this.buf.writeUInt32LE(P,this.length),this.length+=4}writeU64(P){this.maybeResize(),this.writeBuffer(Buffer.from(new s.default(P).toArray("le",8)))}writeU128(P){this.maybeResize(),this.writeBuffer(Buffer.from(new s.default(P).toArray("le",16)))}writeU256(P){this.maybeResize(),this.writeBuffer(Buffer.from(new s.default(P).toArray("le",32)))}writeU512(P){this.maybeResize(),this.writeBuffer(Buffer.from(new s.default(P).toArray("le",64)))}writeBuffer(P){this.buf=Buffer.concat([Buffer.from(this.buf.subarray(0,this.length)),P,Buffer.alloc(x)]),this.length+=P.length}writeString(P){this.maybeResize();const N=Buffer.from(P,"utf8");this.writeU32(N.length),this.writeBuffer(N)}writeFixedArray(P){this.writeBuffer(Buffer.from(P))}writeArray(P,N){this.maybeResize(),this.writeU32(P.length);for(const K of P)this.maybeResize(),N(K)}toArray(){return this.buf.subarray(0,this.length)}}lt.BinaryWriter=R;function A(M,P,N){const K=N.value;N.value=function(...p){try{return K.apply(this,p)}catch(a){if(a instanceof RangeError){const f=a.code;if(["ERR_BUFFER_OUT_OF_BOUNDS","ERR_OUT_OF_RANGE"].indexOf(f)>=0)throw new k("Reached the end of buffer when deserializing")}throw a}}}class T{constructor(P){this.buf=P,this.offset=0}readU8(){const P=this.buf.readUInt8(this.offset);return this.offset+=1,P}readU16(){const P=this.buf.readUInt16LE(this.offset);return this.offset+=2,P}readU32(){const P=this.buf.readUInt32LE(this.offset);return this.offset+=4,P}readU64(){const P=this.readBuffer(8);return new s.default(P,"le")}readU128(){const P=this.readBuffer(16);return new s.default(P,"le")}readU256(){const P=this.readBuffer(32);return new s.default(P,"le")}readU512(){const P=this.readBuffer(64);return new s.default(P,"le")}readBuffer(P){if(this.offset+P>this.buf.length)throw new k(`Expected buffer length ${P} isn't within bounds`);const N=this.buf.slice(this.offset,this.offset+P);return this.offset+=P,N}readString(){const P=this.readU32(),N=this.readBuffer(P);try{return y.decode(N)}catch(K){throw new k(`Error decoding UTF-8 string: ${K}`)}}readFixedArray(P){return new Uint8Array(this.readBuffer(P))}readArray(P){const N=this.readU32(),K=Array();for(let p=0;p<N;++p)K.push(P());return K}}e([A],T.prototype,"readU8",null),e([A],T.prototype,"readU16",null),e([A],T.prototype,"readU32",null),e([A],T.prototype,"readU64",null),e([A],T.prototype,"readU128",null),e([A],T.prototype,"readU256",null),e([A],T.prototype,"readU512",null),e([A],T.prototype,"readString",null),e([A],T.prototype,"readFixedArray",null),e([A],T.prototype,"readArray",null),lt.BinaryReader=T;function C(M){return M.charAt(0).toUpperCase()+M.slice(1)}function D(M,P,N,K,p){try{if(typeof K=="string")p[`write${C(K)}`](N);else if(K instanceof Array)if(typeof K[0]=="number"){if(N.length!==K[0])throw new k(`Expecting byte array of length ${K[0]}, but got ${N.length} bytes`);p.writeFixedArray(N)}else if(K.length===2&&typeof K[1]=="number"){if(N.length!==K[1])throw new k(`Expecting byte array of length ${K[1]}, but got ${N.length} bytes`);for(let a=0;a<K[1];a++)D(M,null,N[a],K[0],p)}else p.writeArray(N,a=>{D(M,P,a,K[0],p)});else if(K.kind!==void 0)switch(K.kind){case"option":{N==null?p.writeU8(0):(p.writeU8(1),D(M,P,N,K.type,p));break}case"map":{p.writeU32(N.size),N.forEach((a,f)=>{D(M,P,f,K.key,p),D(M,P,a,K.value,p)});break}default:throw new k(`FieldType ${K} unrecognized`)}else U(M,N,p)}catch(a){throw a instanceof k&&a.addToFieldPath(P),a}}function U(M,P,N){if(typeof P.borshSerialize=="function"){P.borshSerialize(N);return}const K=M.get(P.constructor);if(!K)throw new k(`Class ${P.constructor.name} is missing in schema`);if(K.kind==="struct")K.fields.map(([p,a])=>{D(M,p,P[p],a,N)});else if(K.kind==="enum"){const p=P[K.field];for(let a=0;a<K.values.length;++a){const[f,d]=K.values[a];if(f===p){N.writeU8(a),D(M,f,P[f],d,N);break}}}else throw new k(`Unexpected schema kind: ${K.kind} for ${P.constructor.name}`)}function W(M,P,N=R){const K=new N;return U(M,P,K),K.toArray()}lt.serialize=W;function G(M,P,N,K){try{if(typeof N=="string")return K[`read${C(N)}`]();if(N instanceof Array){if(typeof N[0]=="number")return K.readFixedArray(N[0]);if(typeof N[1]=="number"){const p=[];for(let a=0;a<N[1];a++)p.push(G(M,null,N[0],K));return p}else return K.readArray(()=>G(M,P,N[0],K))}if(N.kind==="option")return K.readU8()?G(M,P,N.type,K):void 0;if(N.kind==="map"){let p=new Map;const a=K.readU32();for(let f=0;f<a;f++){const d=G(M,P,N.key,K),m=G(M,P,N.value,K);p.set(d,m)}return p}return $(M,N,K)}catch(p){throw p instanceof k&&p.addToFieldPath(P),p}}function $(M,P,N){if(typeof P.borshDeserialize=="function")return P.borshDeserialize(N);const K=M.get(P);if(!K)throw new k(`Class ${P.name} is missing in schema`);if(K.kind==="struct"){const p={};for(const[a,f]of M.get(P).fields)p[a]=G(M,a,f,N);return new P(p)}if(K.kind==="enum"){const p=N.readU8();if(p>=K.values.length)throw new k(`Enum index: ${p} is out of range`);const[a,f]=K.values[p],d=G(M,a,f,N);return new P({[a]:d})}throw new k(`Unexpected schema kind: ${K.kind} for ${P.constructor.name}`)}function rt(M,P,N,K=T){const p=new K(N),a=$(M,P,p);if(p.offset<N.length)throw new k(`Unexpected ${N.length-p.offset} bytes after deserialized data`);return a}lt.deserialize=rt;function Q(M,P,N,K=T){const p=new K(N);return $(M,P,p)}return lt.deserializeUnchecked=Q,lt}var ts=Xc(),z={},Ui;function Jc(){if(Ui)return z;Ui=1,Object.defineProperty(z,"__esModule",{value:!0}),z.s16=z.s8=z.nu64be=z.u48be=z.u40be=z.u32be=z.u24be=z.u16be=z.nu64=z.u48=z.u40=z.u32=z.u24=z.u16=z.u8=z.offset=z.greedy=z.Constant=z.UTF8=z.CString=z.Blob=z.Boolean=z.BitField=z.BitStructure=z.VariantLayout=z.Union=z.UnionLayoutDiscriminator=z.UnionDiscriminator=z.Structure=z.Sequence=z.DoubleBE=z.Double=z.FloatBE=z.Float=z.NearInt64BE=z.NearInt64=z.NearUInt64BE=z.NearUInt64=z.IntBE=z.Int=z.UIntBE=z.UInt=z.OffsetLayout=z.GreedyCount=z.ExternalLayout=z.bindConstructorLayout=z.nameWithProperty=z.Layout=z.uint8ArrayToBuffer=z.checkUint8Array=void 0,z.constant=z.utf8=z.cstr=z.blob=z.unionLayoutDiscriminator=z.union=z.seq=z.bits=z.struct=z.f64be=z.f64=z.f32be=z.f32=z.ns64be=z.s48be=z.s40be=z.s32be=z.s24be=z.s16be=z.ns64=z.s48=z.s40=z.s32=z.s24=void 0;const n=Ca();function t(c){if(!(c instanceof Uint8Array))throw new TypeError("b must be a Uint8Array")}z.checkUint8Array=t;function e(c){return t(c),n.Buffer.from(c.buffer,c.byteOffset,c.length)}z.uint8ArrayToBuffer=e;let r=class{constructor(u,g){if(!Number.isInteger(u))throw new TypeError("span must be an integer");this.span=u,this.property=g}makeDestinationObject(){return{}}getSpan(u,g){if(0>this.span)throw new RangeError("indeterminate span");return this.span}replicate(u){const g=Object.create(this.constructor.prototype);return Object.assign(g,this),g.property=u,g}fromArray(u){}};z.Layout=r;function i(c,u){return u.property?c+"["+u.property+"]":c}z.nameWithProperty=i;function s(c,u){if(typeof c!="function")throw new TypeError("Class must be constructor");if(Object.prototype.hasOwnProperty.call(c,"layout_"))throw new Error("Class is already bound to a layout");if(!(u&&u instanceof r))throw new TypeError("layout must be a Layout");if(Object.prototype.hasOwnProperty.call(u,"boundConstructor_"))throw new Error("layout is already bound to a constructor");c.layout_=u,u.boundConstructor_=c,u.makeDestinationObject=(()=>new c),Object.defineProperty(c.prototype,"encode",{value(g,v){return u.encode(this,g,v)},writable:!0}),Object.defineProperty(c,"decode",{value(g,v){return u.decode(g,v)},writable:!0})}z.bindConstructorLayout=s;class o extends r{isCount(){throw new Error("ExternalLayout is abstract")}}z.ExternalLayout=o;class h extends o{constructor(u=1,g){if(!Number.isInteger(u)||0>=u)throw new TypeError("elementSpan must be a (positive) integer");super(-1,g),this.elementSpan=u}isCount(){return!0}decode(u,g=0){t(u);const v=u.length-g;return Math.floor(v/this.elementSpan)}encode(u,g,v){return 0}}z.GreedyCount=h;class l extends o{constructor(u,g=0,v){if(!(u instanceof r))throw new TypeError("layout must be a Layout");if(!Number.isInteger(g))throw new TypeError("offset must be integer or undefined");super(u.span,v||u.property),this.layout=u,this.offset=g}isCount(){return this.layout instanceof y||this.layout instanceof S}decode(u,g=0){return this.layout.decode(u,g+this.offset)}encode(u,g,v=0){return this.layout.encode(u,g,v+this.offset)}}z.OffsetLayout=l;class y extends r{constructor(u,g){if(super(u,g),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(u,g=0){return e(u).readUIntLE(g,this.span)}encode(u,g,v=0){return e(g).writeUIntLE(u,v,this.span),this.span}}z.UInt=y;class S extends r{constructor(u,g){if(super(u,g),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(u,g=0){return e(u).readUIntBE(g,this.span)}encode(u,g,v=0){return e(g).writeUIntBE(u,v,this.span),this.span}}z.UIntBE=S;class I extends r{constructor(u,g){if(super(u,g),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(u,g=0){return e(u).readIntLE(g,this.span)}encode(u,g,v=0){return e(g).writeIntLE(u,v,this.span),this.span}}z.Int=I;class x extends r{constructor(u,g){if(super(u,g),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(u,g=0){return e(u).readIntBE(g,this.span)}encode(u,g,v=0){return e(g).writeIntBE(u,v,this.span),this.span}}z.IntBE=x;const k=Math.pow(2,32);function R(c){const u=Math.floor(c/k),g=c-u*k;return{hi32:u,lo32:g}}function A(c,u){return c*k+u}class T extends r{constructor(u){super(8,u)}decode(u,g=0){const v=e(u),L=v.readUInt32LE(g),q=v.readUInt32LE(g+4);return A(q,L)}encode(u,g,v=0){const L=R(u),q=e(g);return q.writeUInt32LE(L.lo32,v),q.writeUInt32LE(L.hi32,v+4),8}}z.NearUInt64=T;class C extends r{constructor(u){super(8,u)}decode(u,g=0){const v=e(u),L=v.readUInt32BE(g),q=v.readUInt32BE(g+4);return A(L,q)}encode(u,g,v=0){const L=R(u),q=e(g);return q.writeUInt32BE(L.hi32,v),q.writeUInt32BE(L.lo32,v+4),8}}z.NearUInt64BE=C;class D extends r{constructor(u){super(8,u)}decode(u,g=0){const v=e(u),L=v.readUInt32LE(g),q=v.readInt32LE(g+4);return A(q,L)}encode(u,g,v=0){const L=R(u),q=e(g);return q.writeUInt32LE(L.lo32,v),q.writeInt32LE(L.hi32,v+4),8}}z.NearInt64=D;class U extends r{constructor(u){super(8,u)}decode(u,g=0){const v=e(u),L=v.readInt32BE(g),q=v.readUInt32BE(g+4);return A(L,q)}encode(u,g,v=0){const L=R(u),q=e(g);return q.writeInt32BE(L.hi32,v),q.writeUInt32BE(L.lo32,v+4),8}}z.NearInt64BE=U;class W extends r{constructor(u){super(4,u)}decode(u,g=0){return e(u).readFloatLE(g)}encode(u,g,v=0){return e(g).writeFloatLE(u,v),4}}z.Float=W;class G extends r{constructor(u){super(4,u)}decode(u,g=0){return e(u).readFloatBE(g)}encode(u,g,v=0){return e(g).writeFloatBE(u,v),4}}z.FloatBE=G;class $ extends r{constructor(u){super(8,u)}decode(u,g=0){return e(u).readDoubleLE(g)}encode(u,g,v=0){return e(g).writeDoubleLE(u,v),8}}z.Double=$;class rt extends r{constructor(u){super(8,u)}decode(u,g=0){return e(u).readDoubleBE(g)}encode(u,g,v=0){return e(g).writeDoubleBE(u,v),8}}z.DoubleBE=rt;class Q extends r{constructor(u,g,v){if(!(u instanceof r))throw new TypeError("elementLayout must be a Layout");if(!(g instanceof o&&g.isCount()||Number.isInteger(g)&&0<=g))throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");let L=-1;!(g instanceof o)&&0<u.span&&(L=g*u.span),super(L,v),this.elementLayout=u,this.count=g}getSpan(u,g=0){if(0<=this.span)return this.span;let v=0,L=this.count;if(L instanceof o&&(L=L.decode(u,g)),0<this.elementLayout.span)v=L*this.elementLayout.span;else{let q=0;for(;q<L;)v+=this.elementLayout.getSpan(u,g+v),++q}return v}decode(u,g=0){const v=[];let L=0,q=this.count;for(q instanceof o&&(q=q.decode(u,g));L<q;)v.push(this.elementLayout.decode(u,g)),g+=this.elementLayout.getSpan(u,g),L+=1;return v}encode(u,g,v=0){const L=this.elementLayout,q=u.reduce((X,J)=>X+L.encode(J,g,v+X),0);return this.count instanceof o&&this.count.encode(u.length,g,v),q}}z.Sequence=Q;class M extends r{constructor(u,g,v){if(!(Array.isArray(u)&&u.reduce((q,X)=>q&&X instanceof r,!0)))throw new TypeError("fields must be array of Layout instances");typeof g=="boolean"&&v===void 0&&(v=g,g=void 0);for(const q of u)if(0>q.span&&q.property===void 0)throw new Error("fields cannot contain unnamed variable-length layout");let L=-1;try{L=u.reduce((q,X)=>q+X.getSpan(),0)}catch{}super(L,g),this.fields=u,this.decodePrefixes=!!v}getSpan(u,g=0){if(0<=this.span)return this.span;let v=0;try{v=this.fields.reduce((L,q)=>{const X=q.getSpan(u,g);return g+=X,L+X},0)}catch{throw new RangeError("indeterminate span")}return v}decode(u,g=0){t(u);const v=this.makeDestinationObject();for(const L of this.fields)if(L.property!==void 0&&(v[L.property]=L.decode(u,g)),g+=L.getSpan(u,g),this.decodePrefixes&&u.length===g)break;return v}encode(u,g,v=0){const L=v;let q=0,X=0;for(const J of this.fields){let ht=J.span;if(X=0<ht?ht:0,J.property!==void 0){const dt=u[J.property];dt!==void 0&&(X=J.encode(dt,g,v),0>ht&&(ht=J.getSpan(g,v)))}q=v,v+=ht}return q+X-L}fromArray(u){const g=this.makeDestinationObject();for(const v of this.fields)v.property!==void 0&&0<u.length&&(g[v.property]=u.shift());return g}layoutFor(u){if(typeof u!="string")throw new TypeError("property must be string");for(const g of this.fields)if(g.property===u)return g}offsetOf(u){if(typeof u!="string")throw new TypeError("property must be string");let g=0;for(const v of this.fields){if(v.property===u)return g;0>v.span?g=-1:0<=g&&(g+=v.span)}}}z.Structure=M;class P{constructor(u){this.property=u}decode(u,g){throw new Error("UnionDiscriminator is abstract")}encode(u,g,v){throw new Error("UnionDiscriminator is abstract")}}z.UnionDiscriminator=P;class N extends P{constructor(u,g){if(!(u instanceof o&&u.isCount()))throw new TypeError("layout must be an unsigned integer ExternalLayout");super(g||u.property||"variant"),this.layout=u}decode(u,g){return this.layout.decode(u,g)}encode(u,g,v){return this.layout.encode(u,g,v)}}z.UnionLayoutDiscriminator=N;class K extends r{constructor(u,g,v){let L;if(u instanceof y||u instanceof S)L=new N(new l(u));else if(u instanceof o&&u.isCount())L=new N(u);else if(u instanceof P)L=u;else throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");if(g===void 0&&(g=null),!(g===null||g instanceof r))throw new TypeError("defaultLayout must be null or a Layout");if(g!==null){if(0>g.span)throw new Error("defaultLayout must have constant span");g.property===void 0&&(g=g.replicate("content"))}let q=-1;g&&(q=g.span,0<=q&&(u instanceof y||u instanceof S)&&(q+=L.layout.span)),super(q,v),this.discriminator=L,this.usesPrefixDiscriminator=u instanceof y||u instanceof S,this.defaultLayout=g,this.registry={};let X=this.defaultGetSourceVariant.bind(this);this.getSourceVariant=function(J){return X(J)},this.configGetSourceVariant=function(J){X=J.bind(this)}}getSpan(u,g=0){if(0<=this.span)return this.span;const v=this.getVariant(u,g);if(!v)throw new Error("unable to determine span for unrecognized variant");return v.getSpan(u,g)}defaultGetSourceVariant(u){if(Object.prototype.hasOwnProperty.call(u,this.discriminator.property)){if(this.defaultLayout&&this.defaultLayout.property&&Object.prototype.hasOwnProperty.call(u,this.defaultLayout.property))return;const g=this.registry[u[this.discriminator.property]];if(g&&(!g.layout||g.property&&Object.prototype.hasOwnProperty.call(u,g.property)))return g}else for(const g in this.registry){const v=this.registry[g];if(v.property&&Object.prototype.hasOwnProperty.call(u,v.property))return v}throw new Error("unable to infer src variant")}decode(u,g=0){let v;const L=this.discriminator,q=L.decode(u,g),X=this.registry[q];if(X===void 0){const J=this.defaultLayout;let ht=0;this.usesPrefixDiscriminator&&(ht=L.layout.span),v=this.makeDestinationObject(),v[L.property]=q,v[J.property]=J.decode(u,g+ht)}else v=X.decode(u,g);return v}encode(u,g,v=0){const L=this.getSourceVariant(u);if(L===void 0){const q=this.discriminator,X=this.defaultLayout;let J=0;return this.usesPrefixDiscriminator&&(J=q.layout.span),q.encode(u[q.property],g,v),J+X.encode(u[X.property],g,v+J)}return L.encode(u,g,v)}addVariant(u,g,v){const L=new p(this,u,g,v);return this.registry[u]=L,L}getVariant(u,g=0){let v;return u instanceof Uint8Array?v=this.discriminator.decode(u,g):v=u,this.registry[v]}}z.Union=K;class p extends r{constructor(u,g,v,L){if(!(u instanceof K))throw new TypeError("union must be a Union");if(!Number.isInteger(g)||0>g)throw new TypeError("variant must be a (non-negative) integer");if(typeof v=="string"&&L===void 0&&(L=v,v=null),v){if(!(v instanceof r))throw new TypeError("layout must be a Layout");if(u.defaultLayout!==null&&0<=v.span&&v.span>u.defaultLayout.span)throw new Error("variant span exceeds span of containing union");if(typeof L!="string")throw new TypeError("variant must have a String property")}let q=u.span;0>u.span&&(q=v?v.span:0,0<=q&&u.usesPrefixDiscriminator&&(q+=u.discriminator.layout.span)),super(q,L),this.union=u,this.variant=g,this.layout=v||null}getSpan(u,g=0){if(0<=this.span)return this.span;let v=0;this.union.usesPrefixDiscriminator&&(v=this.union.discriminator.layout.span);let L=0;return this.layout&&(L=this.layout.getSpan(u,g+v)),v+L}decode(u,g=0){const v=this.makeDestinationObject();if(this!==this.union.getVariant(u,g))throw new Error("variant mismatch");let L=0;return this.union.usesPrefixDiscriminator&&(L=this.union.discriminator.layout.span),this.layout?v[this.property]=this.layout.decode(u,g+L):this.property?v[this.property]=!0:this.union.usesPrefixDiscriminator&&(v[this.union.discriminator.property]=this.variant),v}encode(u,g,v=0){let L=0;if(this.union.usesPrefixDiscriminator&&(L=this.union.discriminator.layout.span),this.layout&&!Object.prototype.hasOwnProperty.call(u,this.property))throw new TypeError("variant lacks property "+this.property);this.union.discriminator.encode(this.variant,g,v);let q=L;if(this.layout&&(this.layout.encode(u[this.property],g,v+L),q+=this.layout.getSpan(g,v+L),0<=this.union.span&&q>this.union.span))throw new Error("encoded variant overruns containing union");return q}fromArray(u){if(this.layout)return this.layout.fromArray(u)}}z.VariantLayout=p;function a(c){return 0>c&&(c+=4294967296),c}class f extends r{constructor(u,g,v){if(!(u instanceof y||u instanceof S))throw new TypeError("word must be a UInt or UIntBE layout");if(typeof g=="string"&&v===void 0&&(v=g,g=!1),4<u.span)throw new RangeError("word cannot exceed 32 bits");super(u.span,v),this.word=u,this.msb=!!g,this.fields=[];let L=0;this._packedSetValue=function(q){return L=a(q),this},this._packedGetValue=function(){return L}}decode(u,g=0){const v=this.makeDestinationObject(),L=this.word.decode(u,g);this._packedSetValue(L);for(const q of this.fields)q.property!==void 0&&(v[q.property]=q.decode(u));return v}encode(u,g,v=0){const L=this.word.decode(g,v);this._packedSetValue(L);for(const q of this.fields)if(q.property!==void 0){const X=u[q.property];X!==void 0&&q.encode(X)}return this.word.encode(this._packedGetValue(),g,v)}addField(u,g){const v=new d(this,u,g);return this.fields.push(v),v}addBoolean(u){const g=new m(this,u);return this.fields.push(g),g}fieldFor(u){if(typeof u!="string")throw new TypeError("property must be string");for(const g of this.fields)if(g.property===u)return g}}z.BitStructure=f;class d{constructor(u,g,v){if(!(u instanceof f))throw new TypeError("container must be a BitStructure");if(!Number.isInteger(g)||0>=g)throw new TypeError("bits must be positive integer");const L=8*u.span,q=u.fields.reduce((X,J)=>X+J.bits,0);if(g+q>L)throw new Error("bits too long for span remainder ("+(L-q)+" of "+L+" remain)");this.container=u,this.bits=g,this.valueMask=(1<<g)-1,g===32&&(this.valueMask=4294967295),this.start=q,this.container.msb&&(this.start=L-q-g),this.wordMask=a(this.valueMask<<this.start),this.property=v}decode(u,g){const v=this.container._packedGetValue();return a(v&this.wordMask)>>>this.start}encode(u){if(typeof u!="number"||!Number.isInteger(u)||u!==a(u&this.valueMask))throw new TypeError(i("BitField.encode",this)+" value must be integer not exceeding "+this.valueMask);const g=this.container._packedGetValue(),v=a(u<<this.start);this.container._packedSetValue(a(g&~this.wordMask)|v)}}z.BitField=d;class m extends d{constructor(u,g){super(u,1,g)}decode(u,g){return!!super.decode(u,g)}encode(u){typeof u=="boolean"&&(u=+u),super.encode(u)}}z.Boolean=m;class w extends r{constructor(u,g){if(!(u instanceof o&&u.isCount()||Number.isInteger(u)&&0<=u))throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");let v=-1;u instanceof o||(v=u),super(v,g),this.length=u}getSpan(u,g){let v=this.span;return 0>v&&(v=this.length.decode(u,g)),v}decode(u,g=0){let v=this.span;return 0>v&&(v=this.length.decode(u,g)),e(u).slice(g,g+v)}encode(u,g,v){let L=this.length;if(this.length instanceof o&&(L=u.length),!(u instanceof Uint8Array&&L===u.length))throw new TypeError(i("Blob.encode",this)+" requires (length "+L+") Uint8Array as src");if(v+L>g.length)throw new RangeError("encoding overruns Uint8Array");const q=e(u);return e(g).write(q.toString("hex"),v,L,"hex"),this.length instanceof o&&this.length.encode(L,g,v),L}}z.Blob=w;class _ extends r{constructor(u){super(-1,u)}getSpan(u,g=0){t(u);let v=g;for(;v<u.length&&u[v]!==0;)v+=1;return 1+v-g}decode(u,g=0){const v=this.getSpan(u,g);return e(u).slice(g,g+v-1).toString("utf-8")}encode(u,g,v=0){typeof u!="string"&&(u=String(u));const L=n.Buffer.from(u,"utf8"),q=L.length;if(v+q>g.length)throw new RangeError("encoding overruns Buffer");const X=e(g);return L.copy(X,v),X[v+q]=0,q+1}}z.CString=_;class B extends r{constructor(u,g){if(typeof u=="string"&&g===void 0&&(g=u,u=void 0),u===void 0)u=-1;else if(!Number.isInteger(u))throw new TypeError("maxSpan must be an integer");super(-1,g),this.maxSpan=u}getSpan(u,g=0){return t(u),u.length-g}decode(u,g=0){const v=this.getSpan(u,g);if(0<=this.maxSpan&&this.maxSpan<v)throw new RangeError("text length exceeds maxSpan");return e(u).slice(g,g+v).toString("utf-8")}encode(u,g,v=0){typeof u!="string"&&(u=String(u));const L=n.Buffer.from(u,"utf8"),q=L.length;if(0<=this.maxSpan&&this.maxSpan<q)throw new RangeError("text length exceeds maxSpan");if(v+q>g.length)throw new RangeError("encoding overruns Buffer");return L.copy(e(g),v),q}}z.UTF8=B;class b extends r{constructor(u,g){super(0,g),this.value=u}decode(u,g){return this.value}encode(u,g,v){return 0}}return z.Constant=b,z.greedy=((c,u)=>new h(c,u)),z.offset=((c,u,g)=>new l(c,u,g)),z.u8=(c=>new y(1,c)),z.u16=(c=>new y(2,c)),z.u24=(c=>new y(3,c)),z.u32=(c=>new y(4,c)),z.u40=(c=>new y(5,c)),z.u48=(c=>new y(6,c)),z.nu64=(c=>new T(c)),z.u16be=(c=>new S(2,c)),z.u24be=(c=>new S(3,c)),z.u32be=(c=>new S(4,c)),z.u40be=(c=>new S(5,c)),z.u48be=(c=>new S(6,c)),z.nu64be=(c=>new C(c)),z.s8=(c=>new I(1,c)),z.s16=(c=>new I(2,c)),z.s24=(c=>new I(3,c)),z.s32=(c=>new I(4,c)),z.s40=(c=>new I(5,c)),z.s48=(c=>new I(6,c)),z.ns64=(c=>new D(c)),z.s16be=(c=>new x(2,c)),z.s24be=(c=>new x(3,c)),z.s32be=(c=>new x(4,c)),z.s40be=(c=>new x(5,c)),z.s48be=(c=>new x(6,c)),z.ns64be=(c=>new U(c)),z.f32=(c=>new W(c)),z.f32be=(c=>new G(c)),z.f64=(c=>new $(c)),z.f64be=(c=>new rt(c)),z.struct=((c,u,g)=>new M(c,u,g)),z.bits=((c,u,g)=>new f(c,u,g)),z.seq=((c,u,g)=>new Q(c,u,g)),z.union=((c,u,g)=>new K(c,u,g)),z.unionLayoutDiscriminator=((c,u)=>new N(c,u)),z.blob=((c,u)=>new w(c,u)),z.cstr=(c=>new _(c)),z.utf8=((c,u)=>new B(c,u)),z.constant=((c,u)=>new b(c,u)),z}var E=Jc(),Qc=8078e3,tu=8078001,eu=8078004,ru=8078005,nu=8078006,su=8078011;function Wo(n){return Array.isArray(n)?"%5B"+n.map(Wo).join("%2C%20")+"%5D":typeof n=="bigint"?`${n}n`:encodeURIComponent(String(n!=null&&Object.getPrototypeOf(n)===null?{...n}:n))}function iu([n,t]){return`${n}=${Wo(t)}`}function ou(n){const t=Object.entries(n).map(iu).join("&");return btoa(t)}function au(n,t={}){{let e=`Solana error #${n}; Decode this error by running \`npx @solana/errors decode -- ${n}`;return Object.keys(t).length&&(e+=` '${ou(t)}'`),`${e}\``}}var dr=class extends Error{cause=this.cause;context;constructor(...[n,t]){let e,r;if(t){const{cause:s,...o}=t;s&&(r={cause:s}),Object.keys(o).length>0&&(e=o)}const i=au(n,e);super(i,r),this.context={__code:n,...e},this.name="SolanaError"}};function cu(n,t){return"fixedSize"in t?t.fixedSize:t.getSizeFromValue(n)}function uu(n){return Object.freeze({...n,encode:t=>{const e=new Uint8Array(cu(t,n));return n.write(t,e,0),e}})}function fu(n){return Object.freeze({...n,decode:(t,e=0)=>n.read(t,e)[0]})}function fr(n){return"fixedSize"in n&&typeof n.fixedSize=="number"}function lu(n,t){if(fr(n)!==fr(t))throw new dr(eu);if(fr(n)&&fr(t)&&n.fixedSize!==t.fixedSize)throw new dr(ru,{decoderFixedSize:t.fixedSize,encoderFixedSize:n.fixedSize});if(!fr(n)&&!fr(t)&&n.maxSize!==t.maxSize)throw new dr(nu,{decoderMaxSize:t.maxSize,encoderMaxSize:n.maxSize});return{...t,...n,decode:t.decode,encode:n.encode,read:t.read,write:n.write}}function hu(n,t,e=0){if(t.length-e<=0)throw new dr(Qc,{codecDescription:n})}function du(n,t,e,r=0){const i=e.length-r;if(i<t)throw new dr(tu,{bytesLength:i,codecDescription:n,expected:t})}function pu(n,t,e,r){if(r<t||r>e)throw new dr(su,{codecDescription:n,max:e,min:t,value:r})}function Vo(n){return n?.endian!==1}function gu(n){return uu({fixedSize:n.size,write(t,e,r){n.range&&pu(n.name,n.range[0],n.range[1],t);const i=new ArrayBuffer(n.size);return n.set(new DataView(i),t,Vo(n.config)),e.set(new Uint8Array(i),r),r+n.size}})}function yu(n){return fu({fixedSize:n.size,read(t,e=0){hu(n.name,t,e),du(n.name,n.size,t,e);const r=new DataView(mu(t,e,n.size));return[n.get(r,Vo(n.config)),e+n.size]}})}function mu(n,t,e){const r=n.byteOffset+(t??0),i=e??n.byteLength;return n.buffer.slice(r,r+i)}var Ho=(n={})=>gu({config:n,name:"u64",range:[0n,BigInt("0xffffffffffffffff")],set:(t,e,r)=>t.setBigUint64(0,BigInt(e),r),size:8}),bu=(n={})=>yu({config:n,get:(t,e)=>t.getBigUint64(0,e),name:"u64",size:8}),wu=(n={})=>lu(Ho(n),bu(n));class vu extends TypeError{constructor(t,e){let r;const{message:i,explanation:s,...o}=t,{path:h}=t,l=h.length===0?i:`At path: ${h.join(".")} -- ${i}`;super(s??l),s!=null&&(this.cause=l),Object.assign(this,o),this.name=this.constructor.name,this.failures=()=>r??(r=[t,...e()])}}function ku(n){return Kr(n)&&typeof n[Symbol.iterator]=="function"}function Kr(n){return typeof n=="object"&&n!=null}function an(n){return Kr(n)&&!Array.isArray(n)}function ke(n){return typeof n=="symbol"?n.toString():typeof n=="string"?JSON.stringify(n):`${n}`}function Su(n){const{done:t,value:e}=n.next();return t?void 0:e}function xu(n,t,e,r){if(n===!0)return;n===!1?n={}:typeof n=="string"&&(n={message:n});const{path:i,branch:s}=t,{type:o}=e,{refinement:h,message:l=`Expected a value of type \`${o}\`${h?` with refinement \`${h}\``:""}, but received: \`${ke(r)}\``}=n;return{value:r,type:o,refinement:h,key:i[i.length-1],path:i,branch:s,...n,message:l}}function*zi(n,t,e,r){ku(n)||(n=[n]);for(const i of n){const s=xu(i,t,e,r);s&&(yield s)}}function*Cs(n,t,e={}){const{path:r=[],branch:i=[n],coerce:s=!1,mask:o=!1}=e,h={path:r,branch:i,mask:o};s&&(n=t.coercer(n,h));let l="valid";for(const y of t.validator(n,h))y.explanation=e.message,l="not_valid",yield[y,void 0];for(let[y,S,I]of t.entries(n,h)){const x=Cs(S,I,{path:y===void 0?r:[...r,y],branch:y===void 0?i:[...i,S],coerce:s,mask:o,message:e.message});for(const k of x)k[0]?(l=k[0].refinement!=null?"not_refined":"not_valid",yield[k[0],void 0]):s&&(S=k[1],y===void 0?n=S:n instanceof Map?n.set(y,S):n instanceof Set?n.add(S):Kr(n)&&(S!==void 0||y in n)&&(n[y]=S))}if(l!=="not_valid")for(const y of t.refiner(n,h))y.explanation=e.message,l="not_refined",yield[y,void 0];l==="valid"&&(yield[void 0,n])}let Te=class{constructor(t){const{type:e,schema:r,validator:i,refiner:s,coercer:o=l=>l,entries:h=function*(){}}=t;this.type=e,this.schema=r,this.entries=h,this.coercer=o,i?this.validator=(l,y)=>{const S=i(l,y);return zi(S,y,this,l)}:this.validator=()=>[],s?this.refiner=(l,y)=>{const S=s(l,y);return zi(S,y,this,l)}:this.refiner=()=>[]}assert(t,e){return $o(t,this,e)}create(t,e){return j(t,this,e)}is(t){return jo(t,this)}mask(t,e){return _u(t,this,e)}validate(t,e={}){return qr(t,this,e)}};function $o(n,t,e){const r=qr(n,t,{message:e});if(r[0])throw r[0]}function j(n,t,e){const r=qr(n,t,{coerce:!0,message:e});if(r[0])throw r[0];return r[1]}function _u(n,t,e){const r=qr(n,t,{coerce:!0,mask:!0,message:e});if(r[0])throw r[0];return r[1]}function jo(n,t){return!qr(n,t)[0]}function qr(n,t,e={}){const r=Cs(n,t,e),i=Su(r);return i[0]?[new vu(i[0],function*(){for(const o of r)o[0]&&(yield o[0])}),void 0]:[void 0,i[1]]}function sr(n,t){return new Te({type:n,schema:null,validator:t})}function Eu(){return sr("any",()=>!0)}function Z(n){return new Te({type:"array",schema:n,*entries(t){if(n&&Array.isArray(t))for(const[e,r]of t.entries())yield[e,r,n]},coercer(t){return Array.isArray(t)?t.slice():t},validator(t){return Array.isArray(t)||`Expected an array value, but received: ${ke(t)}`}})}function Me(){return sr("boolean",n=>typeof n=="boolean")}function Os(n){return sr("instance",t=>t instanceof n||`Expected a \`${n.name}\` instance, but received: ${ke(t)}`)}function bt(n){const t=ke(n),e=typeof n;return new Te({type:"literal",schema:e==="string"||e==="number"||e==="boolean"?n:null,validator(r){return r===n||`Expected the literal \`${t}\`, but received: ${ke(r)}`}})}function Iu(){return sr("never",()=>!1)}function Y(n){return new Te({...n,validator:(t,e)=>t===null||n.validator(t,e),refiner:(t,e)=>t===null||n.refiner(t,e)})}function O(){return sr("number",n=>typeof n=="number"&&!isNaN(n)||`Expected a number, but received: ${ke(n)}`)}function et(n){return new Te({...n,validator:(t,e)=>t===void 0||n.validator(t,e),refiner:(t,e)=>t===void 0||n.refiner(t,e)})}function Go(n,t){return new Te({type:"record",schema:null,*entries(e){if(Kr(e))for(const r in e){const i=e[r];yield[r,r,n],yield[r,i,t]}},validator(e){return an(e)||`Expected an object, but received: ${ke(e)}`},coercer(e){return an(e)?{...e}:e}})}function V(){return sr("string",n=>typeof n=="string"||`Expected a string, but received: ${ke(n)}`)}function Ns(n){const t=Iu();return new Te({type:"tuple",schema:null,*entries(e){if(Array.isArray(e)){const r=Math.max(n.length,e.length);for(let i=0;i<r;i++)yield[i,e[i],n[i]||t]}},validator(e){return Array.isArray(e)||`Expected an array, but received: ${ke(e)}`},coercer(e){return Array.isArray(e)?e.slice():e}})}function F(n){const t=Object.keys(n);return new Te({type:"type",schema:n,*entries(e){if(Kr(e))for(const r of t)yield[r,e[r],n[r]]},validator(e){return an(e)||`Expected an object, but received: ${ke(e)}`},coercer(e){return an(e)?{...e}:e}})}function ge(n){const t=n.map(e=>e.type).join(" | ");return new Te({type:"union",schema:null,coercer(e,r){for(const i of n){const[s,o]=i.validate(e,{coerce:!0,mask:r.mask});if(!s)return o}return e},validator(e,r){const i=[];for(const s of n){const[...o]=Cs(e,s,r),[h]=o;if(h[0])for(const[l]of o)l&&i.push(l);else return[]}return[`Expected the value to satisfy a union of \`${t}\`, but received: ${ke(e)}`,...i]}})}function xr(){return sr("unknown",()=>!0)}function Dr(n,t,e){return new Te({...n,coercer:(r,i)=>jo(r,t)?n.coercer(e(r,i),i):n.coercer(r,i)})}var jr,Au=new Uint8Array(16);function Zo(){if(!jr&&(jr=typeof crypto<"u"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||typeof msCrypto<"u"&&typeof msCrypto.getRandomValues=="function"&&msCrypto.getRandomValues.bind(msCrypto),!jr))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return jr(Au)}const Bu=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;function pn(n){return typeof n=="string"&&Bu.test(n)}var ae=[];for(var es=0;es<256;++es)ae.push((es+256).toString(16).substr(1));function gn(n){var t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0,e=(ae[n[t+0]]+ae[n[t+1]]+ae[n[t+2]]+ae[n[t+3]]+"-"+ae[n[t+4]]+ae[n[t+5]]+"-"+ae[n[t+6]]+ae[n[t+7]]+"-"+ae[n[t+8]]+ae[n[t+9]]+"-"+ae[n[t+10]]+ae[n[t+11]]+ae[n[t+12]]+ae[n[t+13]]+ae[n[t+14]]+ae[n[t+15]]).toLowerCase();if(!pn(e))throw TypeError("Stringified UUID is invalid");return e}var Ki,rs,ns=0,ss=0;function Ru(n,t,e){var r=t&&e||0,i=t||new Array(16);n=n||{};var s=n.node||Ki,o=n.clockseq!==void 0?n.clockseq:rs;if(s==null||o==null){var h=n.random||(n.rng||Zo)();s==null&&(s=Ki=[h[0]|1,h[1],h[2],h[3],h[4],h[5]]),o==null&&(o=rs=(h[6]<<8|h[7])&16383)}var l=n.msecs!==void 0?n.msecs:Date.now(),y=n.nsecs!==void 0?n.nsecs:ss+1,S=l-ns+(y-ss)/1e4;if(S<0&&n.clockseq===void 0&&(o=o+1&16383),(S<0||l>ns)&&n.nsecs===void 0&&(y=0),y>=1e4)throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");ns=l,ss=y,rs=o,l+=122192928e5;var I=((l&268435455)*1e4+y)%4294967296;i[r++]=I>>>24&255,i[r++]=I>>>16&255,i[r++]=I>>>8&255,i[r++]=I&255;var x=l/4294967296*1e4&268435455;i[r++]=x>>>8&255,i[r++]=x&255,i[r++]=x>>>24&15|16,i[r++]=x>>>16&255,i[r++]=o>>>8|128,i[r++]=o&255;for(var k=0;k<6;++k)i[r+k]=s[k];return t||gn(i)}function Yo(n){if(!pn(n))throw TypeError("Invalid UUID");var t,e=new Uint8Array(16);return e[0]=(t=parseInt(n.slice(0,8),16))>>>24,e[1]=t>>>16&255,e[2]=t>>>8&255,e[3]=t&255,e[4]=(t=parseInt(n.slice(9,13),16))>>>8,e[5]=t&255,e[6]=(t=parseInt(n.slice(14,18),16))>>>8,e[7]=t&255,e[8]=(t=parseInt(n.slice(19,23),16))>>>8,e[9]=t&255,e[10]=(t=parseInt(n.slice(24,36),16))/1099511627776&255,e[11]=t/4294967296&255,e[12]=t>>>24&255,e[13]=t>>>16&255,e[14]=t>>>8&255,e[15]=t&255,e}function Mu(n){n=unescape(encodeURIComponent(n));for(var t=[],e=0;e<n.length;++e)t.push(n.charCodeAt(e));return t}var Tu="6ba7b810-9dad-11d1-80b4-00c04fd430c8",Pu="6ba7b811-9dad-11d1-80b4-00c04fd430c8";function Xo(n,t,e){function r(i,s,o,h){if(typeof i=="string"&&(i=Mu(i)),typeof s=="string"&&(s=Yo(s)),s.length!==16)throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");var l=new Uint8Array(16+i.length);if(l.set(s),l.set(i,s.length),l=e(l),l[6]=l[6]&15|t,l[8]=l[8]&63|128,o){h=h||0;for(var y=0;y<16;++y)o[h+y]=l[y];return o}return gn(l)}try{r.name=n}catch{}return r.DNS=Tu,r.URL=Pu,r}function Lu(n){if(typeof n=="string"){var t=unescape(encodeURIComponent(n));n=new Uint8Array(t.length);for(var e=0;e<t.length;++e)n[e]=t.charCodeAt(e)}return Cu(Ou(Nu(n),n.length*8))}function Cu(n){for(var t=[],e=n.length*32,r="0123456789abcdef",i=0;i<e;i+=8){var s=n[i>>5]>>>i%32&255,o=parseInt(r.charAt(s>>>4&15)+r.charAt(s&15),16);t.push(o)}return t}function Jo(n){return(n+64>>>9<<4)+14+1}function Ou(n,t){n[t>>5]|=128<<t%32,n[Jo(t)-1]=t;for(var e=1732584193,r=-271733879,i=-1732584194,s=271733878,o=0;o<n.length;o+=16){var h=e,l=r,y=i,S=s;e=le(e,r,i,s,n[o],7,-680876936),s=le(s,e,r,i,n[o+1],12,-389564586),i=le(i,s,e,r,n[o+2],17,606105819),r=le(r,i,s,e,n[o+3],22,-1044525330),e=le(e,r,i,s,n[o+4],7,-176418897),s=le(s,e,r,i,n[o+5],12,1200080426),i=le(i,s,e,r,n[o+6],17,-1473231341),r=le(r,i,s,e,n[o+7],22,-45705983),e=le(e,r,i,s,n[o+8],7,1770035416),s=le(s,e,r,i,n[o+9],12,-1958414417),i=le(i,s,e,r,n[o+10],17,-42063),r=le(r,i,s,e,n[o+11],22,-1990404162),e=le(e,r,i,s,n[o+12],7,1804603682),s=le(s,e,r,i,n[o+13],12,-40341101),i=le(i,s,e,r,n[o+14],17,-1502002290),r=le(r,i,s,e,n[o+15],22,1236535329),e=he(e,r,i,s,n[o+1],5,-165796510),s=he(s,e,r,i,n[o+6],9,-1069501632),i=he(i,s,e,r,n[o+11],14,643717713),r=he(r,i,s,e,n[o],20,-373897302),e=he(e,r,i,s,n[o+5],5,-701558691),s=he(s,e,r,i,n[o+10],9,38016083),i=he(i,s,e,r,n[o+15],14,-660478335),r=he(r,i,s,e,n[o+4],20,-405537848),e=he(e,r,i,s,n[o+9],5,568446438),s=he(s,e,r,i,n[o+14],9,-1019803690),i=he(i,s,e,r,n[o+3],14,-187363961),r=he(r,i,s,e,n[o+8],20,1163531501),e=he(e,r,i,s,n[o+13],5,-1444681467),s=he(s,e,r,i,n[o+2],9,-51403784),i=he(i,s,e,r,n[o+7],14,1735328473),r=he(r,i,s,e,n[o+12],20,-1926607734),e=de(e,r,i,s,n[o+5],4,-378558),s=de(s,e,r,i,n[o+8],11,-2022574463),i=de(i,s,e,r,n[o+11],16,1839030562),r=de(r,i,s,e,n[o+14],23,-35309556),e=de(e,r,i,s,n[o+1],4,-1530992060),s=de(s,e,r,i,n[o+4],11,1272893353),i=de(i,s,e,r,n[o+7],16,-155497632),r=de(r,i,s,e,n[o+10],23,-1094730640),e=de(e,r,i,s,n[o+13],4,681279174),s=de(s,e,r,i,n[o],11,-358537222),i=de(i,s,e,r,n[o+3],16,-722521979),r=de(r,i,s,e,n[o+6],23,76029189),e=de(e,r,i,s,n[o+9],4,-640364487),s=de(s,e,r,i,n[o+12],11,-421815835),i=de(i,s,e,r,n[o+15],16,530742520),r=de(r,i,s,e,n[o+2],23,-995338651),e=pe(e,r,i,s,n[o],6,-198630844),s=pe(s,e,r,i,n[o+7],10,1126891415),i=pe(i,s,e,r,n[o+14],15,-1416354905),r=pe(r,i,s,e,n[o+5],21,-57434055),e=pe(e,r,i,s,n[o+12],6,1700485571),s=pe(s,e,r,i,n[o+3],10,-1894986606),i=pe(i,s,e,r,n[o+10],15,-1051523),r=pe(r,i,s,e,n[o+1],21,-2054922799),e=pe(e,r,i,s,n[o+8],6,1873313359),s=pe(s,e,r,i,n[o+15],10,-30611744),i=pe(i,s,e,r,n[o+6],15,-1560198380),r=pe(r,i,s,e,n[o+13],21,1309151649),e=pe(e,r,i,s,n[o+4],6,-145523070),s=pe(s,e,r,i,n[o+11],10,-1120210379),i=pe(i,s,e,r,n[o+2],15,718787259),r=pe(r,i,s,e,n[o+9],21,-343485551),e=He(e,h),r=He(r,l),i=He(i,y),s=He(s,S)}return[e,r,i,s]}function Nu(n){if(n.length===0)return[];for(var t=n.length*8,e=new Uint32Array(Jo(t)),r=0;r<t;r+=8)e[r>>5]|=(n[r/8]&255)<<r%32;return e}function He(n,t){var e=(n&65535)+(t&65535),r=(n>>16)+(t>>16)+(e>>16);return r<<16|e&65535}function Uu(n,t){return n<<t|n>>>32-t}function yn(n,t,e,r,i,s){return He(Uu(He(He(t,n),He(r,s)),i),e)}function le(n,t,e,r,i,s,o){return yn(t&e|~t&r,n,t,i,s,o)}function he(n,t,e,r,i,s,o){return yn(t&r|e&~r,n,t,i,s,o)}function de(n,t,e,r,i,s,o){return yn(t^e^r,n,t,i,s,o)}function pe(n,t,e,r,i,s,o){return yn(e^(t|~r),n,t,i,s,o)}var zu=Xo("v3",48,Lu);function Ku(n,t,e){n=n||{};var r=n.random||(n.rng||Zo)();if(r[6]=r[6]&15|64,r[8]=r[8]&63|128,t){e=e||0;for(var i=0;i<16;++i)t[e+i]=r[i];return t}return gn(r)}function qu(n,t,e,r){switch(n){case 0:return t&e^~t&r;case 1:return t^e^r;case 2:return t&e^t&r^e&r;case 3:return t^e^r}}function is(n,t){return n<<t|n>>>32-t}function Du(n){var t=[1518500249,1859775393,2400959708,3395469782],e=[1732584193,4023233417,2562383102,271733878,3285377520];if(typeof n=="string"){var r=unescape(encodeURIComponent(n));n=[];for(var i=0;i<r.length;++i)n.push(r.charCodeAt(i))}else Array.isArray(n)||(n=Array.prototype.slice.call(n));n.push(128);for(var s=n.length/4+2,o=Math.ceil(s/16),h=new Array(o),l=0;l<o;++l){for(var y=new Uint32Array(16),S=0;S<16;++S)y[S]=n[l*64+S*4]<<24|n[l*64+S*4+1]<<16|n[l*64+S*4+2]<<8|n[l*64+S*4+3];h[l]=y}h[o-1][14]=(n.length-1)*8/Math.pow(2,32),h[o-1][14]=Math.floor(h[o-1][14]),h[o-1][15]=(n.length-1)*8&4294967295;for(var I=0;I<o;++I){for(var x=new Uint32Array(80),k=0;k<16;++k)x[k]=h[I][k];for(var R=16;R<80;++R)x[R]=is(x[R-3]^x[R-8]^x[R-14]^x[R-16],1);for(var A=e[0],T=e[1],C=e[2],D=e[3],U=e[4],W=0;W<80;++W){var G=Math.floor(W/20),$=is(A,5)+qu(G,T,C,D)+U+t[G]+x[W]>>>0;U=D,D=C,C=is(T,30)>>>0,T=A,A=$}e[0]=e[0]+A>>>0,e[1]=e[1]+T>>>0,e[2]=e[2]+C>>>0,e[3]=e[3]+D>>>0,e[4]=e[4]+U>>>0}return[e[0]>>24&255,e[0]>>16&255,e[0]>>8&255,e[0]&255,e[1]>>24&255,e[1]>>16&255,e[1]>>8&255,e[1]&255,e[2]>>24&255,e[2]>>16&255,e[2]>>8&255,e[2]&255,e[3]>>24&255,e[3]>>16&255,e[3]>>8&255,e[3]&255,e[4]>>24&255,e[4]>>16&255,e[4]>>8&255,e[4]&255]}var Fu=Xo("v5",80,Du);const Wu="00000000-0000-0000-0000-000000000000";function Vu(n){if(!pn(n))throw TypeError("Invalid UUID");return parseInt(n.substr(14,1),16)}const Hu=Object.freeze(Object.defineProperty({__proto__:null,NIL:Wu,parse:Yo,stringify:gn,v1:Ru,v3:zu,v4:Ku,v5:Fu,validate:pn,version:Vu},Symbol.toStringTag,{value:"Module"})),Qo=ho(Hu);var os,qi;function $u(){if(qi)return os;qi=1;const n=Qo.v4;return os=function(e,r,i,s){if(typeof e!="string")throw new TypeError(e+" must be a string");s=s||{};const o=typeof s.version=="number"?s.version:2;if(o!==1&&o!==2)throw new TypeError(o+" must be 1 or 2");const h={method:e};if(o===2&&(h.jsonrpc="2.0"),r){if(typeof r!="object"&&!Array.isArray(r))throw new TypeError(r+" must be an object, array or omitted");h.params=r}if(typeof i>"u"){const l=typeof s.generator=="function"?s.generator:function(){return n()};h.id=l(h,s)}else o===2&&i===null?s.notificationIdNull&&(h.id=null):h.id=i;return h},os}var as,Di;function ju(){if(Di)return as;Di=1;const n=Qo.v4,t=$u(),e=function(r,i){if(!(this instanceof e))return new e(r,i);i||(i={}),this.options={reviver:typeof i.reviver<"u"?i.reviver:null,replacer:typeof i.replacer<"u"?i.replacer:null,generator:typeof i.generator<"u"?i.generator:function(){return n()},version:typeof i.version<"u"?i.version:2,notificationIdNull:typeof i.notificationIdNull=="boolean"?i.notificationIdNull:!1},this.callServer=r};return as=e,e.prototype.request=function(r,i,s,o){const h=this;let l=null;const y=Array.isArray(r)&&typeof i=="function";if(this.options.version===1&&y)throw new TypeError("JSON-RPC 1.0 does not support batching");if(y||!y&&r&&typeof r=="object"&&typeof i=="function")o=i,l=r;else{typeof s=="function"&&(o=s,s=void 0);const x=typeof o=="function";try{l=t(r,i,s,{generator:this.options.generator,version:this.options.version,notificationIdNull:this.options.notificationIdNull})}catch(k){if(x){o(k);return}throw k}if(!x)return l}let I;try{I=JSON.stringify(l,this.options.replacer)}catch(x){o(x);return}return this.callServer(I,function(x,k){h._parseResponse(x,k,o)}),l},e.prototype._parseResponse=function(r,i,s){if(r){s(r);return}if(!i){s();return}let o;try{o=JSON.parse(i,this.options.reviver)}catch(h){s(h);return}if(s.length===3)if(Array.isArray(o)){const h=function(y){return typeof y.error<"u"},l=function(y){return!h(y)};s(null,o.filter(h),o.filter(l));return}else{s(null,o.error,o.result);return}s(null,o)},as}var Gu=ju();const Zu=fn(Gu);var cs={exports:{}},Fi;function Yu(){return Fi||(Fi=1,(function(n){var t=Object.prototype.hasOwnProperty,e="~";function r(){}Object.create&&(r.prototype=Object.create(null),new r().__proto__||(e=!1));function i(l,y,S){this.fn=l,this.context=y,this.once=S||!1}function s(l,y,S,I,x){if(typeof S!="function")throw new TypeError("The listener must be a function");var k=new i(S,I||l,x),R=e?e+y:y;return l._events[R]?l._events[R].fn?l._events[R]=[l._events[R],k]:l._events[R].push(k):(l._events[R]=k,l._eventsCount++),l}function o(l,y){--l._eventsCount===0?l._events=new r:delete l._events[y]}function h(){this._events=new r,this._eventsCount=0}h.prototype.eventNames=function(){var y=[],S,I;if(this._eventsCount===0)return y;for(I in S=this._events)t.call(S,I)&&y.push(e?I.slice(1):I);return Object.getOwnPropertySymbols?y.concat(Object.getOwnPropertySymbols(S)):y},h.prototype.listeners=function(y){var S=e?e+y:y,I=this._events[S];if(!I)return[];if(I.fn)return[I.fn];for(var x=0,k=I.length,R=new Array(k);x<k;x++)R[x]=I[x].fn;return R},h.prototype.listenerCount=function(y){var S=e?e+y:y,I=this._events[S];return I?I.fn?1:I.length:0},h.prototype.emit=function(y,S,I,x,k,R){var A=e?e+y:y;if(!this._events[A])return!1;var T=this._events[A],C=arguments.length,D,U;if(T.fn){switch(T.once&&this.removeListener(y,T.fn,void 0,!0),C){case 1:return T.fn.call(T.context),!0;case 2:return T.fn.call(T.context,S),!0;case 3:return T.fn.call(T.context,S,I),!0;case 4:return T.fn.call(T.context,S,I,x),!0;case 5:return T.fn.call(T.context,S,I,x,k),!0;case 6:return T.fn.call(T.context,S,I,x,k,R),!0}for(U=1,D=new Array(C-1);U<C;U++)D[U-1]=arguments[U];T.fn.apply(T.context,D)}else{var W=T.length,G;for(U=0;U<W;U++)switch(T[U].once&&this.removeListener(y,T[U].fn,void 0,!0),C){case 1:T[U].fn.call(T[U].context);break;case 2:T[U].fn.call(T[U].context,S);break;case 3:T[U].fn.call(T[U].context,S,I);break;case 4:T[U].fn.call(T[U].context,S,I,x);break;default:if(!D)for(G=1,D=new Array(C-1);G<C;G++)D[G-1]=arguments[G];T[U].fn.apply(T[U].context,D)}}return!0},h.prototype.on=function(y,S,I){return s(this,y,S,I,!1)},h.prototype.once=function(y,S,I){return s(this,y,S,I,!0)},h.prototype.removeListener=function(y,S,I,x){var k=e?e+y:y;if(!this._events[k])return this;if(!S)return o(this,k),this;var R=this._events[k];if(R.fn)R.fn===S&&(!x||R.once)&&(!I||R.context===I)&&o(this,k);else{for(var A=0,T=[],C=R.length;A<C;A++)(R[A].fn!==S||x&&!R[A].once||I&&R[A].context!==I)&&T.push(R[A]);T.length?this._events[k]=T.length===1?T[0]:T:o(this,k)}return this},h.prototype.removeAllListeners=function(y){var S;return y?(S=e?e+y:y,this._events[S]&&o(this,S)):(this._events=new r,this._eventsCount=0),this},h.prototype.off=h.prototype.removeListener,h.prototype.addListener=h.prototype.on,h.prefixed=e,h.EventEmitter=h,n.exports=h})(cs)),cs.exports}var Xu=Yu();const ta=fn(Xu);var Ju=class extends ta{socket;constructor(n,t){super(),this.socket=new window.WebSocket(n,t.protocols),this.socket.onopen=()=>this.emit("open"),this.socket.onmessage=e=>this.emit("message",e.data),this.socket.onerror=e=>this.emit("error",e),this.socket.onclose=e=>{this.emit("close",e.code,e.reason)}}send(n,t,e){const r=e||t;try{this.socket.send(n),r()}catch(i){r(i)}}close(n,t){this.socket.close(n,t)}addEventListener(n,t,e){this.socket.addEventListener(n,t,e)}};function Qu(n,t){return new Ju(n,t)}var tf=class{encode(n){return JSON.stringify(n)}decode(n){return JSON.parse(n)}},ef=class extends ta{address;rpc_id;queue;options;autoconnect;ready;reconnect;reconnect_timer_id;reconnect_interval;max_reconnects;rest_options;current_reconnects;generate_request_id;socket;webSocketFactory;dataPack;constructor(n,t="ws://localhost:8080",{autoconnect:e=!0,reconnect:r=!0,reconnect_interval:i=1e3,max_reconnects:s=5,...o}={},h,l){super(),this.webSocketFactory=n,this.queue={},this.rpc_id=0,this.address=t,this.autoconnect=e,this.ready=!1,this.reconnect=r,this.reconnect_timer_id=void 0,this.reconnect_interval=i,this.max_reconnects=s,this.rest_options=o,this.current_reconnects=0,this.generate_request_id=h||(()=>typeof this.rpc_id=="number"?++this.rpc_id:Number(this.rpc_id)+1),l?this.dataPack=l:this.dataPack=new tf,this.autoconnect&&this._connect(this.address,{autoconnect:this.autoconnect,reconnect:this.reconnect,reconnect_interval:this.reconnect_interval,max_reconnects:this.max_reconnects,...this.rest_options})}connect(){this.socket||this._connect(this.address,{autoconnect:this.autoconnect,reconnect:this.reconnect,reconnect_interval:this.reconnect_interval,max_reconnects:this.max_reconnects,...this.rest_options})}call(n,t,e,r){return!r&&typeof e=="object"&&(r=e,e=null),new Promise((i,s)=>{if(!this.ready)return s(new Error("socket not ready"));const o=this.generate_request_id(n,t),h={jsonrpc:"2.0",method:n,params:t||void 0,id:o};this.socket.send(this.dataPack.encode(h),r,l=>{if(l)return s(l);this.queue[o]={promise:[i,s]},e&&(this.queue[o].timeout=setTimeout(()=>{delete this.queue[o],s(new Error("reply timeout"))},e))})})}async login(n){const t=await this.call("rpc.login",n);if(!t)throw new Error("authentication failed");return t}async listMethods(){return await this.call("__listMethods")}notify(n,t){return new Promise((e,r)=>{if(!this.ready)return r(new Error("socket not ready"));const i={jsonrpc:"2.0",method:n,params:t};this.socket.send(this.dataPack.encode(i),s=>{if(s)return r(s);e()})})}async subscribe(n){typeof n=="string"&&(n=[n]);const t=await this.call("rpc.on",n);if(typeof n=="string"&&t[n]!=="ok")throw new Error("Failed subscribing to an event '"+n+"' with: "+t[n]);return t}async unsubscribe(n){typeof n=="string"&&(n=[n]);const t=await this.call("rpc.off",n);if(typeof n=="string"&&t[n]!=="ok")throw new Error("Failed unsubscribing from an event with: "+t);return t}close(n,t){this.socket&&this.socket.close(n||1e3,t)}setAutoReconnect(n){this.reconnect=n}setReconnectInterval(n){this.reconnect_interval=n}setMaxReconnects(n){this.max_reconnects=n}getCurrentReconnects(){return this.current_reconnects}getMaxReconnects(){return this.max_reconnects}isReconnecting(){return this.reconnect_timer_id!==void 0}willReconnect(){return this.reconnect&&(this.max_reconnects===0||this.current_reconnects<this.max_reconnects)}_connect(n,t){clearTimeout(this.reconnect_timer_id),this.socket=this.webSocketFactory(n,t),this.socket.addEventListener("open",()=>{this.ready=!0,this.emit("open"),this.current_reconnects=0}),this.socket.addEventListener("message",({data:e})=>{e instanceof ArrayBuffer&&(e=nt.Buffer.from(e).toString());try{e=this.dataPack.decode(e)}catch{return}if(e.notification&&this.listeners(e.notification).length){if(!Object.keys(e.params).length)return this.emit(e.notification);const r=[e.notification];if(e.params.constructor===Object)r.push(e.params);else for(let i=0;i<e.params.length;i++)r.push(e.params[i]);return Promise.resolve().then(()=>{this.emit.apply(this,r)})}if(!this.queue[e.id])return e.method?Promise.resolve().then(()=>{this.emit(e.method,e?.params)}):void 0;"error"in e=="result"in e&&this.queue[e.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.')),this.queue[e.id].timeout&&clearTimeout(this.queue[e.id].timeout),e.error?this.queue[e.id].promise[1](e.error):this.queue[e.id].promise[0](e.result),delete this.queue[e.id]}),this.socket.addEventListener("error",e=>this.emit("error",e)),this.socket.addEventListener("close",({code:e,reason:r})=>{this.ready&&setTimeout(()=>this.emit("close",e,r),0),this.ready=!1,this.socket=void 0,e!==1e3&&(this.current_reconnects++,this.reconnect&&(this.max_reconnects>this.current_reconnects||this.max_reconnects===0)?this.reconnect_timer_id=setTimeout(()=>this._connect(n,t),this.reconnect_interval):this.reconnect&&this.max_reconnects>0&&this.current_reconnects>=this.max_reconnects&&setTimeout(()=>this.emit("max_reconnects_reached",e,r),1))})}};const rf=BigInt(0),Ar=BigInt(1),nf=BigInt(2),sf=BigInt(7),of=BigInt(256),af=BigInt(113),ea=[],ra=[],na=[];for(let n=0,t=Ar,e=1,r=0;n<24;n++){[e,r]=[r,(2*e+3*r)%5],ea.push(2*(5*r+e)),ra.push((n+1)*(n+2)/2%64);let i=rf;for(let s=0;s<7;s++)t=(t<<Ar^(t>>sf)*af)%of,t&nf&&(i^=Ar<<(Ar<<BigInt(s))-Ar);na.push(i)}const sa=wo(na,!0),cf=sa[0],uf=sa[1],Wi=(n,t,e)=>e>32?Ga(n,t,e):$a(n,t,e),Vi=(n,t,e)=>e>32?Za(n,t,e):ja(n,t,e);function ff(n,t=24){const e=new Uint32Array(10);for(let r=24-t;r<24;r++){for(let o=0;o<10;o++)e[o]=n[o]^n[o+10]^n[o+20]^n[o+30]^n[o+40];for(let o=0;o<10;o+=2){const h=(o+8)%10,l=(o+2)%10,y=e[l],S=e[l+1],I=Wi(y,S,1)^e[h],x=Vi(y,S,1)^e[h+1];for(let k=0;k<50;k+=10)n[o+k]^=I,n[o+k+1]^=x}let i=n[2],s=n[3];for(let o=0;o<24;o++){const h=ra[o],l=Wi(i,s,h),y=Vi(i,s,h),S=ea[o];i=n[S],s=n[S+1],n[S]=l,n[S+1]=y}for(let o=0;o<50;o+=10){for(let h=0;h<10;h++)e[h]=n[o+h];for(let h=0;h<10;h++)n[o+h]^=~e[(h+2)%10]&e[(h+4)%10]}n[0]^=cf[r],n[1]^=uf[r]}je(e)}class Us extends Is{constructor(t,e,r,i=!1,s=24){if(super(),this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,this.enableXOF=!1,this.blockLen=t,this.suffix=e,this.outputLen=r,this.enableXOF=i,this.rounds=s,Mr(r),!(0<t&&t<200))throw new Error("only keccak-f1600 function is supported");this.state=new Uint8Array(200),this.state32=Na(this.state)}clone(){return this._cloneInto()}keccak(){yi(this.state32),ff(this.state32,this.rounds),yi(this.state32),this.posOut=0,this.pos=0}update(t){mr(this),t=ln(t),Ke(t);const{blockLen:e,state:r}=this,i=t.length;for(let s=0;s<i;){const o=Math.min(e-this.pos,i-s);for(let h=0;h<o;h++)r[this.pos++]^=t[s++];this.pos===e&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:t,suffix:e,pos:r,blockLen:i}=this;t[r]^=e,(e&128)!==0&&r===i-1&&this.keccak(),t[i-1]^=128,this.keccak()}writeInto(t){mr(this,!1),Ke(t),this.finish();const e=this.state,{blockLen:r}=this;for(let i=0,s=t.length;i<s;){this.posOut>=r&&this.keccak();const o=Math.min(r-this.posOut,s-i);t.set(e.subarray(this.posOut,this.posOut+o),i),this.posOut+=o,i+=o}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){return Mr(t),this.xofInto(new Uint8Array(t))}digestInto(t){if(yo(t,this),this.finished)throw new Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,je(this.state)}_cloneInto(t){const{blockLen:e,suffix:r,outputLen:i,rounds:s,enableXOF:o}=this;return t||(t=new Us(e,r,i,o,s)),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=s,t.suffix=r,t.outputLen=i,t.enableXOF=o,t.destroyed=this.destroyed,t}}const lf=(n,t,e)=>As(()=>new Us(t,n,e)),Hi=lf(1,136,256/8);class ia extends Is{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,go(t);const r=ln(e);if(this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const i=this.blockLen,s=new Uint8Array(i);s.set(r.length>i?t.create().update(r).digest():r);for(let o=0;o<s.length;o++)s[o]^=54;this.iHash.update(s),this.oHash=t.create();for(let o=0;o<s.length;o++)s[o]^=106;this.oHash.update(s),je(s)}update(t){return mr(this),this.iHash.update(t),this}digestInto(t){mr(this),Ke(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:i,destroyed:s,blockLen:o,outputLen:h}=this;return t=t,t.finished=i,t.destroyed=s,t.blockLen=o,t.outputLen=h,t.oHash=e._cloneInto(t.oHash),t.iHash=r._cloneInto(t.iHash),t}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const oa=(n,t,e)=>new ia(n,t).update(e).digest();oa.create=(n,t)=>new ia(n,t);const $i=(n,t)=>(n+(n>=0?t:-t)/aa)/t;function hf(n,t,e){const[[r,i],[s,o]]=t,h=$i(o*n,e),l=$i(-i*n,e);let y=n-h*r-l*s,S=-h*i-l*o;const I=y<ze,x=S<ze;I&&(y=-y),x&&(S=-S);const k=Ur(Math.ceil(_o(e)/2))+pr;if(y<ze||y>=k||S<ze||S>=k)throw new Error("splitScalar (endomorphism): failed, k="+n);return{k1neg:I,k1:y,k2neg:x,k2:S}}function bs(n){if(!["compact","recovered","der"].includes(n))throw new Error('Signature format must be "compact", "recovered", or "der"');return n}function us(n,t){const e={};for(let r of Object.keys(t))e[r]=n[r]===void 0?t[r]:n[r];return tr(e.lowS,"lowS"),tr(e.prehash,"prehash"),e.format!==void 0&&bs(e.format),e}class df extends Error{constructor(t=""){super(t)}}const Oe={Err:df,_tlv:{encode:(n,t)=>{const{Err:e}=Oe;if(n<0||n>256)throw new e("tlv.encode: wrong tag");if(t.length&1)throw new e("tlv.encode: unpadded data");const r=t.length/2,i=$r(r);if(i.length/2&128)throw new e("tlv.encode: long form length too big");const s=r>127?$r(i.length/2|128):"";return $r(n)+s+i+t},decode(n,t){const{Err:e}=Oe;let r=0;if(n<0||n>256)throw new e("tlv.encode: wrong tag");if(t.length<2||t[r++]!==n)throw new e("tlv.decode: wrong tlv");const i=t[r++],s=!!(i&128);let o=0;if(!s)o=i;else{const l=i&127;if(!l)throw new e("tlv.decode(long): indefinite length not supported");if(l>4)throw new e("tlv.decode(long): byte length is too big");const y=t.subarray(r,r+l);if(y.length!==l)throw new e("tlv.decode: length bytes not complete");if(y[0]===0)throw new e("tlv.decode(long): zero leftmost byte");for(const S of y)o=o<<8|S;if(r+=l,o<128)throw new e("tlv.decode(long): not minimal encoding")}const h=t.subarray(r,r+o);if(h.length!==o)throw new e("tlv.decode: wrong value length");return{v:h,l:t.subarray(r+o)}}},_int:{encode(n){const{Err:t}=Oe;if(n<ze)throw new t("integer: negative integers are not allowed");let e=$r(n);if(Number.parseInt(e[0],16)&8&&(e="00"+e),e.length&1)throw new t("unexpected DER parsing assertion: unpadded hex");return e},decode(n){const{Err:t}=Oe;if(n[0]&128)throw new t("invalid signature integer: negative");if(n[0]===0&&!(n[1]&128))throw new t("invalid signature integer: unnecessary leading zero");return hn(n)}},toSig(n){const{Err:t,_int:e,_tlv:r}=Oe,i=kt("signature",n),{v:s,l:o}=r.decode(48,i);if(o.length)throw new t("invalid signature: left bytes after parsing");const{v:h,l}=r.decode(2,s),{v:y,l:S}=r.decode(2,l);if(S.length)throw new t("invalid signature: left bytes after parsing");return{r:e.decode(h),s:e.decode(y)}},hexFromSig(n){const{_tlv:t,_int:e}=Oe,r=t.encode(2,e.encode(n.r)),i=t.encode(2,e.encode(n.s)),s=r+i;return t.encode(48,s)}},ze=BigInt(0),pr=BigInt(1),aa=BigInt(2),Gr=BigInt(3),pf=BigInt(4);function lr(n,t){const{BYTES:e}=n;let r;if(typeof t=="bigint")r=t;else{let i=kt("private key",t);try{r=n.fromBytes(i)}catch{throw new Error(`invalid private key: expected ui8a of size ${e}, got ${typeof t}`)}}if(!n.isValidNot0(r))throw new Error("invalid private key: out of range [1..N-1]");return r}function gf(n,t={}){const e=qo("weierstrass",n,t),{Fp:r,Fn:i}=e;let s=e.CURVE;const{h:o,n:h}=s;zr(t,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:l}=t;if(l&&(!r.is0(s.a)||typeof l.beta!="bigint"||!Array.isArray(l.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const y=ua(r,i);function S(){if(!r.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function I(K,p,a){const{x:f,y:d}=p.toAffine(),m=r.toBytes(f);if(tr(a,"isCompressed"),a){S();const w=!r.isOdd(d);return Ee(ca(w),m)}else return Ee(Uint8Array.of(4),m,r.toBytes(d))}function x(K){ve(K,void 0,"Point");const{publicKey:p,publicKeyUncompressed:a}=y,f=K.length,d=K[0],m=K.subarray(1);if(f===p&&(d===2||d===3)){const w=r.fromBytes(m);if(!r.isValid(w))throw new Error("bad point: is not on curve, wrong x");const _=A(w);let B;try{B=r.sqrt(_)}catch(u){const g=u instanceof Error?": "+u.message:"";throw new Error("bad point: is not on curve, sqrt error"+g)}S();const b=r.isOdd(B);return(d&1)===1!==b&&(B=r.neg(B)),{x:w,y:B}}else if(f===a&&d===4){const w=r.BYTES,_=r.fromBytes(m.subarray(0,w)),B=r.fromBytes(m.subarray(w,w*2));if(!T(_,B))throw new Error("bad point: is not on curve");return{x:_,y:B}}else throw new Error(`bad point: got length ${f}, expected compressed=${p} or uncompressed=${a}`)}const k=t.toBytes||I,R=t.fromBytes||x;function A(K){const p=r.sqr(K),a=r.mul(p,K);return r.add(r.add(a,r.mul(K,s.a)),s.b)}function T(K,p){const a=r.sqr(p),f=A(K);return r.eql(a,f)}if(!T(s.Gx,s.Gy))throw new Error("bad curve params: generator point");const C=r.mul(r.pow(s.a,Gr),pf),D=r.mul(r.sqr(s.b),BigInt(27));if(r.is0(r.add(C,D)))throw new Error("bad curve params: a or b");function U(K,p,a=!1){if(!r.isValid(p)||a&&r.is0(p))throw new Error(`bad point coordinate ${K}`);return p}function W(K){if(!(K instanceof M))throw new Error("ProjectivePoint expected")}function G(K){if(!l||!l.basises)throw new Error("no endo");return hf(K,l.basises,i.ORDER)}const $=tn((K,p)=>{const{X:a,Y:f,Z:d}=K;if(r.eql(d,r.ONE))return{x:a,y:f};const m=K.is0();p==null&&(p=m?r.ONE:r.inv(d));const w=r.mul(a,p),_=r.mul(f,p),B=r.mul(d,p);if(m)return{x:r.ZERO,y:r.ZERO};if(!r.eql(B,r.ONE))throw new Error("invZ was invalid");return{x:w,y:_}}),rt=tn(K=>{if(K.is0()){if(t.allowInfinityPoint&&!r.is0(K.Y))return;throw new Error("bad point: ZERO")}const{x:p,y:a}=K.toAffine();if(!r.isValid(p)||!r.isValid(a))throw new Error("bad point: x or y not field elements");if(!T(p,a))throw new Error("bad point: equation left != right");if(!K.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function Q(K,p,a,f,d){return a=new M(r.mul(a.X,K),a.Y,a.Z),p=en(f,p),a=en(d,a),p.add(a)}class M{constructor(p,a,f){this.X=U("x",p),this.Y=U("y",a,!0),this.Z=U("z",f),Object.freeze(this)}static CURVE(){return s}static fromAffine(p){const{x:a,y:f}=p||{};if(!p||!r.isValid(a)||!r.isValid(f))throw new Error("invalid affine point");if(p instanceof M)throw new Error("projective point not allowed");return r.is0(a)&&r.is0(f)?M.ZERO:new M(a,f,r.ONE)}static fromBytes(p){const a=M.fromAffine(R(ve(p,void 0,"point")));return a.assertValidity(),a}static fromHex(p){return M.fromBytes(kt("pointHex",p))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(p=8,a=!0){return N.createCache(this,p),a||this.multiply(Gr),this}assertValidity(){rt(this)}hasEvenY(){const{y:p}=this.toAffine();if(!r.isOdd)throw new Error("Field doesn't support isOdd");return!r.isOdd(p)}equals(p){W(p);const{X:a,Y:f,Z:d}=this,{X:m,Y:w,Z:_}=p,B=r.eql(r.mul(a,_),r.mul(m,d)),b=r.eql(r.mul(f,_),r.mul(w,d));return B&&b}negate(){return new M(this.X,r.neg(this.Y),this.Z)}double(){const{a:p,b:a}=s,f=r.mul(a,Gr),{X:d,Y:m,Z:w}=this;let _=r.ZERO,B=r.ZERO,b=r.ZERO,c=r.mul(d,d),u=r.mul(m,m),g=r.mul(w,w),v=r.mul(d,m);return v=r.add(v,v),b=r.mul(d,w),b=r.add(b,b),_=r.mul(p,b),B=r.mul(f,g),B=r.add(_,B),_=r.sub(u,B),B=r.add(u,B),B=r.mul(_,B),_=r.mul(v,_),b=r.mul(f,b),g=r.mul(p,g),v=r.sub(c,g),v=r.mul(p,v),v=r.add(v,b),b=r.add(c,c),c=r.add(b,c),c=r.add(c,g),c=r.mul(c,v),B=r.add(B,c),g=r.mul(m,w),g=r.add(g,g),c=r.mul(g,v),_=r.sub(_,c),b=r.mul(g,u),b=r.add(b,b),b=r.add(b,b),new M(_,B,b)}add(p){W(p);const{X:a,Y:f,Z:d}=this,{X:m,Y:w,Z:_}=p;let B=r.ZERO,b=r.ZERO,c=r.ZERO;const u=s.a,g=r.mul(s.b,Gr);let v=r.mul(a,m),L=r.mul(f,w),q=r.mul(d,_),X=r.add(a,f),J=r.add(m,w);X=r.mul(X,J),J=r.add(v,L),X=r.sub(X,J),J=r.add(a,d);let ht=r.add(m,_);return J=r.mul(J,ht),ht=r.add(v,q),J=r.sub(J,ht),ht=r.add(f,d),B=r.add(w,_),ht=r.mul(ht,B),B=r.add(L,q),ht=r.sub(ht,B),c=r.mul(u,J),B=r.mul(g,q),c=r.add(B,c),B=r.sub(L,c),c=r.add(L,c),b=r.mul(B,c),L=r.add(v,v),L=r.add(L,v),q=r.mul(u,q),J=r.mul(g,J),L=r.add(L,q),q=r.sub(v,q),q=r.mul(u,q),J=r.add(J,q),v=r.mul(L,J),b=r.add(b,v),v=r.mul(ht,J),B=r.mul(X,B),B=r.sub(B,v),v=r.mul(X,L),c=r.mul(ht,c),c=r.add(c,v),new M(B,b,c)}subtract(p){return this.add(p.negate())}is0(){return this.equals(M.ZERO)}multiply(p){const{endo:a}=t;if(!i.isValidNot0(p))throw new Error("invalid scalar: out of range");let f,d;const m=w=>N.cached(this,w,_=>Xe(M,_));if(a){const{k1neg:w,k1:_,k2neg:B,k2:b}=G(p),{p:c,f:u}=m(_),{p:g,f:v}=m(b);d=u.add(v),f=Q(a.beta,c,g,w,B)}else{const{p:w,f:_}=m(p);f=w,d=_}return Xe(M,[f,d])[0]}multiplyUnsafe(p){const{endo:a}=t,f=this;if(!i.isValid(p))throw new Error("invalid scalar: out of range");if(p===ze||f.is0())return M.ZERO;if(p===pr)return f;if(N.hasCache(this))return this.multiply(p);if(a){const{k1neg:d,k1:m,k2neg:w,k2:_}=G(p),{p1:B,p2:b}=Sc(M,f,m,_);return Q(a.beta,B,b,d,w)}else return N.unsafe(f,p)}multiplyAndAddUnsafe(p,a,f){const d=this.multiplyUnsafe(a).add(p.multiplyUnsafe(f));return d.is0()?void 0:d}toAffine(p){return $(this,p)}isTorsionFree(){const{isTorsionFree:p}=t;return o===pr?!0:p?p(M,this):N.unsafe(this,h).is0()}clearCofactor(){const{clearCofactor:p}=t;return o===pr?this:p?p(M,this):this.multiplyUnsafe(o)}isSmallOrder(){return this.multiplyUnsafe(o).is0()}toBytes(p=!0){return tr(p,"isCompressed"),this.assertValidity(),k(M,this,p)}toHex(p=!0){return Qe(this.toBytes(p))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get px(){return this.X}get py(){return this.X}get pz(){return this.Z}toRawBytes(p=!0){return this.toBytes(p)}_setWindowSize(p){this.precompute(p)}static normalizeZ(p){return Xe(M,p)}static msm(p,a){return Ko(M,i,p,a)}static fromPrivateKey(p){return M.BASE.multiply(lr(i,p))}}M.BASE=new M(s.Gx,s.Gy,r.ONE),M.ZERO=new M(r.ZERO,r.ONE,r.ZERO),M.Fp=r,M.Fn=i;const P=i.BITS,N=new zo(M,t.endo?Math.ceil(P/2):P);return M.BASE.precompute(8),M}function ca(n){return Uint8Array.of(n?2:3)}function ua(n,t){return{secretKey:t.BYTES,publicKey:1+n.BYTES,publicKeyUncompressed:1+2*n.BYTES,publicKeyHasPrefix:!0,signature:2*t.BYTES}}function yf(n,t={}){const{Fn:e}=n,r=t.randomBytes||Bs,i=Object.assign(ua(n.Fp,e),{seed:Oo(e.ORDER)});function s(k){try{return!!lr(e,k)}catch{return!1}}function o(k,R){const{publicKey:A,publicKeyUncompressed:T}=i;try{const C=k.length;return R===!0&&C!==A||R===!1&&C!==T?!1:!!n.fromBytes(k)}catch{return!1}}function h(k=r(i.seed)){return wc(ve(k,i.seed,"seed"),e.ORDER)}function l(k,R=!0){return n.BASE.multiply(lr(e,k)).toBytes(R)}function y(k){const R=h(k);return{secretKey:R,publicKey:l(R)}}function S(k){if(typeof k=="bigint")return!1;if(k instanceof n)return!0;const{secretKey:R,publicKey:A,publicKeyUncompressed:T}=i;if(e.allowedLengths||R===A)return;const C=kt("key",k).length;return C===A||C===T}function I(k,R,A=!0){if(S(k)===!0)throw new Error("first arg must be private key");if(S(R)===!1)throw new Error("second arg must be public key");const T=lr(e,k);return n.fromHex(R).multiply(T).toBytes(A)}return Object.freeze({getPublicKey:l,getSharedSecret:I,keygen:y,Point:n,utils:{isValidSecretKey:s,isValidPublicKey:o,randomSecretKey:h,isValidPrivateKey:s,randomPrivateKey:h,normPrivateKeyToScalar:k=>lr(e,k),precompute(k=8,R=n.BASE){return R.precompute(k,!1)}},lengths:i})}function mf(n,t,e={}){go(t),zr(e,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const r=e.randomBytes||Bs,i=e.hmac||((a,...f)=>oa(t,a,Ee(...f))),{Fp:s,Fn:o}=n,{ORDER:h,BITS:l}=o,{keygen:y,getPublicKey:S,getSharedSecret:I,utils:x,lengths:k}=yf(n,e),R={prehash:!1,lowS:typeof e.lowS=="boolean"?e.lowS:!1,format:void 0,extraEntropy:!1},A="compact";function T(a){const f=h>>pr;return a>f}function C(a,f){if(!o.isValidNot0(f))throw new Error(`invalid signature ${a}: out of range 1..Point.Fn.ORDER`);return f}function D(a,f){bs(f);const d=k.signature,m=f==="compact"?d:f==="recovered"?d+1:void 0;return ve(a,m,`${f} signature`)}class U{constructor(f,d,m){this.r=C("r",f),this.s=C("s",d),m!=null&&(this.recovery=m),Object.freeze(this)}static fromBytes(f,d=A){D(f,d);let m;if(d==="der"){const{r:b,s:c}=Oe.toSig(ve(f));return new U(b,c)}d==="recovered"&&(m=f[0],d="compact",f=f.subarray(1));const w=o.BYTES,_=f.subarray(0,w),B=f.subarray(w,w*2);return new U(o.fromBytes(_),o.fromBytes(B),m)}static fromHex(f,d){return this.fromBytes(Qr(f),d)}addRecoveryBit(f){return new U(this.r,this.s,f)}recoverPublicKey(f){const d=s.ORDER,{r:m,s:w,recovery:_}=this;if(_==null||![0,1,2,3].includes(_))throw new Error("recovery id invalid");if(h*aa<d&&_>1)throw new Error("recovery id is ambiguous for h>1 curve");const b=_===2||_===3?m+h:m;if(!s.isValid(b))throw new Error("recovery id 2 or 3 invalid");const c=s.toBytes(b),u=n.fromBytes(Ee(ca((_&1)===0),c)),g=o.inv(b),v=G(kt("msgHash",f)),L=o.create(-v*g),q=o.create(w*g),X=n.BASE.multiplyUnsafe(L).add(u.multiplyUnsafe(q));if(X.is0())throw new Error("point at infinify");return X.assertValidity(),X}hasHighS(){return T(this.s)}toBytes(f=A){if(bs(f),f==="der")return Qr(Oe.hexFromSig(this));const d=o.toBytes(this.r),m=o.toBytes(this.s);if(f==="recovered"){if(this.recovery==null)throw new Error("recovery bit must be present");return Ee(Uint8Array.of(this.recovery),d,m)}return Ee(d,m)}toHex(f){return Qe(this.toBytes(f))}assertValidity(){}static fromCompact(f){return U.fromBytes(kt("sig",f),"compact")}static fromDER(f){return U.fromBytes(kt("sig",f),"der")}normalizeS(){return this.hasHighS()?new U(this.r,o.neg(this.s),this.recovery):this}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return Qe(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return Qe(this.toBytes("compact"))}}const W=e.bits2int||function(f){if(f.length>8192)throw new Error("input is too large");const d=hn(f),m=f.length*8-l;return m>0?d>>BigInt(m):d},G=e.bits2int_modN||function(f){return o.create(W(f))},$=Ur(l);function rt(a){return ms("num < 2^"+l,a,ze,$),o.toBytes(a)}function Q(a,f){return ve(a,void 0,"message"),f?ve(t(a),void 0,"prehashed message"):a}function M(a,f,d){if(["recovered","canonical"].some(L=>L in d))throw new Error("sign() legacy options not supported");const{lowS:m,prehash:w,extraEntropy:_}=us(d,R);a=Q(a,w);const B=G(a),b=lr(o,f),c=[rt(b),rt(B)];if(_!=null&&_!==!1){const L=_===!0?r(k.secretKey):_;c.push(kt("extraEntropy",L))}const u=Ee(...c),g=B;function v(L){const q=W(L);if(!o.isValidNot0(q))return;const X=o.inv(q),J=n.BASE.multiply(q).toAffine(),ht=o.create(J.x);if(ht===ze)return;const dt=o.create(X*o.create(g+ht*b));if(dt===ze)return;let mt=(J.x===ht?0:2)|Number(J.y&pr),Ir=dt;return m&&T(dt)&&(Ir=o.neg(dt),mt^=1),new U(ht,Ir,mt)}return{seed:u,k2sig:v}}function P(a,f,d={}){a=kt("message",a);const{seed:m,k2sig:w}=M(a,f,d);return uc(t.outputLen,o.BYTES,i)(m,w)}function N(a){let f;const d=typeof a=="string"||Nr(a),m=!d&&a!==null&&typeof a=="object"&&typeof a.r=="bigint"&&typeof a.s=="bigint";if(!d&&!m)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");if(m)f=new U(a.r,a.s);else if(d){try{f=U.fromBytes(kt("sig",a),"der")}catch(w){if(!(w instanceof Oe.Err))throw w}if(!f)try{f=U.fromBytes(kt("sig",a),"compact")}catch{return!1}}return f||!1}function K(a,f,d,m={}){const{lowS:w,prehash:_,format:B}=us(m,R);if(d=kt("publicKey",d),f=Q(kt("message",f),_),"strict"in m)throw new Error("options.strict was renamed to lowS");const b=B===void 0?N(a):U.fromBytes(kt("sig",a),B);if(b===!1)return!1;try{const c=n.fromBytes(d);if(w&&b.hasHighS())return!1;const{r:u,s:g}=b,v=G(f),L=o.inv(g),q=o.create(v*L),X=o.create(u*L),J=n.BASE.multiplyUnsafe(q).add(c.multiplyUnsafe(X));return J.is0()?!1:o.create(J.x)===u}catch{return!1}}function p(a,f,d={}){const{prehash:m}=us(d,R);return f=Q(f,m),U.fromBytes(a,"recovered").recoverPublicKey(f).toBytes()}return Object.freeze({keygen:y,getPublicKey:S,getSharedSecret:I,utils:x,lengths:k,Point:n,sign:P,verify:K,recoverPublicKey:p,Signature:U,hash:t})}function bf(n){const t={a:n.a,b:n.b,p:n.Fp.ORDER,n:n.n,h:n.h,Gx:n.Gx,Gy:n.Gy},e=n.Fp;let r=n.allowedPrivateKeyLengths?Array.from(new Set(n.allowedPrivateKeyLengths.map(o=>Math.ceil(o/2)))):void 0;const i=nr(t.n,{BITS:n.nBitLength,allowedLengths:r,modFromBytes:n.wrapPrivateKey}),s={Fp:e,Fn:i,allowInfinityPoint:n.allowInfinityPoint,endo:n.endo,isTorsionFree:n.isTorsionFree,clearCofactor:n.clearCofactor,fromBytes:n.fromBytes,toBytes:n.toBytes};return{CURVE:t,curveOpts:s}}function wf(n){const{CURVE:t,curveOpts:e}=bf(n),r={hmac:n.hmac,randomBytes:n.randomBytes,lowS:n.lowS,bits2int:n.bits2int,bits2int_modN:n.bits2int_modN};return{CURVE:t,curveOpts:e,hash:n.hash,ecdsaOpts:r}}function vf(n,t){const e=t.Point;return Object.assign({},t,{ProjectivePoint:e,CURVE:Object.assign({},n,Lo(e.Fn.ORDER,e.Fn.BITS))})}function kf(n){const{CURVE:t,curveOpts:e,hash:r,ecdsaOpts:i}=wf(n),s=gf(t,e),o=mf(s,r,i);return vf(n,o)}function Sf(n,t){const e=r=>kf({...n,hash:r});return{...e(t),create:e}}const zs={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},xf={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},ji=BigInt(2);function _f(n){const t=zs.p,e=BigInt(3),r=BigInt(6),i=BigInt(11),s=BigInt(22),o=BigInt(23),h=BigInt(44),l=BigInt(88),y=n*n*n%t,S=y*y*n%t,I=vt(S,e,t)*S%t,x=vt(I,e,t)*S%t,k=vt(x,ji,t)*y%t,R=vt(k,i,t)*k%t,A=vt(R,s,t)*R%t,T=vt(A,h,t)*A%t,C=vt(T,l,t)*T%t,D=vt(C,h,t)*A%t,U=vt(D,e,t)*S%t,W=vt(U,o,t)*R%t,G=vt(W,r,t)*y%t,$=vt(G,ji,t);if(!ws.eql(ws.sqr($),n))throw new Error("Cannot find square root");return $}const ws=nr(zs.p,{sqrt:_f}),Ks=Sf({...zs,Fp:ws,lowS:!0,endo:xf},ko),Ef=Sr.utils.randomPrivateKey,Gi=()=>{const n=Sr.utils.randomPrivateKey(),t=cn(n),e=new Uint8Array(64);return e.set(n),e.set(t,32),{publicKey:t,secretKey:e}},cn=Sr.getPublicKey;function Zi(n){try{return Sr.ExtendedPoint.fromHex(n),!0}catch{return!1}}const qs=(n,t)=>Sr.sign(n,t.slice(0,32)),If=Sr.verify,it=n=>nt.Buffer.isBuffer(n)?n:n instanceof Uint8Array?nt.Buffer.from(n.buffer,n.byteOffset,n.byteLength):nt.Buffer.from(n);class Ds{constructor(t){Object.assign(this,t)}encode(){return nt.Buffer.from(ts.serialize(Rr,this))}static decode(t){return ts.deserialize(Rr,this,t)}static decodeUnchecked(t){return ts.deserializeUnchecked(Rr,this,t)}}class Af extends Ds{constructor(t){if(super(t),this.enum="",Object.keys(t).length!==1)throw new Error("Enum can only take single value");Object.keys(t).map(e=>{this.enum=e})}}const Rr=new Map;var fa;const la=32,Re=32;function Bf(n){return n._bn!==void 0}let Yi=1;class H extends Ds{constructor(t){if(super({}),this._bn=void 0,Bf(t))this._bn=t._bn;else{if(typeof t=="string"){const e=ce.decode(t);if(e.length!=Re)throw new Error("Invalid public key input");this._bn=new Mi(e)}else this._bn=new Mi(t);if(this._bn.byteLength()>Re)throw new Error("Invalid public key input")}}static unique(){const t=new H(Yi);return Yi+=1,new H(t.toBuffer())}equals(t){return this._bn.eq(t._bn)}toBase58(){return ce.encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){const t=this.toBuffer();return new Uint8Array(t.buffer,t.byteOffset,t.byteLength)}toBuffer(){const t=this._bn.toArrayLike(nt.Buffer);if(t.length===Re)return t;const e=nt.Buffer.alloc(32);return t.copy(e,32-t.length),e}get[Symbol.toStringTag](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(t,e,r){const i=nt.Buffer.concat([t.toBuffer(),nt.Buffer.from(e),r.toBuffer()]),s=Li(i);return new H(s)}static createProgramAddressSync(t,e){let r=nt.Buffer.alloc(0);t.forEach(function(s){if(s.length>la)throw new TypeError("Max seed length exceeded");r=nt.Buffer.concat([r,it(s)])}),r=nt.Buffer.concat([r,e.toBuffer(),nt.Buffer.from("ProgramDerivedAddress")]);const i=Li(r);if(Zi(i))throw new Error("Invalid seeds, address must fall off the curve");return new H(i)}static async createProgramAddress(t,e){return this.createProgramAddressSync(t,e)}static findProgramAddressSync(t,e){let r=255,i;for(;r!=0;){try{const s=t.concat(nt.Buffer.from([r]));i=this.createProgramAddressSync(s,e)}catch(s){if(s instanceof TypeError)throw s;r--;continue}return[i,r]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(t,e){return this.findProgramAddressSync(t,e)}static isOnCurve(t){const e=new H(t);return Zi(e.toBytes())}}fa=H;H.default=new fa("11111111111111111111111111111111");Rr.set(H,{kind:"struct",fields:[["_bn","u256"]]});class Rf{constructor(t){if(this._publicKey=void 0,this._secretKey=void 0,t){const e=it(t);if(t.length!==64)throw new Error("bad secret key size");this._publicKey=e.slice(32,64),this._secretKey=e.slice(0,32)}else this._secretKey=it(Ef()),this._publicKey=it(cn(this._secretKey))}get publicKey(){return new H(this._publicKey)}get secretKey(){return nt.Buffer.concat([this._secretKey,this._publicKey],64)}}const Mf=new H("BPFLoader1111111111111111111111111111111111"),$e=1232,mn=127,Pr=64;class Fs extends Error{constructor(t){super(`Signature ${t} has expired: block height exceeded.`),this.signature=void 0,this.signature=t}}Object.defineProperty(Fs.prototype,"name",{value:"TransactionExpiredBlockheightExceededError"});class Ws extends Error{constructor(t,e){super(`Transaction was not confirmed in ${e.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${t} using the Solana Explorer or CLI tools.`),this.signature=void 0,this.signature=t}}Object.defineProperty(Ws.prototype,"name",{value:"TransactionExpiredTimeoutError"});class hr extends Error{constructor(t){super(`Signature ${t} has expired: the nonce is no longer valid.`),this.signature=void 0,this.signature=t}}Object.defineProperty(hr.prototype,"name",{value:"TransactionExpiredNonceInvalidError"});class Lr{constructor(t,e){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=t,this.accountKeysFromLookups=e}keySegments(){const t=[this.staticAccountKeys];return this.accountKeysFromLookups&&(t.push(this.accountKeysFromLookups.writable),t.push(this.accountKeysFromLookups.readonly)),t}get(t){for(const e of this.keySegments()){if(t<e.length)return e[t];t-=e.length}}get length(){return this.keySegments().flat().length}compileInstructions(t){if(this.length>256)throw new Error("Account index overflow encountered during compilation");const r=new Map;this.keySegments().flat().forEach((s,o)=>{r.set(s.toBase58(),o)});const i=s=>{const o=r.get(s.toBase58());if(o===void 0)throw new Error("Encountered an unknown instruction account key during compilation");return o};return t.map(s=>({programIdIndex:i(s.programId),accountKeyIndexes:s.keys.map(o=>i(o.pubkey)),data:s.data}))}}const ot=(n="publicKey")=>E.blob(32,n),Tf=(n="signature")=>E.blob(64,n),Je=(n="string")=>{const t=E.struct([E.u32("length"),E.u32("lengthPadding"),E.blob(E.offset(E.u32(),-8),"chars")],n),e=t.decode.bind(t),r=t.encode.bind(t),i=t;return i.decode=(s,o)=>e(s,o).chars.toString(),i.encode=(s,o,h)=>{const l={chars:nt.Buffer.from(s,"utf8")};return r(l,o,h)},i.alloc=s=>E.u32().span+E.u32().span+nt.Buffer.from(s,"utf8").length,i},Pf=(n="authorized")=>E.struct([ot("staker"),ot("withdrawer")],n),Lf=(n="lockup")=>E.struct([E.ns64("unixTimestamp"),E.ns64("epoch"),ot("custodian")],n),Cf=(n="voteInit")=>E.struct([ot("nodePubkey"),ot("authorizedVoter"),ot("authorizedWithdrawer"),E.u8("commission")],n),Of=(n="voteAuthorizeWithSeedArgs")=>E.struct([E.u32("voteAuthorizationType"),ot("currentAuthorityDerivedKeyOwnerPubkey"),Je("currentAuthorityDerivedKeySeed"),ot("newAuthorized")],n);function ha(n,t){const e=i=>{if(i.span>=0)return i.span;if(typeof i.alloc=="function")return i.alloc(t[i.property]);if("count"in i&&"elementLayout"in i){const s=t[i.property];if(Array.isArray(s))return s.length*e(i.elementLayout)}else if("fields"in i)return ha({layout:i},t[i.property]);return 0};let r=0;return n.layout.fields.forEach(i=>{r+=e(i)}),r}function ye(n){let t=0,e=0;for(;;){let r=n.shift();if(t|=(r&127)<<e*7,e+=1,(r&128)===0)break}return t}function we(n,t){let e=t;for(;;){let r=e&127;if(e>>=7,e==0){n.push(r);break}else r|=128,n.push(r)}}function ct(n,t){if(!n)throw new Error(t||"Assertion failed")}class bn{constructor(t,e){this.payer=void 0,this.keyMetaMap=void 0,this.payer=t,this.keyMetaMap=e}static compile(t,e){const r=new Map,i=o=>{const h=o.toBase58();let l=r.get(h);return l===void 0&&(l={isSigner:!1,isWritable:!1,isInvoked:!1},r.set(h,l)),l},s=i(e);s.isSigner=!0,s.isWritable=!0;for(const o of t){i(o.programId).isInvoked=!0;for(const h of o.keys){const l=i(h.pubkey);l.isSigner||=h.isSigner,l.isWritable||=h.isWritable}}return new bn(e,r)}getMessageComponents(){const t=[...this.keyMetaMap.entries()];ct(t.length<=256,"Max static account keys length exceeded");const e=t.filter(([,l])=>l.isSigner&&l.isWritable),r=t.filter(([,l])=>l.isSigner&&!l.isWritable),i=t.filter(([,l])=>!l.isSigner&&l.isWritable),s=t.filter(([,l])=>!l.isSigner&&!l.isWritable),o={numRequiredSignatures:e.length+r.length,numReadonlySignedAccounts:r.length,numReadonlyUnsignedAccounts:s.length};{ct(e.length>0,"Expected at least one writable signer key");const[l]=e[0];ct(l===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}const h=[...e.map(([l])=>new H(l)),...r.map(([l])=>new H(l)),...i.map(([l])=>new H(l)),...s.map(([l])=>new H(l))];return[o,h]}extractTableLookup(t){const[e,r]=this.drainKeysFoundInLookupTable(t.state.addresses,o=>!o.isSigner&&!o.isInvoked&&o.isWritable),[i,s]=this.drainKeysFoundInLookupTable(t.state.addresses,o=>!o.isSigner&&!o.isInvoked&&!o.isWritable);if(!(e.length===0&&i.length===0))return[{accountKey:t.key,writableIndexes:e,readonlyIndexes:i},{writable:r,readonly:s}]}drainKeysFoundInLookupTable(t,e){const r=new Array,i=new Array;for(const[s,o]of this.keyMetaMap.entries())if(e(o)){const h=new H(s),l=t.findIndex(y=>y.equals(h));l>=0&&(ct(l<256,"Max lookup table index exceeded"),r.push(l),i.push(h),this.keyMetaMap.delete(s))}return[r,i]}}const da="Reached end of buffer unexpectedly";function Ie(n){if(n.length===0)throw new Error(da);return n.shift()}function me(n,...t){const[e]=t;if(t.length===2?e+(t[1]??0)>n.length:e>=n.length)throw new Error(da);return n.splice(...t)}class Se{constructor(t){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=t.header,this.accountKeys=t.accountKeys.map(e=>new H(e)),this.recentBlockhash=t.recentBlockhash,this.instructions=t.instructions,this.instructions.forEach(e=>this.indexToProgramIds.set(e.programIdIndex,this.accountKeys[e.programIdIndex]))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map(t=>({programIdIndex:t.programIdIndex,accountKeyIndexes:t.accounts,data:ce.decode(t.data)}))}get addressTableLookups(){return[]}getAccountKeys(){return new Lr(this.staticAccountKeys)}static compile(t){const e=bn.compile(t.instructions,t.payerKey),[r,i]=e.getMessageComponents(),o=new Lr(i).compileInstructions(t.instructions).map(h=>({programIdIndex:h.programIdIndex,accounts:h.accountKeyIndexes,data:ce.encode(h.data)}));return new Se({header:r,accountKeys:i,recentBlockhash:t.recentBlockhash,instructions:o})}isAccountSigner(t){return t<this.header.numRequiredSignatures}isAccountWritable(t){const e=this.header.numRequiredSignatures;if(t>=this.header.numRequiredSignatures){const r=t-e,s=this.accountKeys.length-e-this.header.numReadonlyUnsignedAccounts;return r<s}else{const r=e-this.header.numReadonlySignedAccounts;return t<r}}isProgramId(t){return this.indexToProgramIds.has(t)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter((t,e)=>!this.isProgramId(e))}serialize(){const t=this.accountKeys.length;let e=[];we(e,t);const r=this.instructions.map(I=>{const{accounts:x,programIdIndex:k}=I,R=Array.from(ce.decode(I.data));let A=[];we(A,x.length);let T=[];return we(T,R.length),{programIdIndex:k,keyIndicesCount:nt.Buffer.from(A),keyIndices:x,dataLength:nt.Buffer.from(T),data:R}});let i=[];we(i,r.length);let s=nt.Buffer.alloc($e);nt.Buffer.from(i).copy(s);let o=i.length;r.forEach(I=>{const k=E.struct([E.u8("programIdIndex"),E.blob(I.keyIndicesCount.length,"keyIndicesCount"),E.seq(E.u8("keyIndex"),I.keyIndices.length,"keyIndices"),E.blob(I.dataLength.length,"dataLength"),E.seq(E.u8("userdatum"),I.data.length,"data")]).encode(I,s,o);o+=k}),s=s.slice(0,o);const h=E.struct([E.blob(1,"numRequiredSignatures"),E.blob(1,"numReadonlySignedAccounts"),E.blob(1,"numReadonlyUnsignedAccounts"),E.blob(e.length,"keyCount"),E.seq(ot("key"),t,"keys"),ot("recentBlockhash")]),l={numRequiredSignatures:nt.Buffer.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:nt.Buffer.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:nt.Buffer.from([this.header.numReadonlyUnsignedAccounts]),keyCount:nt.Buffer.from(e),keys:this.accountKeys.map(I=>it(I.toBytes())),recentBlockhash:ce.decode(this.recentBlockhash)};let y=nt.Buffer.alloc(2048);const S=h.encode(l,y);return s.copy(y,S),y.slice(0,S+s.length)}static from(t){let e=[...t];const r=Ie(e);if(r!==(r&mn))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const i=Ie(e),s=Ie(e),o=ye(e);let h=[];for(let x=0;x<o;x++){const k=me(e,0,Re);h.push(new H(nt.Buffer.from(k)))}const l=me(e,0,Re),y=ye(e);let S=[];for(let x=0;x<y;x++){const k=Ie(e),R=ye(e),A=me(e,0,R),T=ye(e),C=me(e,0,T),D=ce.encode(nt.Buffer.from(C));S.push({programIdIndex:k,accounts:A,data:D})}const I={header:{numRequiredSignatures:r,numReadonlySignedAccounts:i,numReadonlyUnsignedAccounts:s},recentBlockhash:ce.encode(nt.Buffer.from(l)),accountKeys:h,instructions:S};return new Se(I)}}class er{constructor(t){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=t.header,this.staticAccountKeys=t.staticAccountKeys,this.recentBlockhash=t.recentBlockhash,this.compiledInstructions=t.compiledInstructions,this.addressTableLookups=t.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let t=0;for(const e of this.addressTableLookups)t+=e.readonlyIndexes.length+e.writableIndexes.length;return t}getAccountKeys(t){let e;if(t&&"accountKeysFromLookups"in t&&t.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=t.accountKeysFromLookups.writable.length+t.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");e=t.accountKeysFromLookups}else if(t&&"addressLookupTableAccounts"in t&&t.addressLookupTableAccounts)e=this.resolveAddressTableLookups(t.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new Lr(this.staticAccountKeys,e)}isAccountSigner(t){return t<this.header.numRequiredSignatures}isAccountWritable(t){const e=this.header.numRequiredSignatures,r=this.staticAccountKeys.length;if(t>=r){const i=t-r,s=this.addressTableLookups.reduce((o,h)=>o+h.writableIndexes.length,0);return i<s}else if(t>=this.header.numRequiredSignatures){const i=t-e,o=r-e-this.header.numReadonlyUnsignedAccounts;return i<o}else{const i=e-this.header.numReadonlySignedAccounts;return t<i}}resolveAddressTableLookups(t){const e={writable:[],readonly:[]};for(const r of this.addressTableLookups){const i=t.find(s=>s.key.equals(r.accountKey));if(!i)throw new Error(`Failed to find address lookup table account for table key ${r.accountKey.toBase58()}`);for(const s of r.writableIndexes)if(s<i.state.addresses.length)e.writable.push(i.state.addresses[s]);else throw new Error(`Failed to find address for index ${s} in address lookup table ${r.accountKey.toBase58()}`);for(const s of r.readonlyIndexes)if(s<i.state.addresses.length)e.readonly.push(i.state.addresses[s]);else throw new Error(`Failed to find address for index ${s} in address lookup table ${r.accountKey.toBase58()}`)}return e}static compile(t){const e=bn.compile(t.instructions,t.payerKey),r=new Array,i={writable:new Array,readonly:new Array},s=t.addressLookupTableAccounts||[];for(const S of s){const I=e.extractTableLookup(S);if(I!==void 0){const[x,{writable:k,readonly:R}]=I;r.push(x),i.writable.push(...k),i.readonly.push(...R)}}const[o,h]=e.getMessageComponents(),y=new Lr(h,i).compileInstructions(t.instructions);return new er({header:o,staticAccountKeys:h,recentBlockhash:t.recentBlockhash,compiledInstructions:y,addressTableLookups:r})}serialize(){const t=Array();we(t,this.staticAccountKeys.length);const e=this.serializeInstructions(),r=Array();we(r,this.compiledInstructions.length);const i=this.serializeAddressTableLookups(),s=Array();we(s,this.addressTableLookups.length);const o=E.struct([E.u8("prefix"),E.struct([E.u8("numRequiredSignatures"),E.u8("numReadonlySignedAccounts"),E.u8("numReadonlyUnsignedAccounts")],"header"),E.blob(t.length,"staticAccountKeysLength"),E.seq(ot(),this.staticAccountKeys.length,"staticAccountKeys"),ot("recentBlockhash"),E.blob(r.length,"instructionsLength"),E.blob(e.length,"serializedInstructions"),E.blob(s.length,"addressTableLookupsLength"),E.blob(i.length,"serializedAddressTableLookups")]),h=new Uint8Array($e),y=o.encode({prefix:128,header:this.header,staticAccountKeysLength:new Uint8Array(t),staticAccountKeys:this.staticAccountKeys.map(S=>S.toBytes()),recentBlockhash:ce.decode(this.recentBlockhash),instructionsLength:new Uint8Array(r),serializedInstructions:e,addressTableLookupsLength:new Uint8Array(s),serializedAddressTableLookups:i},h);return h.slice(0,y)}serializeInstructions(){let t=0;const e=new Uint8Array($e);for(const r of this.compiledInstructions){const i=Array();we(i,r.accountKeyIndexes.length);const s=Array();we(s,r.data.length);const o=E.struct([E.u8("programIdIndex"),E.blob(i.length,"encodedAccountKeyIndexesLength"),E.seq(E.u8(),r.accountKeyIndexes.length,"accountKeyIndexes"),E.blob(s.length,"encodedDataLength"),E.blob(r.data.length,"data")]);t+=o.encode({programIdIndex:r.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(i),accountKeyIndexes:r.accountKeyIndexes,encodedDataLength:new Uint8Array(s),data:r.data},e,t)}return e.slice(0,t)}serializeAddressTableLookups(){let t=0;const e=new Uint8Array($e);for(const r of this.addressTableLookups){const i=Array();we(i,r.writableIndexes.length);const s=Array();we(s,r.readonlyIndexes.length);const o=E.struct([ot("accountKey"),E.blob(i.length,"encodedWritableIndexesLength"),E.seq(E.u8(),r.writableIndexes.length,"writableIndexes"),E.blob(s.length,"encodedReadonlyIndexesLength"),E.seq(E.u8(),r.readonlyIndexes.length,"readonlyIndexes")]);t+=o.encode({accountKey:r.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(i),writableIndexes:r.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(s),readonlyIndexes:r.readonlyIndexes},e,t)}return e.slice(0,t)}static deserialize(t){let e=[...t];const r=Ie(e),i=r&mn;ct(r!==i,"Expected versioned message but received legacy message");const s=i;ct(s===0,`Expected versioned message with version 0 but found version ${s}`);const o={numRequiredSignatures:Ie(e),numReadonlySignedAccounts:Ie(e),numReadonlyUnsignedAccounts:Ie(e)},h=[],l=ye(e);for(let R=0;R<l;R++)h.push(new H(me(e,0,Re)));const y=ce.encode(me(e,0,Re)),S=ye(e),I=[];for(let R=0;R<S;R++){const A=Ie(e),T=ye(e),C=me(e,0,T),D=ye(e),U=new Uint8Array(me(e,0,D));I.push({programIdIndex:A,accountKeyIndexes:C,data:U})}const x=ye(e),k=[];for(let R=0;R<x;R++){const A=new H(me(e,0,Re)),T=ye(e),C=me(e,0,T),D=ye(e),U=me(e,0,D);k.push({accountKey:A,writableIndexes:C,readonlyIndexes:U})}return new er({header:o,staticAccountKeys:h,recentBlockhash:y,compiledInstructions:I,addressTableLookups:k})}}const Vs={deserializeMessageVersion(n){const t=n[0],e=t&mn;return e===t?"legacy":e},deserialize:n=>{const t=Vs.deserializeMessageVersion(n);if(t==="legacy")return Se.from(n);if(t===0)return er.deserialize(n);throw new Error(`Transaction message version ${t} deserialization is not supported`)}};let Ce=(function(n){return n[n.BLOCKHEIGHT_EXCEEDED=0]="BLOCKHEIGHT_EXCEEDED",n[n.PROCESSED=1]="PROCESSED",n[n.TIMED_OUT=2]="TIMED_OUT",n[n.NONCE_INVALID=3]="NONCE_INVALID",n})({});const Nf=nt.Buffer.alloc(Pr).fill(0);class pt{constructor(t){this.keys=void 0,this.programId=void 0,this.data=nt.Buffer.alloc(0),this.programId=t.programId,this.keys=t.keys,t.data&&(this.data=t.data)}toJSON(){return{keys:this.keys.map(({pubkey:t,isSigner:e,isWritable:r})=>({pubkey:t.toJSON(),isSigner:e,isWritable:r})),programId:this.programId.toJSON(),data:[...this.data]}}}class ut{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(t){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,!!t)if(t.feePayer&&(this.feePayer=t.feePayer),t.signatures&&(this.signatures=t.signatures),Object.prototype.hasOwnProperty.call(t,"nonceInfo")){const{minContextSlot:e,nonceInfo:r}=t;this.minNonceContextSlot=e,this.nonceInfo=r}else if(Object.prototype.hasOwnProperty.call(t,"lastValidBlockHeight")){const{blockhash:e,lastValidBlockHeight:r}=t;this.recentBlockhash=e,this.lastValidBlockHeight=r}else{const{recentBlockhash:e,nonceInfo:r}=t;r&&(this.nonceInfo=r),this.recentBlockhash=e}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map(t=>t.toJSON()),signers:this.signatures.map(({publicKey:t})=>t.toJSON())}}add(...t){if(t.length===0)throw new Error("No instructions");return t.forEach(e=>{"instructions"in e?this.instructions=this.instructions.concat(e.instructions):"data"in e&&"programId"in e&&"keys"in e?this.instructions.push(e):this.instructions.push(new pt(e))}),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let t,e;if(this.nonceInfo?(t=this.nonceInfo.nonce,this.instructions[0]!=this.nonceInfo.nonceInstruction?e=[this.nonceInfo.nonceInstruction,...this.instructions]:e=this.instructions):(t=this.recentBlockhash,e=this.instructions),!t)throw new Error("Transaction recentBlockhash required");e.length<1&&console.warn("No instructions provided");let r;if(this.feePayer)r=this.feePayer;else if(this.signatures.length>0&&this.signatures[0].publicKey)r=this.signatures[0].publicKey;else throw new Error("Transaction fee payer required");for(let A=0;A<e.length;A++)if(e[A].programId===void 0)throw new Error(`Transaction instruction index ${A} has undefined program id`);const i=[],s=[];e.forEach(A=>{A.keys.forEach(C=>{s.push({...C})});const T=A.programId.toString();i.includes(T)||i.push(T)}),i.forEach(A=>{s.push({pubkey:new H(A),isSigner:!1,isWritable:!1})});const o=[];s.forEach(A=>{const T=A.pubkey.toString(),C=o.findIndex(D=>D.pubkey.toString()===T);C>-1?(o[C].isWritable=o[C].isWritable||A.isWritable,o[C].isSigner=o[C].isSigner||A.isSigner):o.push(A)}),o.sort(function(A,T){if(A.isSigner!==T.isSigner)return A.isSigner?-1:1;if(A.isWritable!==T.isWritable)return A.isWritable?-1:1;const C={localeMatcher:"best fit",usage:"sort",sensitivity:"variant",ignorePunctuation:!1,numeric:!1,caseFirst:"lower"};return A.pubkey.toBase58().localeCompare(T.pubkey.toBase58(),"en",C)});const h=o.findIndex(A=>A.pubkey.equals(r));if(h>-1){const[A]=o.splice(h,1);A.isSigner=!0,A.isWritable=!0,o.unshift(A)}else o.unshift({pubkey:r,isSigner:!0,isWritable:!0});for(const A of this.signatures){const T=o.findIndex(C=>C.pubkey.equals(A.publicKey));if(T>-1)o[T].isSigner||(o[T].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));else throw new Error(`unknown signer: ${A.publicKey.toString()}`)}let l=0,y=0,S=0;const I=[],x=[];o.forEach(({pubkey:A,isSigner:T,isWritable:C})=>{T?(I.push(A.toString()),l+=1,C||(y+=1)):(x.push(A.toString()),C||(S+=1))});const k=I.concat(x),R=e.map(A=>{const{data:T,programId:C}=A;return{programIdIndex:k.indexOf(C.toString()),accounts:A.keys.map(D=>k.indexOf(D.pubkey.toString())),data:ce.encode(T)}});return R.forEach(A=>{ct(A.programIdIndex>=0),A.accounts.forEach(T=>ct(T>=0))}),new Se({header:{numRequiredSignatures:l,numReadonlySignedAccounts:y,numReadonlyUnsignedAccounts:S},accountKeys:k,recentBlockhash:t,instructions:R})}_compile(){const t=this.compileMessage(),e=t.accountKeys.slice(0,t.header.numRequiredSignatures);return this.signatures.length===e.length&&this.signatures.every((i,s)=>e[s].equals(i.publicKey))||(this.signatures=e.map(r=>({signature:null,publicKey:r}))),t}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(t){return(await t.getFeeForMessage(this.compileMessage())).value}setSigners(...t){if(t.length===0)throw new Error("No signers");const e=new Set;this.signatures=t.filter(r=>{const i=r.toString();return e.has(i)?!1:(e.add(i),!0)}).map(r=>({signature:null,publicKey:r}))}sign(...t){if(t.length===0)throw new Error("No signers");const e=new Set,r=[];for(const s of t){const o=s.publicKey.toString();e.has(o)||(e.add(o),r.push(s))}this.signatures=r.map(s=>({signature:null,publicKey:s.publicKey}));const i=this._compile();this._partialSign(i,...r)}partialSign(...t){if(t.length===0)throw new Error("No signers");const e=new Set,r=[];for(const s of t){const o=s.publicKey.toString();e.has(o)||(e.add(o),r.push(s))}const i=this._compile();this._partialSign(i,...r)}_partialSign(t,...e){const r=t.serialize();e.forEach(i=>{const s=qs(r,i.secretKey);this._addSignature(i.publicKey,it(s))})}addSignature(t,e){this._compile(),this._addSignature(t,e)}_addSignature(t,e){ct(e.length===64);const r=this.signatures.findIndex(i=>t.equals(i.publicKey));if(r<0)throw new Error(`unknown signer: ${t.toString()}`);this.signatures[r].signature=nt.Buffer.from(e)}verifySignatures(t=!0){return!this._getMessageSignednessErrors(this.serializeMessage(),t)}_getMessageSignednessErrors(t,e){const r={};for(const{signature:i,publicKey:s}of this.signatures)i===null?e&&(r.missing||=[]).push(s):If(i,t,s.toBytes())||(r.invalid||=[]).push(s);return r.invalid||r.missing?r:void 0}serialize(t){const{requireAllSignatures:e,verifySignatures:r}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},t),i=this.serializeMessage();if(r){const s=this._getMessageSignednessErrors(i,e);if(s){let o="Signature verification failed.";throw s.invalid&&(o+=`
Invalid signature for public key${s.invalid.length===1?"":"(s)"} [\`${s.invalid.map(h=>h.toBase58()).join("`, `")}\`].`),s.missing&&(o+=`
Missing signature for public key${s.missing.length===1?"":"(s)"} [\`${s.missing.map(h=>h.toBase58()).join("`, `")}\`].`),new Error(o)}}return this._serialize(i)}_serialize(t){const{signatures:e}=this,r=[];we(r,e.length);const i=r.length+e.length*64+t.length,s=nt.Buffer.alloc(i);return ct(e.length<256),nt.Buffer.from(r).copy(s,0),e.forEach(({signature:o},h)=>{o!==null&&(ct(o.length===64,"signature has invalid length"),nt.Buffer.from(o).copy(s,r.length+h*64))}),t.copy(s,r.length+e.length*64),ct(s.length<=$e,`Transaction too large: ${s.length} > ${$e}`),s}get keys(){return ct(this.instructions.length===1),this.instructions[0].keys.map(t=>t.pubkey)}get programId(){return ct(this.instructions.length===1),this.instructions[0].programId}get data(){return ct(this.instructions.length===1),this.instructions[0].data}static from(t){let e=[...t];const r=ye(e);let i=[];for(let s=0;s<r;s++){const o=me(e,0,Pr);i.push(ce.encode(nt.Buffer.from(o)))}return ut.populate(Se.from(e),i)}static populate(t,e=[]){const r=new ut;return r.recentBlockhash=t.recentBlockhash,t.header.numRequiredSignatures>0&&(r.feePayer=t.accountKeys[0]),e.forEach((i,s)=>{const o={signature:i==ce.encode(Nf)?null:ce.decode(i),publicKey:t.accountKeys[s]};r.signatures.push(o)}),t.instructions.forEach(i=>{const s=i.accounts.map(o=>{const h=t.accountKeys[o];return{pubkey:h,isSigner:r.signatures.some(l=>l.publicKey.toString()===h.toString())||t.isAccountSigner(o),isWritable:t.isAccountWritable(o)}});r.instructions.push(new pt({keys:s,programId:t.accountKeys[i.programIdIndex],data:ce.decode(i.data)}))}),r._message=t,r._json=r.toJSON(),r}}class Hs{constructor(t){this.payerKey=void 0,this.instructions=void 0,this.recentBlockhash=void 0,this.payerKey=t.payerKey,this.instructions=t.instructions,this.recentBlockhash=t.recentBlockhash}static decompile(t,e){const{header:r,compiledInstructions:i,recentBlockhash:s}=t,{numRequiredSignatures:o,numReadonlySignedAccounts:h,numReadonlyUnsignedAccounts:l}=r,y=o-h;ct(y>0,"Message header is invalid");const S=t.staticAccountKeys.length-o-l;ct(S>=0,"Message header is invalid");const I=t.getAccountKeys(e),x=I.get(0);if(x===void 0)throw new Error("Failed to decompile message because no account keys were found");const k=[];for(const R of i){const A=[];for(const C of R.accountKeyIndexes){const D=I.get(C);if(D===void 0)throw new Error(`Failed to find key for account key index ${C}`);const U=C<o;let W;U?W=C<y:C<I.staticAccountKeys.length?W=C-o<S:W=C-I.staticAccountKeys.length<I.accountKeysFromLookups.writable.length,A.push({pubkey:D,isSigner:C<r.numRequiredSignatures,isWritable:W})}const T=I.get(R.programIdIndex);if(T===void 0)throw new Error(`Failed to find program id for program id index ${R.programIdIndex}`);k.push(new pt({programId:T,data:it(R.data),keys:A}))}return new Hs({payerKey:x,instructions:k,recentBlockhash:s})}compileToLegacyMessage(){return Se.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions})}compileToV0Message(t){return er.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions,addressLookupTableAccounts:t})}}class $s{get version(){return this.message.version}constructor(t,e){if(this.signatures=void 0,this.message=void 0,e!==void 0)ct(e.length===t.header.numRequiredSignatures,"Expected signatures length to be equal to the number of required signatures"),this.signatures=e;else{const r=[];for(let i=0;i<t.header.numRequiredSignatures;i++)r.push(new Uint8Array(Pr));this.signatures=r}this.message=t}serialize(){const t=this.message.serialize(),e=Array();we(e,this.signatures.length);const r=E.struct([E.blob(e.length,"encodedSignaturesLength"),E.seq(Tf(),this.signatures.length,"signatures"),E.blob(t.length,"serializedMessage")]),i=new Uint8Array(2048),s=r.encode({encodedSignaturesLength:new Uint8Array(e),signatures:this.signatures,serializedMessage:t},i);return i.slice(0,s)}static deserialize(t){let e=[...t];const r=[],i=ye(e);for(let o=0;o<i;o++)r.push(new Uint8Array(me(e,0,Pr)));const s=Vs.deserialize(new Uint8Array(e));return new $s(s,r)}sign(t){const e=this.message.serialize(),r=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures);for(const i of t){const s=r.findIndex(o=>o.equals(i.publicKey));ct(s>=0,`Cannot sign with non signer key ${i.publicKey.toBase58()}`),this.signatures[s]=qs(e,i.secretKey)}}addSignature(t,e){ct(e.byteLength===64,"Signature must be 64 bytes long");const i=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures).findIndex(s=>s.equals(t));ct(i>=0,`Can not add signature; \`${t.toBase58()}\` is not required to sign this transaction`),this.signatures[i]=e}}const Uf=160,zf=64,Kf=Uf/zf,pa=1e3/Kf,_e=new H("SysvarC1ock11111111111111111111111111111111"),qf=new H("SysvarEpochSchedu1e111111111111111111111111"),Df=new H("Sysvar1nstructions1111111111111111111111111"),Xr=new H("SysvarRecentB1ockHashes11111111111111111111"),vr=new H("SysvarRent111111111111111111111111111111111"),Ff=new H("SysvarRewards111111111111111111111111111111"),Wf=new H("SysvarS1otHashes111111111111111111111111111"),Vf=new H("SysvarS1otHistory11111111111111111111111111"),Jr=new H("SysvarStakeHistory1111111111111111111111111");class Cr extends Error{constructor({action:t,signature:e,transactionMessage:r,logs:i}){const s=i?`Logs: 
${JSON.stringify(i.slice(-10),null,2)}. `:"",o="\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.";let h;switch(t){case"send":h=`Transaction ${e} resulted in an error. 
${r}. `+s+o;break;case"simulate":h=`Simulation failed. 
Message: ${r}. 
`+s+o;break;default:h=`Unknown action '${(l=>l)(t)}'`}super(h),this.signature=void 0,this.transactionMessage=void 0,this.transactionLogs=void 0,this.signature=e,this.transactionMessage=r,this.transactionLogs=i||void 0}get transactionError(){return{message:this.transactionMessage,logs:Array.isArray(this.transactionLogs)?this.transactionLogs:void 0}}get logs(){const t=this.transactionLogs;if(!(t!=null&&typeof t=="object"&&"then"in t))return t}async getLogs(t){return Array.isArray(this.transactionLogs)||(this.transactionLogs=new Promise((e,r)=>{t.getTransaction(this.signature).then(i=>{if(i&&i.meta&&i.meta.logMessages){const s=i.meta.logMessages;this.transactionLogs=s,e(s)}else r(new Error("Log messages not found"))}).catch(r)})),await this.transactionLogs}}const Hf={JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP:-32001,JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE:-32002,JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE:-32003,JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE:-32004,JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY:-32005,JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE:-32006,JSON_RPC_SERVER_ERROR_SLOT_SKIPPED:-32007,JSON_RPC_SERVER_ERROR_NO_SNAPSHOT:-32008,JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED:-32009,JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX:-32010,JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE:-32011,JSON_RPC_SCAN_ERROR:-32012,JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH:-32013,JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET:-32014,JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION:-32015,JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED:-32016};class tt extends Error{constructor({code:t,message:e,data:r},i){super(i!=null?`${i}: ${e}`:e),this.code=void 0,this.data=void 0,this.code=t,this.data=r,this.name="SolanaJSONRPCError"}}async function vs(n,t,e,r){const i=r&&{skipPreflight:r.skipPreflight,preflightCommitment:r.preflightCommitment||r.commitment,maxRetries:r.maxRetries,minContextSlot:r.minContextSlot},s=await n.sendTransaction(t,e,i);let o;if(t.recentBlockhash!=null&&t.lastValidBlockHeight!=null)o=(await n.confirmTransaction({abortSignal:r?.abortSignal,signature:s,blockhash:t.recentBlockhash,lastValidBlockHeight:t.lastValidBlockHeight},r&&r.commitment)).value;else if(t.minNonceContextSlot!=null&&t.nonceInfo!=null){const{nonceInstruction:h}=t.nonceInfo,l=h.keys[0].pubkey;o=(await n.confirmTransaction({abortSignal:r?.abortSignal,minContextSlot:t.minNonceContextSlot,nonceAccountPubkey:l,nonceValue:t.nonceInfo.nonce,signature:s},r&&r.commitment)).value}else r?.abortSignal!=null&&console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable."),o=(await n.confirmTransaction(s,r&&r.commitment)).value;if(o.err)throw s!=null?new Cr({action:"send",signature:s,transactionMessage:`Status: (${JSON.stringify(o)})`}):new Error(`Transaction ${s} failed (${JSON.stringify(o)})`);return s}function Ge(n){return new Promise(t=>setTimeout(t,n))}function at(n,t){const e=n.layout.span>=0?n.layout.span:ha(n,t),r=nt.Buffer.alloc(e),i=Object.assign({instruction:n.index},t);return n.layout.encode(i,r),r}function ft(n,t){let e;try{e=n.layout.decode(t)}catch(r){throw new Error("invalid instruction; "+r)}if(e.instruction!==n.index)throw new Error(`invalid instruction; instruction index mismatch ${e.instruction} != ${n.index}`);return e}const ga=E.nu64("lamportsPerSignature"),ya=E.struct([E.u32("version"),E.u32("state"),ot("authorizedPubkey"),ot("nonce"),E.struct([ga],"feeCalculator")]),ks=ya.span;class wn{constructor(t){this.authorizedPubkey=void 0,this.nonce=void 0,this.feeCalculator=void 0,this.authorizedPubkey=t.authorizedPubkey,this.nonce=t.nonce,this.feeCalculator=t.feeCalculator}static fromAccountData(t){const e=ya.decode(it(t),0);return new wn({authorizedPubkey:new H(e.authorizedPubkey),nonce:new H(e.nonce).toString(),feeCalculator:e.feeCalculator})}}function kr(n){const t=E.blob(8,n),e=t.decode.bind(t),r=t.encode.bind(t),i=t,s=wu();return i.decode=(o,h)=>{const l=e(o,h);return s.decode(l)},i.encode=(o,h,l)=>{const y=s.encode(o);return r(y,h,l)},i}class $f{constructor(){}static decodeInstructionType(t){this.checkProgramId(t.programId);const r=E.u32("instruction").decode(t.data);let i;for(const[s,o]of Object.entries(yt))if(o.index==r){i=s;break}if(!i)throw new Error("Instruction type incorrect; not a SystemInstruction");return i}static decodeCreateAccount(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,2);const{lamports:e,space:r,programId:i}=ft(yt.Create,t.data);return{fromPubkey:t.keys[0].pubkey,newAccountPubkey:t.keys[1].pubkey,lamports:e,space:r,programId:new H(i)}}static decodeTransfer(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,2);const{lamports:e}=ft(yt.Transfer,t.data);return{fromPubkey:t.keys[0].pubkey,toPubkey:t.keys[1].pubkey,lamports:e}}static decodeTransferWithSeed(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,3);const{lamports:e,seed:r,programId:i}=ft(yt.TransferWithSeed,t.data);return{fromPubkey:t.keys[0].pubkey,basePubkey:t.keys[1].pubkey,toPubkey:t.keys[2].pubkey,lamports:e,seed:r,programId:new H(i)}}static decodeAllocate(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,1);const{space:e}=ft(yt.Allocate,t.data);return{accountPubkey:t.keys[0].pubkey,space:e}}static decodeAllocateWithSeed(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,1);const{base:e,seed:r,space:i,programId:s}=ft(yt.AllocateWithSeed,t.data);return{accountPubkey:t.keys[0].pubkey,basePubkey:new H(e),seed:r,space:i,programId:new H(s)}}static decodeAssign(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,1);const{programId:e}=ft(yt.Assign,t.data);return{accountPubkey:t.keys[0].pubkey,programId:new H(e)}}static decodeAssignWithSeed(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,1);const{base:e,seed:r,programId:i}=ft(yt.AssignWithSeed,t.data);return{accountPubkey:t.keys[0].pubkey,basePubkey:new H(e),seed:r,programId:new H(i)}}static decodeCreateWithSeed(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,2);const{base:e,seed:r,lamports:i,space:s,programId:o}=ft(yt.CreateWithSeed,t.data);return{fromPubkey:t.keys[0].pubkey,newAccountPubkey:t.keys[1].pubkey,basePubkey:new H(e),seed:r,lamports:i,space:s,programId:new H(o)}}static decodeNonceInitialize(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,3);const{authorized:e}=ft(yt.InitializeNonceAccount,t.data);return{noncePubkey:t.keys[0].pubkey,authorizedPubkey:new H(e)}}static decodeNonceAdvance(t){return this.checkProgramId(t.programId),this.checkKeyLength(t.keys,3),ft(yt.AdvanceNonceAccount,t.data),{noncePubkey:t.keys[0].pubkey,authorizedPubkey:t.keys[2].pubkey}}static decodeNonceWithdraw(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,5);const{lamports:e}=ft(yt.WithdrawNonceAccount,t.data);return{noncePubkey:t.keys[0].pubkey,toPubkey:t.keys[1].pubkey,authorizedPubkey:t.keys[4].pubkey,lamports:e}}static decodeNonceAuthorize(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,2);const{authorized:e}=ft(yt.AuthorizeNonceAccount,t.data);return{noncePubkey:t.keys[0].pubkey,authorizedPubkey:t.keys[1].pubkey,newAuthorizedPubkey:new H(e)}}static checkProgramId(t){if(!t.equals(oe.programId))throw new Error("invalid instruction; programId is not SystemProgram")}static checkKeyLength(t,e){if(t.length<e)throw new Error(`invalid instruction; found ${t.length} keys, expected at least ${e}`)}}const yt=Object.freeze({Create:{index:0,layout:E.struct([E.u32("instruction"),E.ns64("lamports"),E.ns64("space"),ot("programId")])},Assign:{index:1,layout:E.struct([E.u32("instruction"),ot("programId")])},Transfer:{index:2,layout:E.struct([E.u32("instruction"),kr("lamports")])},CreateWithSeed:{index:3,layout:E.struct([E.u32("instruction"),ot("base"),Je("seed"),E.ns64("lamports"),E.ns64("space"),ot("programId")])},AdvanceNonceAccount:{index:4,layout:E.struct([E.u32("instruction")])},WithdrawNonceAccount:{index:5,layout:E.struct([E.u32("instruction"),E.ns64("lamports")])},InitializeNonceAccount:{index:6,layout:E.struct([E.u32("instruction"),ot("authorized")])},AuthorizeNonceAccount:{index:7,layout:E.struct([E.u32("instruction"),ot("authorized")])},Allocate:{index:8,layout:E.struct([E.u32("instruction"),E.ns64("space")])},AllocateWithSeed:{index:9,layout:E.struct([E.u32("instruction"),ot("base"),Je("seed"),E.ns64("space"),ot("programId")])},AssignWithSeed:{index:10,layout:E.struct([E.u32("instruction"),ot("base"),Je("seed"),ot("programId")])},TransferWithSeed:{index:11,layout:E.struct([E.u32("instruction"),kr("lamports"),Je("seed"),ot("programId")])},UpgradeNonceAccount:{index:12,layout:E.struct([E.u32("instruction")])}});class oe{constructor(){}static createAccount(t){const e=yt.Create,r=at(e,{lamports:t.lamports,space:t.space,programId:it(t.programId.toBuffer())});return new pt({keys:[{pubkey:t.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:t.newAccountPubkey,isSigner:!0,isWritable:!0}],programId:this.programId,data:r})}static transfer(t){let e,r;if("basePubkey"in t){const i=yt.TransferWithSeed;e=at(i,{lamports:BigInt(t.lamports),seed:t.seed,programId:it(t.programId.toBuffer())}),r=[{pubkey:t.fromPubkey,isSigner:!1,isWritable:!0},{pubkey:t.basePubkey,isSigner:!0,isWritable:!1},{pubkey:t.toPubkey,isSigner:!1,isWritable:!0}]}else{const i=yt.Transfer;e=at(i,{lamports:BigInt(t.lamports)}),r=[{pubkey:t.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:t.toPubkey,isSigner:!1,isWritable:!0}]}return new pt({keys:r,programId:this.programId,data:e})}static assign(t){let e,r;if("basePubkey"in t){const i=yt.AssignWithSeed;e=at(i,{base:it(t.basePubkey.toBuffer()),seed:t.seed,programId:it(t.programId.toBuffer())}),r=[{pubkey:t.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:t.basePubkey,isSigner:!0,isWritable:!1}]}else{const i=yt.Assign;e=at(i,{programId:it(t.programId.toBuffer())}),r=[{pubkey:t.accountPubkey,isSigner:!0,isWritable:!0}]}return new pt({keys:r,programId:this.programId,data:e})}static createAccountWithSeed(t){const e=yt.CreateWithSeed,r=at(e,{base:it(t.basePubkey.toBuffer()),seed:t.seed,lamports:t.lamports,space:t.space,programId:it(t.programId.toBuffer())});let i=[{pubkey:t.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:t.newAccountPubkey,isSigner:!1,isWritable:!0}];return t.basePubkey.equals(t.fromPubkey)||i.push({pubkey:t.basePubkey,isSigner:!0,isWritable:!1}),new pt({keys:i,programId:this.programId,data:r})}static createNonceAccount(t){const e=new ut;"basePubkey"in t&&"seed"in t?e.add(oe.createAccountWithSeed({fromPubkey:t.fromPubkey,newAccountPubkey:t.noncePubkey,basePubkey:t.basePubkey,seed:t.seed,lamports:t.lamports,space:ks,programId:this.programId})):e.add(oe.createAccount({fromPubkey:t.fromPubkey,newAccountPubkey:t.noncePubkey,lamports:t.lamports,space:ks,programId:this.programId}));const r={noncePubkey:t.noncePubkey,authorizedPubkey:t.authorizedPubkey};return e.add(this.nonceInitialize(r)),e}static nonceInitialize(t){const e=yt.InitializeNonceAccount,r=at(e,{authorized:it(t.authorizedPubkey.toBuffer())}),i={keys:[{pubkey:t.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:Xr,isSigner:!1,isWritable:!1},{pubkey:vr,isSigner:!1,isWritable:!1}],programId:this.programId,data:r};return new pt(i)}static nonceAdvance(t){const e=yt.AdvanceNonceAccount,r=at(e),i={keys:[{pubkey:t.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:Xr,isSigner:!1,isWritable:!1},{pubkey:t.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:r};return new pt(i)}static nonceWithdraw(t){const e=yt.WithdrawNonceAccount,r=at(e,{lamports:t.lamports});return new pt({keys:[{pubkey:t.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:t.toPubkey,isSigner:!1,isWritable:!0},{pubkey:Xr,isSigner:!1,isWritable:!1},{pubkey:vr,isSigner:!1,isWritable:!1},{pubkey:t.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:r})}static nonceAuthorize(t){const e=yt.AuthorizeNonceAccount,r=at(e,{authorized:it(t.newAuthorizedPubkey.toBuffer())});return new pt({keys:[{pubkey:t.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:t.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:r})}static allocate(t){let e,r;if("basePubkey"in t){const i=yt.AllocateWithSeed;e=at(i,{base:it(t.basePubkey.toBuffer()),seed:t.seed,space:t.space,programId:it(t.programId.toBuffer())}),r=[{pubkey:t.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:t.basePubkey,isSigner:!0,isWritable:!1}]}else{const i=yt.Allocate;e=at(i,{space:t.space}),r=[{pubkey:t.accountPubkey,isSigner:!0,isWritable:!0}]}return new pt({keys:r,programId:this.programId,data:e})}}oe.programId=new H("11111111111111111111111111111111");const jf=$e-300;class rr{constructor(){}static getMinNumSignatures(t){return 2*(Math.ceil(t/rr.chunkSize)+1+1)}static async load(t,e,r,i,s){{const I=await t.getMinimumBalanceForRentExemption(s.length),x=await t.getAccountInfo(r.publicKey,"confirmed");let k=null;if(x!==null){if(x.executable)return console.error("Program load failed, account is already executable"),!1;x.data.length!==s.length&&(k=k||new ut,k.add(oe.allocate({accountPubkey:r.publicKey,space:s.length}))),x.owner.equals(i)||(k=k||new ut,k.add(oe.assign({accountPubkey:r.publicKey,programId:i}))),x.lamports<I&&(k=k||new ut,k.add(oe.transfer({fromPubkey:e.publicKey,toPubkey:r.publicKey,lamports:I-x.lamports})))}else k=new ut().add(oe.createAccount({fromPubkey:e.publicKey,newAccountPubkey:r.publicKey,lamports:I>0?I:1,space:s.length,programId:i}));k!==null&&await vs(t,k,[e,r],{commitment:"confirmed"})}const o=E.struct([E.u32("instruction"),E.u32("offset"),E.u32("bytesLength"),E.u32("bytesLengthPadding"),E.seq(E.u8("byte"),E.offset(E.u32(),-8),"bytes")]),h=rr.chunkSize;let l=0,y=s,S=[];for(;y.length>0;){const I=y.slice(0,h),x=nt.Buffer.alloc(h+16);o.encode({instruction:0,offset:l,bytes:I,bytesLength:0,bytesLengthPadding:0},x);const k=new ut().add({keys:[{pubkey:r.publicKey,isSigner:!0,isWritable:!0}],programId:i,data:x});S.push(vs(t,k,[e,r],{commitment:"confirmed"})),t._rpcEndpoint.includes("solana.com")&&await Ge(1e3/4),l+=h,y=y.slice(h)}await Promise.all(S);{const I=E.struct([E.u32("instruction")]),x=nt.Buffer.alloc(I.span);I.encode({instruction:1},x);const k=new ut().add({keys:[{pubkey:r.publicKey,isSigner:!0,isWritable:!0},{pubkey:vr,isSigner:!1,isWritable:!1}],programId:i,data:x}),R="processed",A=await t.sendTransaction(k,[e,r],{preflightCommitment:R}),{context:T,value:C}=await t.confirmTransaction({signature:A,lastValidBlockHeight:k.lastValidBlockHeight,blockhash:k.recentBlockhash},R);if(C.err)throw new Error(`Transaction ${A} failed (${JSON.stringify(C)})`);for(;;){try{if(await t.getSlot({commitment:R})>T.slot)break}catch{}await new Promise(D=>setTimeout(D,Math.round(pa/2)))}}return!0}}rr.chunkSize=jf;const Gf=new H("BPFLoader2111111111111111111111111111111111");class Zf{static getMinNumSignatures(t){return rr.getMinNumSignatures(t)}static load(t,e,r,i,s){return rr.load(t,e,r,s,i)}}function Yf(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}var fs,Xi;function Xf(){if(Xi)return fs;Xi=1;var n=Object.prototype.toString,t=Object.keys||function(r){var i=[];for(var s in r)i.push(s);return i};function e(r,i){var s,o,h,l,y,S,I;if(r===!0)return"true";if(r===!1)return"false";switch(typeof r){case"object":if(r===null)return null;if(r.toJSON&&typeof r.toJSON=="function")return e(r.toJSON(),i);if(I=n.call(r),I==="[object Array]"){for(h="[",o=r.length-1,s=0;s<o;s++)h+=e(r[s],!0)+",";return o>-1&&(h+=e(r[s],!0)),h+"]"}else if(I==="[object Object]"){for(l=t(r).sort(),o=l.length,h="",s=0;s<o;)y=l[s],S=e(r[y],!1),S!==void 0&&(h&&(h+=","),h+=JSON.stringify(y)+":"+S),s++;return"{"+h+"}"}else return JSON.stringify(r);case"function":case"undefined":return i?null:void 0;case"string":return JSON.stringify(r);default:return isFinite(r)?r:null}}return fs=function(r){var i=e(r,!1);if(i!==void 0)return""+i},fs}var Jf=Xf(),Ji=Yf(Jf);const Br=32;function ls(n){let t=0;for(;n>1;)n/=2,t++;return t}function Qf(n){return n===0?1:(n--,n|=n>>1,n|=n>>2,n|=n>>4,n|=n>>8,n|=n>>16,n|=n>>32,n+1)}class ma{constructor(t,e,r,i,s){this.slotsPerEpoch=void 0,this.leaderScheduleSlotOffset=void 0,this.warmup=void 0,this.firstNormalEpoch=void 0,this.firstNormalSlot=void 0,this.slotsPerEpoch=t,this.leaderScheduleSlotOffset=e,this.warmup=r,this.firstNormalEpoch=i,this.firstNormalSlot=s}getEpoch(t){return this.getEpochAndSlotIndex(t)[0]}getEpochAndSlotIndex(t){if(t<this.firstNormalSlot){const e=ls(Qf(t+Br+1))-ls(Br)-1,r=this.getSlotsInEpoch(e),i=t-(r-Br);return[e,i]}else{const e=t-this.firstNormalSlot,r=Math.floor(e/this.slotsPerEpoch),i=this.firstNormalEpoch+r,s=e%this.slotsPerEpoch;return[i,s]}}getFirstSlotInEpoch(t){return t<=this.firstNormalEpoch?(Math.pow(2,t)-1)*Br:(t-this.firstNormalEpoch)*this.slotsPerEpoch+this.firstNormalSlot}getLastSlotInEpoch(t){return this.getFirstSlotInEpoch(t)+this.getSlotsInEpoch(t)-1}getSlotsInEpoch(t){return t<this.firstNormalEpoch?Math.pow(2,t+ls(Br)):this.slotsPerEpoch}}var tl=globalThis.fetch;class el extends ef{constructor(t,e,r){const i=s=>{const o=Qu(s,{autoconnect:!0,max_reconnects:5,reconnect:!0,reconnect_interval:1e3,...e});return"socket"in o?this.underlyingSocket=o.socket:this.underlyingSocket=o,o};super(i,t,e,r),this.underlyingSocket=void 0}call(...t){const e=this.underlyingSocket?.readyState;return e===1?super.call(...t):Promise.reject(new Error("Tried to call a JSON-RPC method `"+t[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+e+")"))}notify(...t){const e=this.underlyingSocket?.readyState;return e===1?super.notify(...t):Promise.reject(new Error("Tried to send a JSON-RPC notification `"+t[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+e+")"))}}function rl(n,t){let e;try{e=n.layout.decode(t)}catch(r){throw new Error("invalid instruction; "+r)}if(e.typeIndex!==n.index)throw new Error(`invalid account data; account type mismatch ${e.typeIndex} != ${n.index}`);return e}const Qi=56;class Ss{constructor(t){this.key=void 0,this.state=void 0,this.key=t.key,this.state=t.state}isActive(){const t=BigInt("0xffffffffffffffff");return this.state.deactivationSlot===t}static deserialize(t){const e=rl(nl,t),r=t.length-Qi;ct(r>=0,"lookup table is invalid"),ct(r%32===0,"lookup table is invalid");const i=r/32,{addresses:s}=E.struct([E.seq(ot(),i,"addresses")]).decode(t.slice(Qi));return{deactivationSlot:e.deactivationSlot,lastExtendedSlot:e.lastExtendedSlot,lastExtendedSlotStartIndex:e.lastExtendedStartIndex,authority:e.authority.length!==0?new H(e.authority[0]):void 0,addresses:s.map(o=>new H(o))}}}const nl={index:1,layout:E.struct([E.u32("typeIndex"),kr("deactivationSlot"),E.nu64("lastExtendedSlot"),E.u8("lastExtendedStartIndex"),E.u8(),E.seq(ot(),E.offset(E.u8(),-1),"authority")])},sl=/^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;function il(n){const t=n.match(sl);if(t==null)throw TypeError(`Failed to validate endpoint URL \`${n}\``);const[e,r,i,s]=t,o=n.startsWith("https:")?"wss:":"ws:",h=i==null?null:parseInt(i.slice(1),10),l=h==null?"":`:${h+1}`;return`${o}//${r}${l}${s}`}const wt=Dr(Os(H),V(),n=>new H(n)),ba=Ns([V(),bt("base64")]),js=Dr(Os(nt.Buffer),ba,n=>nt.Buffer.from(n[0],"base64")),wa=30*1e3;function ol(n){if(/^https?:/.test(n)===!1)throw new TypeError("Endpoint URL must start with `http:` or `https:`.");return n}function gt(n){let t,e;if(typeof n=="string")t=n;else if(n){const{commitment:r,...i}=n;t=r,e=i}return{commitment:t,config:e}}function to(n){return n.map(t=>"memcmp"in t?{...t,memcmp:{...t.memcmp,encoding:t.memcmp.encoding??"base58"}}:t)}function va(n){return ge([F({jsonrpc:bt("2.0"),id:V(),result:n}),F({jsonrpc:bt("2.0"),id:V(),error:F({code:xr(),message:V(),data:et(Eu())})})])}const al=va(xr());function st(n){return Dr(va(n),al,t=>"error"in t?t:{...t,result:j(t.result,n)})}function St(n){return st(F({context:F({slot:O()}),value:n}))}function vn(n){return F({context:F({slot:O()}),value:n})}function hs(n,t){return n===0?new er({header:t.header,staticAccountKeys:t.accountKeys.map(e=>new H(e)),recentBlockhash:t.recentBlockhash,compiledInstructions:t.instructions.map(e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:ce.decode(e.data)})),addressTableLookups:t.addressTableLookups}):new Se(t)}const cl=F({foundation:O(),foundationTerm:O(),initial:O(),taper:O(),terminal:O()}),ul=st(Z(Y(F({epoch:O(),effectiveSlot:O(),amount:O(),postBalance:O(),commission:et(Y(O()))})))),fl=Z(F({slot:O(),prioritizationFee:O()})),ll=F({total:O(),validator:O(),foundation:O(),epoch:O()}),hl=F({epoch:O(),slotIndex:O(),slotsInEpoch:O(),absoluteSlot:O(),blockHeight:et(O()),transactionCount:et(O())}),dl=F({slotsPerEpoch:O(),leaderScheduleSlotOffset:O(),warmup:Me(),firstNormalEpoch:O(),firstNormalSlot:O()}),pl=Go(V(),Z(O())),ir=Y(ge([F({}),V()])),gl=F({err:ir}),yl=bt("receivedSignature"),ml=F({"solana-core":V(),"feature-set":et(O())}),bl=F({program:V(),programId:wt,parsed:xr()}),wl=F({programId:wt,accounts:Z(wt),data:V()}),eo=St(F({err:Y(ge([F({}),V()])),logs:Y(Z(V())),accounts:et(Y(Z(Y(F({executable:Me(),owner:V(),lamports:O(),data:Z(V()),rentEpoch:et(O())}))))),unitsConsumed:et(O()),returnData:et(Y(F({programId:V(),data:Ns([V(),bt("base64")])}))),innerInstructions:et(Y(Z(F({index:O(),instructions:Z(ge([bl,wl]))}))))})),vl=St(F({byIdentity:Go(V(),Z(O())),range:F({firstSlot:O(),lastSlot:O()})}));function kl(n,t,e,r,i,s){const o=e||tl;let h;s!=null&&console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");let l;return r&&(l=async(S,I)=>{const x=await new Promise((k,R)=>{try{r(S,I,(A,T)=>k([A,T]))}catch(A){R(A)}});return await o(...x)}),new Zu(async(S,I)=>{const x={method:"POST",body:S,agent:h,headers:Object.assign({"Content-Type":"application/json"},t||{},kh)};try{let k=5,R,A=500;for(;l?R=await l(n,x):R=await o(n,x),!(R.status!==429||i===!0||(k-=1,k===0));)console.error(`Server responded with ${R.status} ${R.statusText}.  Retrying after ${A}ms delay...`),await Ge(A),A*=2;const T=await R.text();R.ok?I(null,T):I(new Error(`${R.status} ${R.statusText}: ${T}`))}catch(k){k instanceof Error&&I(k)}},{})}function Sl(n){return(t,e)=>new Promise((r,i)=>{n.request(t,e,(s,o)=>{if(s){i(s);return}r(o)})})}function xl(n){return t=>new Promise((e,r)=>{t.length===0&&e([]);const i=t.map(s=>n.request(s.methodName,s.args));n.request(i,(s,o)=>{if(s){r(s);return}e(o)})})}const _l=st(cl),El=st(ll),Il=st(fl),Al=st(hl),Bl=st(dl),Rl=st(pl),Ml=st(O()),Tl=St(F({total:O(),circulating:O(),nonCirculating:O(),nonCirculatingAccounts:Z(wt)})),xs=F({amount:V(),uiAmount:Y(O()),decimals:O(),uiAmountString:et(V())}),Pl=St(Z(F({address:wt,amount:V(),uiAmount:Y(O()),decimals:O(),uiAmountString:et(V())}))),Ll=St(Z(F({pubkey:wt,account:F({executable:Me(),owner:wt,lamports:O(),data:js,rentEpoch:O()})}))),_s=F({program:V(),parsed:xr(),space:O()}),Cl=St(Z(F({pubkey:wt,account:F({executable:Me(),owner:wt,lamports:O(),data:_s,rentEpoch:O()})}))),Ol=St(Z(F({lamports:O(),address:wt}))),Or=F({executable:Me(),owner:wt,lamports:O(),data:js,rentEpoch:O()}),Nl=F({pubkey:wt,account:Or}),Ul=Dr(ge([Os(nt.Buffer),_s]),ge([ba,_s]),n=>Array.isArray(n)?j(n,js):n),Es=F({executable:Me(),owner:wt,lamports:O(),data:Ul,rentEpoch:O()}),zl=F({pubkey:wt,account:Es}),Kl=F({state:ge([bt("active"),bt("inactive"),bt("activating"),bt("deactivating")]),active:O(),inactive:O()}),ql=st(Z(F({signature:V(),slot:O(),err:ir,memo:Y(V()),blockTime:et(Y(O()))}))),Dl=st(Z(F({signature:V(),slot:O(),err:ir,memo:Y(V()),blockTime:et(Y(O()))}))),Fl=F({subscription:O(),result:vn(Or)}),Wl=F({pubkey:wt,account:Or}),Vl=F({subscription:O(),result:vn(Wl)}),Hl=F({parent:O(),slot:O(),root:O()}),$l=F({subscription:O(),result:Hl}),jl=ge([F({type:ge([bt("firstShredReceived"),bt("completed"),bt("optimisticConfirmation"),bt("root")]),slot:O(),timestamp:O()}),F({type:bt("createdBank"),parent:O(),slot:O(),timestamp:O()}),F({type:bt("frozen"),slot:O(),timestamp:O(),stats:F({numTransactionEntries:O(),numSuccessfulTransactions:O(),numFailedTransactions:O(),maxTransactionsPerEntry:O()})}),F({type:bt("dead"),slot:O(),timestamp:O(),err:V()})]),Gl=F({subscription:O(),result:jl}),Zl=F({subscription:O(),result:vn(ge([gl,yl]))}),Yl=F({subscription:O(),result:O()}),Xl=F({pubkey:V(),gossip:Y(V()),tpu:Y(V()),rpc:Y(V()),version:Y(V())}),ro=F({votePubkey:V(),nodePubkey:V(),activatedStake:O(),epochVoteAccount:Me(),epochCredits:Z(Ns([O(),O(),O()])),commission:O(),lastVote:O(),rootSlot:Y(O())}),Jl=st(F({current:Z(ro),delinquent:Z(ro)})),Ql=ge([bt("processed"),bt("confirmed"),bt("finalized")]),th=F({slot:O(),confirmations:Y(O()),err:ir,confirmationStatus:et(Ql)}),eh=St(Z(Y(th))),rh=st(O()),ka=F({accountKey:wt,writableIndexes:Z(O()),readonlyIndexes:Z(O())}),Gs=F({signatures:Z(V()),message:F({accountKeys:Z(V()),header:F({numRequiredSignatures:O(),numReadonlySignedAccounts:O(),numReadonlyUnsignedAccounts:O()}),instructions:Z(F({accounts:Z(O()),data:V(),programIdIndex:O()})),recentBlockhash:V(),addressTableLookups:et(Z(ka))})}),Sa=F({pubkey:wt,signer:Me(),writable:Me(),source:et(ge([bt("transaction"),bt("lookupTable")]))}),xa=F({accountKeys:Z(Sa),signatures:Z(V())}),_a=F({parsed:xr(),program:V(),programId:wt}),Ea=F({accounts:Z(wt),data:V(),programId:wt}),nh=ge([Ea,_a]),sh=ge([F({parsed:xr(),program:V(),programId:V()}),F({accounts:Z(V()),data:V(),programId:V()})]),Ia=Dr(nh,sh,n=>"accounts"in n?j(n,Ea):j(n,_a)),Aa=F({signatures:Z(V()),message:F({accountKeys:Z(Sa),instructions:Z(Ia),recentBlockhash:V(),addressTableLookups:et(Y(Z(ka)))})}),un=F({accountIndex:O(),mint:V(),owner:et(V()),programId:et(V()),uiTokenAmount:xs}),Ba=F({writable:Z(wt),readonly:Z(wt)}),kn=F({err:ir,fee:O(),innerInstructions:et(Y(Z(F({index:O(),instructions:Z(F({accounts:Z(O()),data:V(),programIdIndex:O()}))})))),preBalances:Z(O()),postBalances:Z(O()),logMessages:et(Y(Z(V()))),preTokenBalances:et(Y(Z(un))),postTokenBalances:et(Y(Z(un))),loadedAddresses:et(Ba),computeUnitsConsumed:et(O()),costUnits:et(O())}),Zs=F({err:ir,fee:O(),innerInstructions:et(Y(Z(F({index:O(),instructions:Z(Ia)})))),preBalances:Z(O()),postBalances:Z(O()),logMessages:et(Y(Z(V()))),preTokenBalances:et(Y(Z(un))),postTokenBalances:et(Y(Z(un))),loadedAddresses:et(Ba),computeUnitsConsumed:et(O()),costUnits:et(O())}),_r=ge([bt(0),bt("legacy")]),or=F({pubkey:V(),lamports:O(),postBalance:Y(O()),rewardType:Y(V()),commission:et(Y(O()))}),ih=st(Y(F({blockhash:V(),previousBlockhash:V(),parentSlot:O(),transactions:Z(F({transaction:Gs,meta:Y(kn),version:et(_r)})),rewards:et(Z(or)),blockTime:Y(O()),blockHeight:Y(O())}))),oh=st(Y(F({blockhash:V(),previousBlockhash:V(),parentSlot:O(),rewards:et(Z(or)),blockTime:Y(O()),blockHeight:Y(O())}))),ah=st(Y(F({blockhash:V(),previousBlockhash:V(),parentSlot:O(),transactions:Z(F({transaction:xa,meta:Y(kn),version:et(_r)})),rewards:et(Z(or)),blockTime:Y(O()),blockHeight:Y(O())}))),ch=st(Y(F({blockhash:V(),previousBlockhash:V(),parentSlot:O(),transactions:Z(F({transaction:Aa,meta:Y(Zs),version:et(_r)})),rewards:et(Z(or)),blockTime:Y(O()),blockHeight:Y(O())}))),uh=st(Y(F({blockhash:V(),previousBlockhash:V(),parentSlot:O(),transactions:Z(F({transaction:xa,meta:Y(Zs),version:et(_r)})),rewards:et(Z(or)),blockTime:Y(O()),blockHeight:Y(O())}))),fh=st(Y(F({blockhash:V(),previousBlockhash:V(),parentSlot:O(),rewards:et(Z(or)),blockTime:Y(O()),blockHeight:Y(O())}))),lh=st(Y(F({blockhash:V(),previousBlockhash:V(),parentSlot:O(),transactions:Z(F({transaction:Gs,meta:Y(kn)})),rewards:et(Z(or)),blockTime:Y(O())}))),no=st(Y(F({blockhash:V(),previousBlockhash:V(),parentSlot:O(),signatures:Z(V()),blockTime:Y(O())}))),ds=st(Y(F({slot:O(),meta:Y(kn),blockTime:et(Y(O())),transaction:Gs,version:et(_r)}))),Zr=st(Y(F({slot:O(),transaction:Aa,meta:Y(Zs),blockTime:et(Y(O())),version:et(_r)}))),hh=St(F({blockhash:V(),lastValidBlockHeight:O()})),dh=St(Me()),ph=F({slot:O(),numTransactions:O(),numSlots:O(),samplePeriodSecs:O()}),gh=st(Z(ph)),yh=St(Y(F({feeCalculator:F({lamportsPerSignature:O()})}))),mh=st(V()),bh=st(V()),wh=F({err:ir,logs:Z(V()),signature:V()}),vh=F({result:vn(wh),subscription:O()}),kh={"solana-client":"js/1.0.0-maintenance"};class Sh{constructor(t,e){this._commitment=void 0,this._confirmTransactionInitialTimeout=void 0,this._rpcEndpoint=void 0,this._rpcWsEndpoint=void 0,this._rpcClient=void 0,this._rpcRequest=void 0,this._rpcBatchRequest=void 0,this._rpcWebSocket=void 0,this._rpcWebSocketConnected=!1,this._rpcWebSocketHeartbeat=null,this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketGeneration=0,this._disableBlockhashCaching=!1,this._pollingBlockhash=!1,this._blockhashInfo={latestBlockhash:null,lastFetch:0,transactionSignatures:[],simulatedSignatures:[]},this._nextClientSubscriptionId=0,this._subscriptionDisposeFunctionsByClientSubscriptionId={},this._subscriptionHashByClientSubscriptionId={},this._subscriptionStateChangeCallbacksByHash={},this._subscriptionCallbacksByServerSubscriptionId={},this._subscriptionsByHash={},this._subscriptionsAutoDisposedByRpc=new Set,this.getBlockHeight=(()=>{const y={};return async S=>{const{commitment:I,config:x}=gt(S),k=this._buildArgs([],I,void 0,x),R=Ji(k);return y[R]=y[R]??(async()=>{try{const A=await this._rpcRequest("getBlockHeight",k),T=j(A,st(O()));if("error"in T)throw new tt(T.error,"failed to get block height information");return T.result}finally{delete y[R]}})(),await y[R]}})();let r,i,s,o,h,l;e&&typeof e=="string"?this._commitment=e:e&&(this._commitment=e.commitment,this._confirmTransactionInitialTimeout=e.confirmTransactionInitialTimeout,r=e.wsEndpoint,i=e.httpHeaders,s=e.fetch,o=e.fetchMiddleware,h=e.disableRetryOnRateLimit,l=e.httpAgent),this._rpcEndpoint=ol(t),this._rpcWsEndpoint=r||il(t),this._rpcClient=kl(t,i,s,o,h,l),this._rpcRequest=Sl(this._rpcClient),this._rpcBatchRequest=xl(this._rpcClient),this._rpcWebSocket=new el(this._rpcWsEndpoint,{autoconnect:!1,max_reconnects:1/0}),this._rpcWebSocket.on("open",this._wsOnOpen.bind(this)),this._rpcWebSocket.on("error",this._wsOnError.bind(this)),this._rpcWebSocket.on("close",this._wsOnClose.bind(this)),this._rpcWebSocket.on("accountNotification",this._wsOnAccountNotification.bind(this)),this._rpcWebSocket.on("programNotification",this._wsOnProgramAccountNotification.bind(this)),this._rpcWebSocket.on("slotNotification",this._wsOnSlotNotification.bind(this)),this._rpcWebSocket.on("slotsUpdatesNotification",this._wsOnSlotUpdatesNotification.bind(this)),this._rpcWebSocket.on("signatureNotification",this._wsOnSignatureNotification.bind(this)),this._rpcWebSocket.on("rootNotification",this._wsOnRootNotification.bind(this)),this._rpcWebSocket.on("logsNotification",this._wsOnLogsNotification.bind(this))}get commitment(){return this._commitment}get rpcEndpoint(){return this._rpcEndpoint}async getBalanceAndContext(t,e){const{commitment:r,config:i}=gt(e),s=this._buildArgs([t.toBase58()],r,void 0,i),o=await this._rpcRequest("getBalance",s),h=j(o,St(O()));if("error"in h)throw new tt(h.error,`failed to get balance for ${t.toBase58()}`);return h.result}async getBalance(t,e){return await this.getBalanceAndContext(t,e).then(r=>r.value).catch(r=>{throw new Error("failed to get balance of account "+t.toBase58()+": "+r)})}async getBlockTime(t){const e=await this._rpcRequest("getBlockTime",[t]),r=j(e,st(Y(O())));if("error"in r)throw new tt(r.error,`failed to get block time for slot ${t}`);return r.result}async getMinimumLedgerSlot(){const t=await this._rpcRequest("minimumLedgerSlot",[]),e=j(t,st(O()));if("error"in e)throw new tt(e.error,"failed to get minimum ledger slot");return e.result}async getFirstAvailableBlock(){const t=await this._rpcRequest("getFirstAvailableBlock",[]),e=j(t,Ml);if("error"in e)throw new tt(e.error,"failed to get first available block");return e.result}async getSupply(t){let e={};typeof t=="string"?e={commitment:t}:t?e={...t,commitment:t&&t.commitment||this.commitment}:e={commitment:this.commitment};const r=await this._rpcRequest("getSupply",[e]),i=j(r,Tl);if("error"in i)throw new tt(i.error,"failed to get supply");return i.result}async getTokenSupply(t,e){const r=this._buildArgs([t.toBase58()],e),i=await this._rpcRequest("getTokenSupply",r),s=j(i,St(xs));if("error"in s)throw new tt(s.error,"failed to get token supply");return s.result}async getTokenAccountBalance(t,e){const r=this._buildArgs([t.toBase58()],e),i=await this._rpcRequest("getTokenAccountBalance",r),s=j(i,St(xs));if("error"in s)throw new tt(s.error,"failed to get token account balance");return s.result}async getTokenAccountsByOwner(t,e,r){const{commitment:i,config:s}=gt(r);let o=[t.toBase58()];"mint"in e?o.push({mint:e.mint.toBase58()}):o.push({programId:e.programId.toBase58()});const h=this._buildArgs(o,i,"base64",s),l=await this._rpcRequest("getTokenAccountsByOwner",h),y=j(l,Ll);if("error"in y)throw new tt(y.error,`failed to get token accounts owned by account ${t.toBase58()}`);return y.result}async getParsedTokenAccountsByOwner(t,e,r){let i=[t.toBase58()];"mint"in e?i.push({mint:e.mint.toBase58()}):i.push({programId:e.programId.toBase58()});const s=this._buildArgs(i,r,"jsonParsed"),o=await this._rpcRequest("getTokenAccountsByOwner",s),h=j(o,Cl);if("error"in h)throw new tt(h.error,`failed to get token accounts owned by account ${t.toBase58()}`);return h.result}async getLargestAccounts(t){const e={...t,commitment:t&&t.commitment||this.commitment},r=e.filter||e.commitment?[e]:[],i=await this._rpcRequest("getLargestAccounts",r),s=j(i,Ol);if("error"in s)throw new tt(s.error,"failed to get largest accounts");return s.result}async getTokenLargestAccounts(t,e){const r=this._buildArgs([t.toBase58()],e),i=await this._rpcRequest("getTokenLargestAccounts",r),s=j(i,Pl);if("error"in s)throw new tt(s.error,"failed to get token largest accounts");return s.result}async getAccountInfoAndContext(t,e){const{commitment:r,config:i}=gt(e),s=this._buildArgs([t.toBase58()],r,"base64",i),o=await this._rpcRequest("getAccountInfo",s),h=j(o,St(Y(Or)));if("error"in h)throw new tt(h.error,`failed to get info about account ${t.toBase58()}`);return h.result}async getParsedAccountInfo(t,e){const{commitment:r,config:i}=gt(e),s=this._buildArgs([t.toBase58()],r,"jsonParsed",i),o=await this._rpcRequest("getAccountInfo",s),h=j(o,St(Y(Es)));if("error"in h)throw new tt(h.error,`failed to get info about account ${t.toBase58()}`);return h.result}async getAccountInfo(t,e){try{return(await this.getAccountInfoAndContext(t,e)).value}catch(r){throw new Error("failed to get info about account "+t.toBase58()+": "+r)}}async getMultipleParsedAccounts(t,e){const{commitment:r,config:i}=gt(e),s=t.map(y=>y.toBase58()),o=this._buildArgs([s],r,"jsonParsed",i),h=await this._rpcRequest("getMultipleAccounts",o),l=j(h,St(Z(Y(Es))));if("error"in l)throw new tt(l.error,`failed to get info for accounts ${s}`);return l.result}async getMultipleAccountsInfoAndContext(t,e){const{commitment:r,config:i}=gt(e),s=t.map(y=>y.toBase58()),o=this._buildArgs([s],r,"base64",i),h=await this._rpcRequest("getMultipleAccounts",o),l=j(h,St(Z(Y(Or))));if("error"in l)throw new tt(l.error,`failed to get info for accounts ${s}`);return l.result}async getMultipleAccountsInfo(t,e){return(await this.getMultipleAccountsInfoAndContext(t,e)).value}async getStakeActivation(t,e,r){const{commitment:i,config:s}=gt(e),o=this._buildArgs([t.toBase58()],i,void 0,{...s,epoch:r??s?.epoch}),h=await this._rpcRequest("getStakeActivation",o),l=j(h,st(Kl));if("error"in l)throw new tt(l.error,`failed to get Stake Activation ${t.toBase58()}`);return l.result}async getProgramAccounts(t,e){const{commitment:r,config:i}=gt(e),{encoding:s,...o}=i||{},h=this._buildArgs([t.toBase58()],r,s||"base64",{...o,...o.filters?{filters:to(o.filters)}:null}),l=await this._rpcRequest("getProgramAccounts",h),y=Z(Nl),S=o.withContext===!0?j(l,St(y)):j(l,st(y));if("error"in S)throw new tt(S.error,`failed to get accounts owned by program ${t.toBase58()}`);return S.result}async getParsedProgramAccounts(t,e){const{commitment:r,config:i}=gt(e),s=this._buildArgs([t.toBase58()],r,"jsonParsed",i),o=await this._rpcRequest("getProgramAccounts",s),h=j(o,st(Z(zl)));if("error"in h)throw new tt(h.error,`failed to get accounts owned by program ${t.toBase58()}`);return h.result}async confirmTransaction(t,e){let r;if(typeof t=="string")r=t;else{const s=t;if(s.abortSignal?.aborted)return Promise.reject(s.abortSignal.reason);r=s.signature}let i;try{i=ce.decode(r)}catch{throw new Error("signature must be base58 encoded: "+r)}return ct(i.length===64,"signature has invalid length"),typeof t=="string"?await this.confirmTransactionUsingLegacyTimeoutStrategy({commitment:e||this.commitment,signature:r}):"lastValidBlockHeight"in t?await this.confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:e||this.commitment,strategy:t}):await this.confirmTransactionUsingDurableNonceStrategy({commitment:e||this.commitment,strategy:t})}getCancellationPromise(t){return new Promise((e,r)=>{t!=null&&(t.aborted?r(t.reason):t.addEventListener("abort",()=>{r(t.reason)}))})}getTransactionConfirmationPromise({commitment:t,signature:e}){let r,i,s=!1;const o=new Promise((l,y)=>{try{r=this.onSignature(e,(I,x)=>{r=void 0;const k={context:x,value:I};l({__type:Ce.PROCESSED,response:k})},t);const S=new Promise(I=>{r==null?I():i=this._onSubscriptionStateChange(r,x=>{x==="subscribed"&&I()})});(async()=>{if(await S,s)return;const I=await this.getSignatureStatus(e);if(s||I==null)return;const{context:x,value:k}=I;if(k!=null)if(k?.err)y(k.err);else{switch(t){case"confirmed":case"single":case"singleGossip":{if(k.confirmationStatus==="processed")return;break}case"finalized":case"max":case"root":{if(k.confirmationStatus==="processed"||k.confirmationStatus==="confirmed")return;break}case"processed":case"recent":}s=!0,l({__type:Ce.PROCESSED,response:{context:x,value:k}})}})()}catch(S){y(S)}});return{abortConfirmation:()=>{i&&(i(),i=void 0),r!=null&&(this.removeSignatureListener(r),r=void 0)},confirmationPromise:o}}async confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:t,strategy:{abortSignal:e,lastValidBlockHeight:r,signature:i}}){let s=!1;const o=new Promise(I=>{const x=async()=>{try{return await this.getBlockHeight(t)}catch{return-1}};(async()=>{let k=await x();if(!s){for(;k<=r;)if(await Ge(1e3),s||(k=await x(),s))return;I({__type:Ce.BLOCKHEIGHT_EXCEEDED})}})()}),{abortConfirmation:h,confirmationPromise:l}=this.getTransactionConfirmationPromise({commitment:t,signature:i}),y=this.getCancellationPromise(e);let S;try{const I=await Promise.race([y,l,o]);if(I.__type===Ce.PROCESSED)S=I.response;else throw new Fs(i)}finally{s=!0,h()}return S}async confirmTransactionUsingDurableNonceStrategy({commitment:t,strategy:{abortSignal:e,minContextSlot:r,nonceAccountPubkey:i,nonceValue:s,signature:o}}){let h=!1;const l=new Promise(k=>{let R=s,A=null;const T=async()=>{try{const{context:C,value:D}=await this.getNonceAndContext(i,{commitment:t,minContextSlot:r});return A=C.slot,D?.nonce}catch{return R}};(async()=>{if(R=await T(),!h)for(;;){if(s!==R){k({__type:Ce.NONCE_INVALID,slotInWhichNonceDidAdvance:A});return}if(await Ge(2e3),h||(R=await T(),h))return}})()}),{abortConfirmation:y,confirmationPromise:S}=this.getTransactionConfirmationPromise({commitment:t,signature:o}),I=this.getCancellationPromise(e);let x;try{const k=await Promise.race([I,S,l]);if(k.__type===Ce.PROCESSED)x=k.response;else{let R;for(;;){const A=await this.getSignatureStatus(o);if(A==null)break;if(A.context.slot<(k.slotInWhichNonceDidAdvance??r)){await Ge(400);continue}R=A;break}if(R?.value){const A=t||"finalized",{confirmationStatus:T}=R.value;switch(A){case"processed":case"recent":if(T!=="processed"&&T!=="confirmed"&&T!=="finalized")throw new hr(o);break;case"confirmed":case"single":case"singleGossip":if(T!=="confirmed"&&T!=="finalized")throw new hr(o);break;case"finalized":case"max":case"root":if(T!=="finalized")throw new hr(o);break;default:}x={context:R.context,value:{err:R.value.err}}}else throw new hr(o)}}finally{h=!0,y()}return x}async confirmTransactionUsingLegacyTimeoutStrategy({commitment:t,signature:e}){let r;const i=new Promise(l=>{let y=this._confirmTransactionInitialTimeout||6e4;switch(t){case"processed":case"recent":case"single":case"confirmed":case"singleGossip":{y=this._confirmTransactionInitialTimeout||3e4;break}}r=setTimeout(()=>l({__type:Ce.TIMED_OUT,timeoutMs:y}),y)}),{abortConfirmation:s,confirmationPromise:o}=this.getTransactionConfirmationPromise({commitment:t,signature:e});let h;try{const l=await Promise.race([o,i]);if(l.__type===Ce.PROCESSED)h=l.response;else throw new Ws(e,l.timeoutMs/1e3)}finally{clearTimeout(r),s()}return h}async getClusterNodes(){const t=await this._rpcRequest("getClusterNodes",[]),e=j(t,st(Z(Xl)));if("error"in e)throw new tt(e.error,"failed to get cluster nodes");return e.result}async getVoteAccounts(t){const e=this._buildArgs([],t),r=await this._rpcRequest("getVoteAccounts",e),i=j(r,Jl);if("error"in i)throw new tt(i.error,"failed to get vote accounts");return i.result}async getSlot(t){const{commitment:e,config:r}=gt(t),i=this._buildArgs([],e,void 0,r),s=await this._rpcRequest("getSlot",i),o=j(s,st(O()));if("error"in o)throw new tt(o.error,"failed to get slot");return o.result}async getSlotLeader(t){const{commitment:e,config:r}=gt(t),i=this._buildArgs([],e,void 0,r),s=await this._rpcRequest("getSlotLeader",i),o=j(s,st(V()));if("error"in o)throw new tt(o.error,"failed to get slot leader");return o.result}async getSlotLeaders(t,e){const r=[t,e],i=await this._rpcRequest("getSlotLeaders",r),s=j(i,st(Z(wt)));if("error"in s)throw new tt(s.error,"failed to get slot leaders");return s.result}async getSignatureStatus(t,e){const{context:r,value:i}=await this.getSignatureStatuses([t],e);ct(i.length===1);const s=i[0];return{context:r,value:s}}async getSignatureStatuses(t,e){const r=[t];e&&r.push(e);const i=await this._rpcRequest("getSignatureStatuses",r),s=j(i,eh);if("error"in s)throw new tt(s.error,"failed to get signature status");return s.result}async getTransactionCount(t){const{commitment:e,config:r}=gt(t),i=this._buildArgs([],e,void 0,r),s=await this._rpcRequest("getTransactionCount",i),o=j(s,st(O()));if("error"in o)throw new tt(o.error,"failed to get transaction count");return o.result}async getTotalSupply(t){return(await this.getSupply({commitment:t,excludeNonCirculatingAccountsList:!0})).value.total}async getInflationGovernor(t){const e=this._buildArgs([],t),r=await this._rpcRequest("getInflationGovernor",e),i=j(r,_l);if("error"in i)throw new tt(i.error,"failed to get inflation");return i.result}async getInflationReward(t,e,r){const{commitment:i,config:s}=gt(r),o=this._buildArgs([t.map(y=>y.toBase58())],i,void 0,{...s,epoch:e??s?.epoch}),h=await this._rpcRequest("getInflationReward",o),l=j(h,ul);if("error"in l)throw new tt(l.error,"failed to get inflation reward");return l.result}async getInflationRate(){const t=await this._rpcRequest("getInflationRate",[]),e=j(t,El);if("error"in e)throw new tt(e.error,"failed to get inflation rate");return e.result}async getEpochInfo(t){const{commitment:e,config:r}=gt(t),i=this._buildArgs([],e,void 0,r),s=await this._rpcRequest("getEpochInfo",i),o=j(s,Al);if("error"in o)throw new tt(o.error,"failed to get epoch info");return o.result}async getEpochSchedule(){const t=await this._rpcRequest("getEpochSchedule",[]),e=j(t,Bl);if("error"in e)throw new tt(e.error,"failed to get epoch schedule");const r=e.result;return new ma(r.slotsPerEpoch,r.leaderScheduleSlotOffset,r.warmup,r.firstNormalEpoch,r.firstNormalSlot)}async getLeaderSchedule(){const t=await this._rpcRequest("getLeaderSchedule",[]),e=j(t,Rl);if("error"in e)throw new tt(e.error,"failed to get leader schedule");return e.result}async getMinimumBalanceForRentExemption(t,e){const r=this._buildArgs([t],e),i=await this._rpcRequest("getMinimumBalanceForRentExemption",r),s=j(i,rh);return"error"in s?(console.warn("Unable to fetch minimum balance for rent exemption"),0):s.result}async getRecentBlockhashAndContext(t){const{context:e,value:{blockhash:r}}=await this.getLatestBlockhashAndContext(t);return{context:e,value:{blockhash:r,feeCalculator:{get lamportsPerSignature(){throw new Error("The capability to fetch `lamportsPerSignature` using the `getRecentBlockhash` API is no longer offered by the network. Use the `getFeeForMessage` API to obtain the fee for a given message.")},toJSON(){return{}}}}}}async getRecentPerformanceSamples(t){const e=await this._rpcRequest("getRecentPerformanceSamples",t?[t]:[]),r=j(e,gh);if("error"in r)throw new tt(r.error,"failed to get recent performance samples");return r.result}async getFeeCalculatorForBlockhash(t,e){const r=this._buildArgs([t],e),i=await this._rpcRequest("getFeeCalculatorForBlockhash",r),s=j(i,yh);if("error"in s)throw new tt(s.error,"failed to get fee calculator");const{context:o,value:h}=s.result;return{context:o,value:h!==null?h.feeCalculator:null}}async getFeeForMessage(t,e){const r=it(t.serialize()).toString("base64"),i=this._buildArgs([r],e),s=await this._rpcRequest("getFeeForMessage",i),o=j(s,St(Y(O())));if("error"in o)throw new tt(o.error,"failed to get fee for message");if(o.result===null)throw new Error("invalid blockhash");return o.result}async getRecentPrioritizationFees(t){const e=t?.lockedWritableAccounts?.map(o=>o.toBase58()),r=e?.length?[e]:[],i=await this._rpcRequest("getRecentPrioritizationFees",r),s=j(i,Il);if("error"in s)throw new tt(s.error,"failed to get recent prioritization fees");return s.result}async getRecentBlockhash(t){try{return(await this.getRecentBlockhashAndContext(t)).value}catch(e){throw new Error("failed to get recent blockhash: "+e)}}async getLatestBlockhash(t){try{return(await this.getLatestBlockhashAndContext(t)).value}catch(e){throw new Error("failed to get recent blockhash: "+e)}}async getLatestBlockhashAndContext(t){const{commitment:e,config:r}=gt(t),i=this._buildArgs([],e,void 0,r),s=await this._rpcRequest("getLatestBlockhash",i),o=j(s,hh);if("error"in o)throw new tt(o.error,"failed to get latest blockhash");return o.result}async isBlockhashValid(t,e){const{commitment:r,config:i}=gt(e),s=this._buildArgs([t],r,void 0,i),o=await this._rpcRequest("isBlockhashValid",s),h=j(o,dh);if("error"in h)throw new tt(h.error,"failed to determine if the blockhash `"+t+"`is valid");return h.result}async getVersion(){const t=await this._rpcRequest("getVersion",[]),e=j(t,st(ml));if("error"in e)throw new tt(e.error,"failed to get version");return e.result}async getGenesisHash(){const t=await this._rpcRequest("getGenesisHash",[]),e=j(t,st(V()));if("error"in e)throw new tt(e.error,"failed to get genesis hash");return e.result}async getBlock(t,e){const{commitment:r,config:i}=gt(e),s=this._buildArgsAtLeastConfirmed([t],r,void 0,i),o=await this._rpcRequest("getBlock",s);try{switch(i?.transactionDetails){case"accounts":{const h=j(o,ah);if("error"in h)throw h.error;return h.result}case"none":{const h=j(o,oh);if("error"in h)throw h.error;return h.result}default:{const h=j(o,ih);if("error"in h)throw h.error;const{result:l}=h;return l?{...l,transactions:l.transactions.map(({transaction:y,meta:S,version:I})=>({meta:S,transaction:{...y,message:hs(I,y.message)},version:I}))}:null}}}catch(h){throw new tt(h,"failed to get confirmed block")}}async getParsedBlock(t,e){const{commitment:r,config:i}=gt(e),s=this._buildArgsAtLeastConfirmed([t],r,"jsonParsed",i),o=await this._rpcRequest("getBlock",s);try{switch(i?.transactionDetails){case"accounts":{const h=j(o,uh);if("error"in h)throw h.error;return h.result}case"none":{const h=j(o,fh);if("error"in h)throw h.error;return h.result}default:{const h=j(o,ch);if("error"in h)throw h.error;return h.result}}}catch(h){throw new tt(h,"failed to get block")}}async getBlockProduction(t){let e,r;if(typeof t=="string")r=t;else if(t){const{commitment:h,...l}=t;r=h,e=l}const i=this._buildArgs([],r,"base64",e),s=await this._rpcRequest("getBlockProduction",i),o=j(s,vl);if("error"in o)throw new tt(o.error,"failed to get block production information");return o.result}async getTransaction(t,e){const{commitment:r,config:i}=gt(e),s=this._buildArgsAtLeastConfirmed([t],r,void 0,i),o=await this._rpcRequest("getTransaction",s),h=j(o,ds);if("error"in h)throw new tt(h.error,"failed to get transaction");const l=h.result;return l&&{...l,transaction:{...l.transaction,message:hs(l.version,l.transaction.message)}}}async getParsedTransaction(t,e){const{commitment:r,config:i}=gt(e),s=this._buildArgsAtLeastConfirmed([t],r,"jsonParsed",i),o=await this._rpcRequest("getTransaction",s),h=j(o,Zr);if("error"in h)throw new tt(h.error,"failed to get transaction");return h.result}async getParsedTransactions(t,e){const{commitment:r,config:i}=gt(e),s=t.map(l=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([l],r,"jsonParsed",i)}));return(await this._rpcBatchRequest(s)).map(l=>{const y=j(l,Zr);if("error"in y)throw new tt(y.error,"failed to get transactions");return y.result})}async getTransactions(t,e){const{commitment:r,config:i}=gt(e),s=t.map(l=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([l],r,void 0,i)}));return(await this._rpcBatchRequest(s)).map(l=>{const y=j(l,ds);if("error"in y)throw new tt(y.error,"failed to get transactions");const S=y.result;return S&&{...S,transaction:{...S.transaction,message:hs(S.version,S.transaction.message)}}})}async getConfirmedBlock(t,e){const r=this._buildArgsAtLeastConfirmed([t],e),i=await this._rpcRequest("getBlock",r),s=j(i,lh);if("error"in s)throw new tt(s.error,"failed to get confirmed block");const o=s.result;if(!o)throw new Error("Confirmed block "+t+" not found");const h={...o,transactions:o.transactions.map(({transaction:l,meta:y})=>{const S=new Se(l.message);return{meta:y,transaction:{...l,message:S}}})};return{...h,transactions:h.transactions.map(({transaction:l,meta:y})=>({meta:y,transaction:ut.populate(l.message,l.signatures)}))}}async getBlocks(t,e,r){const i=this._buildArgsAtLeastConfirmed(e!==void 0?[t,e]:[t],r),s=await this._rpcRequest("getBlocks",i),o=j(s,st(Z(O())));if("error"in o)throw new tt(o.error,"failed to get blocks");return o.result}async getBlockSignatures(t,e){const r=this._buildArgsAtLeastConfirmed([t],e,void 0,{transactionDetails:"signatures",rewards:!1}),i=await this._rpcRequest("getBlock",r),s=j(i,no);if("error"in s)throw new tt(s.error,"failed to get block");const o=s.result;if(!o)throw new Error("Block "+t+" not found");return o}async getConfirmedBlockSignatures(t,e){const r=this._buildArgsAtLeastConfirmed([t],e,void 0,{transactionDetails:"signatures",rewards:!1}),i=await this._rpcRequest("getBlock",r),s=j(i,no);if("error"in s)throw new tt(s.error,"failed to get confirmed block");const o=s.result;if(!o)throw new Error("Confirmed block "+t+" not found");return o}async getConfirmedTransaction(t,e){const r=this._buildArgsAtLeastConfirmed([t],e),i=await this._rpcRequest("getTransaction",r),s=j(i,ds);if("error"in s)throw new tt(s.error,"failed to get transaction");const o=s.result;if(!o)return o;const h=new Se(o.transaction.message),l=o.transaction.signatures;return{...o,transaction:ut.populate(h,l)}}async getParsedConfirmedTransaction(t,e){const r=this._buildArgsAtLeastConfirmed([t],e,"jsonParsed"),i=await this._rpcRequest("getTransaction",r),s=j(i,Zr);if("error"in s)throw new tt(s.error,"failed to get confirmed transaction");return s.result}async getParsedConfirmedTransactions(t,e){const r=t.map(o=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([o],e,"jsonParsed")}));return(await this._rpcBatchRequest(r)).map(o=>{const h=j(o,Zr);if("error"in h)throw new tt(h.error,"failed to get confirmed transactions");return h.result})}async getConfirmedSignaturesForAddress(t,e,r){let i={},s=await this.getFirstAvailableBlock();for(;!("until"in i)&&(e--,!(e<=0||e<s));)try{const l=await this.getConfirmedBlockSignatures(e,"finalized");l.signatures.length>0&&(i.until=l.signatures[l.signatures.length-1].toString())}catch(l){if(l instanceof Error&&l.message.includes("skipped"))continue;throw l}let o=await this.getSlot("finalized");for(;!("before"in i)&&(r++,!(r>o));)try{const l=await this.getConfirmedBlockSignatures(r);l.signatures.length>0&&(i.before=l.signatures[l.signatures.length-1].toString())}catch(l){if(l instanceof Error&&l.message.includes("skipped"))continue;throw l}return(await this.getConfirmedSignaturesForAddress2(t,i)).map(l=>l.signature)}async getConfirmedSignaturesForAddress2(t,e,r){const i=this._buildArgsAtLeastConfirmed([t.toBase58()],r,void 0,e),s=await this._rpcRequest("getConfirmedSignaturesForAddress2",i),o=j(s,ql);if("error"in o)throw new tt(o.error,"failed to get confirmed signatures for address");return o.result}async getSignaturesForAddress(t,e,r){const i=this._buildArgsAtLeastConfirmed([t.toBase58()],r,void 0,e),s=await this._rpcRequest("getSignaturesForAddress",i),o=j(s,Dl);if("error"in o)throw new tt(o.error,"failed to get signatures for address");return o.result}async getAddressLookupTable(t,e){const{context:r,value:i}=await this.getAccountInfoAndContext(t,e);let s=null;return i!==null&&(s=new Ss({key:t,state:Ss.deserialize(i.data)})),{context:r,value:s}}async getNonceAndContext(t,e){const{context:r,value:i}=await this.getAccountInfoAndContext(t,e);let s=null;return i!==null&&(s=wn.fromAccountData(i.data)),{context:r,value:s}}async getNonce(t,e){return await this.getNonceAndContext(t,e).then(r=>r.value).catch(r=>{throw new Error("failed to get nonce for account "+t.toBase58()+": "+r)})}async requestAirdrop(t,e){const r=await this._rpcRequest("requestAirdrop",[t.toBase58(),e]),i=j(r,mh);if("error"in i)throw new tt(i.error,`airdrop to ${t.toBase58()} failed`);return i.result}async _blockhashWithExpiryBlockHeight(t){if(!t){for(;this._pollingBlockhash;)await Ge(100);const r=Date.now()-this._blockhashInfo.lastFetch>=wa;if(this._blockhashInfo.latestBlockhash!==null&&!r)return this._blockhashInfo.latestBlockhash}return await this._pollNewBlockhash()}async _pollNewBlockhash(){this._pollingBlockhash=!0;try{const t=Date.now(),e=this._blockhashInfo.latestBlockhash,r=e?e.blockhash:null;for(let i=0;i<50;i++){const s=await this.getLatestBlockhash("finalized");if(r!==s.blockhash)return this._blockhashInfo={latestBlockhash:s,lastFetch:Date.now(),transactionSignatures:[],simulatedSignatures:[]},s;await Ge(pa/2)}throw new Error(`Unable to obtain a new blockhash after ${Date.now()-t}ms`)}finally{this._pollingBlockhash=!1}}async getStakeMinimumDelegation(t){const{commitment:e,config:r}=gt(t),i=this._buildArgs([],e,"base64",r),s=await this._rpcRequest("getStakeMinimumDelegation",i),o=j(s,St(O()));if("error"in o)throw new tt(o.error,"failed to get stake minimum delegation");return o.result}async simulateTransaction(t,e,r){if("message"in t){const A=t.serialize(),T=nt.Buffer.from(A).toString("base64");if(Array.isArray(e)||r!==void 0)throw new Error("Invalid arguments");const C=e||{};C.encoding="base64","commitment"in C||(C.commitment=this.commitment),e&&typeof e=="object"&&"innerInstructions"in e&&(C.innerInstructions=e.innerInstructions);const D=[T,C],U=await this._rpcRequest("simulateTransaction",D),W=j(U,eo);if("error"in W)throw new Error("failed to simulate transaction: "+W.error.message);return W.result}let i;if(t instanceof ut){let R=t;i=new ut,i.feePayer=R.feePayer,i.instructions=t.instructions,i.nonceInfo=R.nonceInfo,i.signatures=R.signatures}else i=ut.populate(t),i._message=i._json=void 0;if(e!==void 0&&!Array.isArray(e))throw new Error("Invalid arguments");const s=e;if(i.nonceInfo&&s)i.sign(...s);else{let R=this._disableBlockhashCaching;for(;;){const A=await this._blockhashWithExpiryBlockHeight(R);if(i.lastValidBlockHeight=A.lastValidBlockHeight,i.recentBlockhash=A.blockhash,!s)break;if(i.sign(...s),!i.signature)throw new Error("!signature");const T=i.signature.toString("base64");if(!this._blockhashInfo.simulatedSignatures.includes(T)&&!this._blockhashInfo.transactionSignatures.includes(T)){this._blockhashInfo.simulatedSignatures.push(T);break}else R=!0}}const o=i._compile(),h=o.serialize(),y=i._serialize(h).toString("base64"),S={encoding:"base64",commitment:this.commitment};if(r){const R=(Array.isArray(r)?r:o.nonProgramIds()).map(A=>A.toBase58());S.accounts={encoding:"base64",addresses:R}}s&&(S.sigVerify=!0),e&&typeof e=="object"&&"innerInstructions"in e&&(S.innerInstructions=e.innerInstructions);const I=[y,S],x=await this._rpcRequest("simulateTransaction",I),k=j(x,eo);if("error"in k){let R;if("data"in k.error&&(R=k.error.data.logs,R&&Array.isArray(R))){const A=`
    `,T=A+R.join(A);console.error(k.error.message,T)}throw new Cr({action:"simulate",signature:"",transactionMessage:k.error.message,logs:R})}return k.result}async sendTransaction(t,e,r){if("version"in t){if(e&&Array.isArray(e))throw new Error("Invalid arguments");const o=t.serialize();return await this.sendRawTransaction(o,e)}if(e===void 0||!Array.isArray(e))throw new Error("Invalid arguments");const i=e;if(t.nonceInfo)t.sign(...i);else{let o=this._disableBlockhashCaching;for(;;){const h=await this._blockhashWithExpiryBlockHeight(o);if(t.lastValidBlockHeight=h.lastValidBlockHeight,t.recentBlockhash=h.blockhash,t.sign(...i),!t.signature)throw new Error("!signature");const l=t.signature.toString("base64");if(this._blockhashInfo.transactionSignatures.includes(l))o=!0;else{this._blockhashInfo.transactionSignatures.push(l);break}}}const s=t.serialize();return await this.sendRawTransaction(s,r)}async sendRawTransaction(t,e){const r=it(t).toString("base64");return await this.sendEncodedTransaction(r,e)}async sendEncodedTransaction(t,e){const r={encoding:"base64"},i=e&&e.skipPreflight,s=i===!0?"processed":e&&e.preflightCommitment||this.commitment;e&&e.maxRetries!=null&&(r.maxRetries=e.maxRetries),e&&e.minContextSlot!=null&&(r.minContextSlot=e.minContextSlot),i&&(r.skipPreflight=i),s&&(r.preflightCommitment=s);const o=[t,r],h=await this._rpcRequest("sendTransaction",o),l=j(h,bh);if("error"in l){let y;throw"data"in l.error&&(y=l.error.data.logs),new Cr({action:i?"send":"simulate",signature:"",transactionMessage:l.error.message,logs:y})}return l.result}_wsOnOpen(){this._rpcWebSocketConnected=!0,this._rpcWebSocketHeartbeat=setInterval(()=>{(async()=>{try{await this._rpcWebSocket.notify("ping")}catch{}})()},5e3),this._updateSubscriptions()}_wsOnError(t){this._rpcWebSocketConnected=!1,console.error("ws error:",t.message)}_wsOnClose(t){if(this._rpcWebSocketConnected=!1,this._rpcWebSocketGeneration=(this._rpcWebSocketGeneration+1)%Number.MAX_SAFE_INTEGER,this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null),this._rpcWebSocketHeartbeat&&(clearInterval(this._rpcWebSocketHeartbeat),this._rpcWebSocketHeartbeat=null),t===1e3){this._updateSubscriptions();return}this._subscriptionCallbacksByServerSubscriptionId={},Object.entries(this._subscriptionsByHash).forEach(([e,r])=>{this._setSubscription(e,{...r,state:"pending"})})}_setSubscription(t,e){const r=this._subscriptionsByHash[t]?.state;if(this._subscriptionsByHash[t]=e,r!==e.state){const i=this._subscriptionStateChangeCallbacksByHash[t];i&&i.forEach(s=>{try{s(e.state)}catch{}})}}_onSubscriptionStateChange(t,e){const r=this._subscriptionHashByClientSubscriptionId[t];if(r==null)return()=>{};const i=this._subscriptionStateChangeCallbacksByHash[r]||=new Set;return i.add(e),()=>{i.delete(e),i.size===0&&delete this._subscriptionStateChangeCallbacksByHash[r]}}async _updateSubscriptions(){if(Object.keys(this._subscriptionsByHash).length===0){this._rpcWebSocketConnected&&(this._rpcWebSocketConnected=!1,this._rpcWebSocketIdleTimeout=setTimeout(()=>{this._rpcWebSocketIdleTimeout=null;try{this._rpcWebSocket.close()}catch(r){r instanceof Error&&console.log(`Error when closing socket connection: ${r.message}`)}},500));return}if(this._rpcWebSocketIdleTimeout!==null&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketConnected=!0),!this._rpcWebSocketConnected){this._rpcWebSocket.connect();return}const t=this._rpcWebSocketGeneration,e=()=>t===this._rpcWebSocketGeneration;await Promise.all(Object.keys(this._subscriptionsByHash).map(async r=>{const i=this._subscriptionsByHash[r];if(i!==void 0)switch(i.state){case"pending":case"unsubscribed":if(i.callbacks.size===0){delete this._subscriptionsByHash[r],i.state==="unsubscribed"&&delete this._subscriptionCallbacksByServerSubscriptionId[i.serverSubscriptionId],await this._updateSubscriptions();return}await(async()=>{const{args:s,method:o}=i;try{this._setSubscription(r,{...i,state:"subscribing"});const h=await this._rpcWebSocket.call(o,s);this._setSubscription(r,{...i,serverSubscriptionId:h,state:"subscribed"}),this._subscriptionCallbacksByServerSubscriptionId[h]=i.callbacks,await this._updateSubscriptions()}catch(h){if(console.error(`Received ${h instanceof Error?"":"JSON-RPC "}error calling \`${o}\``,{args:s,error:h}),!e())return;this._setSubscription(r,{...i,state:"pending"}),await this._updateSubscriptions()}})();break;case"subscribed":i.callbacks.size===0&&await(async()=>{const{serverSubscriptionId:s,unsubscribeMethod:o}=i;if(this._subscriptionsAutoDisposedByRpc.has(s))this._subscriptionsAutoDisposedByRpc.delete(s);else{this._setSubscription(r,{...i,state:"unsubscribing"}),this._setSubscription(r,{...i,state:"unsubscribing"});try{await this._rpcWebSocket.call(o,[s])}catch(h){if(h instanceof Error&&console.error(`${o} error:`,h.message),!e())return;this._setSubscription(r,{...i,state:"subscribed"}),await this._updateSubscriptions();return}}this._setSubscription(r,{...i,state:"unsubscribed"}),await this._updateSubscriptions()})();break}}))}_handleServerNotification(t,e){const r=this._subscriptionCallbacksByServerSubscriptionId[t];r!==void 0&&r.forEach(i=>{try{i(...e)}catch(s){console.error(s)}})}_wsOnAccountNotification(t){const{result:e,subscription:r}=j(t,Fl);this._handleServerNotification(r,[e.value,e.context])}_makeSubscription(t,e){const r=this._nextClientSubscriptionId++,i=Ji([t.method,e]),s=this._subscriptionsByHash[i];return s===void 0?this._subscriptionsByHash[i]={...t,args:e,callbacks:new Set([t.callback]),state:"pending"}:s.callbacks.add(t.callback),this._subscriptionHashByClientSubscriptionId[r]=i,this._subscriptionDisposeFunctionsByClientSubscriptionId[r]=async()=>{delete this._subscriptionDisposeFunctionsByClientSubscriptionId[r],delete this._subscriptionHashByClientSubscriptionId[r];const o=this._subscriptionsByHash[i];ct(o!==void 0,`Could not find a \`Subscription\` when tearing down client subscription #${r}`),o.callbacks.delete(t.callback),await this._updateSubscriptions()},this._updateSubscriptions(),r}onAccountChange(t,e,r){const{commitment:i,config:s}=gt(r),o=this._buildArgs([t.toBase58()],i||this._commitment||"finalized","base64",s);return this._makeSubscription({callback:e,method:"accountSubscribe",unsubscribeMethod:"accountUnsubscribe"},o)}async removeAccountChangeListener(t){await this._unsubscribeClientSubscription(t,"account change")}_wsOnProgramAccountNotification(t){const{result:e,subscription:r}=j(t,Vl);this._handleServerNotification(r,[{accountId:e.value.pubkey,accountInfo:e.value.account},e.context])}onProgramAccountChange(t,e,r,i){const{commitment:s,config:o}=gt(r),h=this._buildArgs([t.toBase58()],s||this._commitment||"finalized","base64",o||(i?{filters:to(i)}:void 0));return this._makeSubscription({callback:e,method:"programSubscribe",unsubscribeMethod:"programUnsubscribe"},h)}async removeProgramAccountChangeListener(t){await this._unsubscribeClientSubscription(t,"program account change")}onLogs(t,e,r){const i=this._buildArgs([typeof t=="object"?{mentions:[t.toString()]}:t],r||this._commitment||"finalized");return this._makeSubscription({callback:e,method:"logsSubscribe",unsubscribeMethod:"logsUnsubscribe"},i)}async removeOnLogsListener(t){await this._unsubscribeClientSubscription(t,"logs")}_wsOnLogsNotification(t){const{result:e,subscription:r}=j(t,vh);this._handleServerNotification(r,[e.value,e.context])}_wsOnSlotNotification(t){const{result:e,subscription:r}=j(t,$l);this._handleServerNotification(r,[e])}onSlotChange(t){return this._makeSubscription({callback:t,method:"slotSubscribe",unsubscribeMethod:"slotUnsubscribe"},[])}async removeSlotChangeListener(t){await this._unsubscribeClientSubscription(t,"slot change")}_wsOnSlotUpdatesNotification(t){const{result:e,subscription:r}=j(t,Gl);this._handleServerNotification(r,[e])}onSlotUpdate(t){return this._makeSubscription({callback:t,method:"slotsUpdatesSubscribe",unsubscribeMethod:"slotsUpdatesUnsubscribe"},[])}async removeSlotUpdateListener(t){await this._unsubscribeClientSubscription(t,"slot update")}async _unsubscribeClientSubscription(t,e){const r=this._subscriptionDisposeFunctionsByClientSubscriptionId[t];r?await r():console.warn(`Ignored unsubscribe request because an active subscription with id \`${t}\` for '${e}' events could not be found.`)}_buildArgs(t,e,r,i){const s=e||this._commitment;if(s||r||i){let o={};r&&(o.encoding=r),s&&(o.commitment=s),i&&(o=Object.assign(o,i)),t.push(o)}return t}_buildArgsAtLeastConfirmed(t,e,r,i){const s=e||this._commitment;if(s&&!["confirmed","finalized"].includes(s))throw new Error("Using Connection with default commitment: `"+this._commitment+"`, but method requires at least `confirmed`");return this._buildArgs(t,e,r,i)}_wsOnSignatureNotification(t){const{result:e,subscription:r}=j(t,Zl);e.value!=="receivedSignature"&&this._subscriptionsAutoDisposedByRpc.add(r),this._handleServerNotification(r,e.value==="receivedSignature"?[{type:"received"},e.context]:[{type:"status",result:e.value},e.context])}onSignature(t,e,r){const i=this._buildArgs([t],r||this._commitment||"finalized"),s=this._makeSubscription({callback:(o,h)=>{if(o.type==="status"){e(o.result,h);try{this.removeSignatureListener(s)}catch{}}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},i);return s}onSignatureWithOptions(t,e,r){const{commitment:i,...s}={...r,commitment:r&&r.commitment||this._commitment||"finalized"},o=this._buildArgs([t],i,void 0,s),h=this._makeSubscription({callback:(l,y)=>{e(l,y);try{this.removeSignatureListener(h)}catch{}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},o);return h}async removeSignatureListener(t){await this._unsubscribeClientSubscription(t,"signature result")}_wsOnRootNotification(t){const{result:e,subscription:r}=j(t,Yl);this._handleServerNotification(r,[e])}onRootChange(t){return this._makeSubscription({callback:t,method:"rootSubscribe",unsubscribeMethod:"rootUnsubscribe"},[])}async removeRootChangeListener(t){await this._unsubscribeClientSubscription(t,"root change")}}class gr{constructor(t){this._keypair=void 0,this._keypair=t??Gi()}static generate(){return new gr(Gi())}static fromSecretKey(t,e){if(t.byteLength!==64)throw new Error("bad secret key size");const r=t.slice(32,64);if(!e||!e.skipValidation){const i=t.slice(0,32),s=cn(i);for(let o=0;o<32;o++)if(r[o]!==s[o])throw new Error("provided secretKey is invalid")}return new gr({publicKey:r,secretKey:t})}static fromSeed(t){const e=cn(t),r=new Uint8Array(64);return r.set(t),r.set(e,32),new gr({publicKey:e,secretKey:r})}get publicKey(){return new H(this._keypair.publicKey)}get secretKey(){return new Uint8Array(this._keypair.secretKey)}}const Ue=Object.freeze({CreateLookupTable:{index:0,layout:E.struct([E.u32("instruction"),kr("recentSlot"),E.u8("bumpSeed")])},FreezeLookupTable:{index:1,layout:E.struct([E.u32("instruction")])},ExtendLookupTable:{index:2,layout:E.struct([E.u32("instruction"),kr(),E.seq(ot(),E.offset(E.u32(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:E.struct([E.u32("instruction")])},CloseLookupTable:{index:4,layout:E.struct([E.u32("instruction")])}});class xh{constructor(){}static decodeInstructionType(t){this.checkProgramId(t.programId);const r=E.u32("instruction").decode(t.data);let i;for(const[s,o]of Object.entries(Ue))if(o.index==r){i=s;break}if(!i)throw new Error("Invalid Instruction. Should be a LookupTable Instruction");return i}static decodeCreateLookupTable(t){this.checkProgramId(t.programId),this.checkKeysLength(t.keys,4);const{recentSlot:e}=ft(Ue.CreateLookupTable,t.data);return{authority:t.keys[1].pubkey,payer:t.keys[2].pubkey,recentSlot:Number(e)}}static decodeExtendLookupTable(t){if(this.checkProgramId(t.programId),t.keys.length<2)throw new Error(`invalid instruction; found ${t.keys.length} keys, expected at least 2`);const{addresses:e}=ft(Ue.ExtendLookupTable,t.data);return{lookupTable:t.keys[0].pubkey,authority:t.keys[1].pubkey,payer:t.keys.length>2?t.keys[2].pubkey:void 0,addresses:e.map(r=>new H(r))}}static decodeCloseLookupTable(t){return this.checkProgramId(t.programId),this.checkKeysLength(t.keys,3),{lookupTable:t.keys[0].pubkey,authority:t.keys[1].pubkey,recipient:t.keys[2].pubkey}}static decodeFreezeLookupTable(t){return this.checkProgramId(t.programId),this.checkKeysLength(t.keys,2),{lookupTable:t.keys[0].pubkey,authority:t.keys[1].pubkey}}static decodeDeactivateLookupTable(t){return this.checkProgramId(t.programId),this.checkKeysLength(t.keys,2),{lookupTable:t.keys[0].pubkey,authority:t.keys[1].pubkey}}static checkProgramId(t){if(!t.equals(Ys.programId))throw new Error("invalid instruction; programId is not AddressLookupTable Program")}static checkKeysLength(t,e){if(t.length<e)throw new Error(`invalid instruction; found ${t.length} keys, expected at least ${e}`)}}class Ys{constructor(){}static createLookupTable(t){const[e,r]=H.findProgramAddressSync([t.authority.toBuffer(),Ho().encode(t.recentSlot)],this.programId),i=Ue.CreateLookupTable,s=at(i,{recentSlot:BigInt(t.recentSlot),bumpSeed:r}),o=[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:t.authority,isSigner:!0,isWritable:!1},{pubkey:t.payer,isSigner:!0,isWritable:!0},{pubkey:oe.programId,isSigner:!1,isWritable:!1}];return[new pt({programId:this.programId,keys:o,data:s}),e]}static freezeLookupTable(t){const e=Ue.FreezeLookupTable,r=at(e),i=[{pubkey:t.lookupTable,isSigner:!1,isWritable:!0},{pubkey:t.authority,isSigner:!0,isWritable:!1}];return new pt({programId:this.programId,keys:i,data:r})}static extendLookupTable(t){const e=Ue.ExtendLookupTable,r=at(e,{addresses:t.addresses.map(s=>s.toBytes())}),i=[{pubkey:t.lookupTable,isSigner:!1,isWritable:!0},{pubkey:t.authority,isSigner:!0,isWritable:!1}];return t.payer&&i.push({pubkey:t.payer,isSigner:!0,isWritable:!0},{pubkey:oe.programId,isSigner:!1,isWritable:!1}),new pt({programId:this.programId,keys:i,data:r})}static deactivateLookupTable(t){const e=Ue.DeactivateLookupTable,r=at(e),i=[{pubkey:t.lookupTable,isSigner:!1,isWritable:!0},{pubkey:t.authority,isSigner:!0,isWritable:!1}];return new pt({programId:this.programId,keys:i,data:r})}static closeLookupTable(t){const e=Ue.CloseLookupTable,r=at(e),i=[{pubkey:t.lookupTable,isSigner:!1,isWritable:!0},{pubkey:t.authority,isSigner:!0,isWritable:!1},{pubkey:t.recipient,isSigner:!1,isWritable:!0}];return new pt({programId:this.programId,keys:i,data:r})}}Ys.programId=new H("AddressLookupTab1e1111111111111111111111111");class _h{constructor(){}static decodeInstructionType(t){this.checkProgramId(t.programId);const r=E.u8("instruction").decode(t.data);let i;for(const[s,o]of Object.entries(Ae))if(o.index==r){i=s;break}if(!i)throw new Error("Instruction type incorrect; not a ComputeBudgetInstruction");return i}static decodeRequestUnits(t){this.checkProgramId(t.programId);const{units:e,additionalFee:r}=ft(Ae.RequestUnits,t.data);return{units:e,additionalFee:r}}static decodeRequestHeapFrame(t){this.checkProgramId(t.programId);const{bytes:e}=ft(Ae.RequestHeapFrame,t.data);return{bytes:e}}static decodeSetComputeUnitLimit(t){this.checkProgramId(t.programId);const{units:e}=ft(Ae.SetComputeUnitLimit,t.data);return{units:e}}static decodeSetComputeUnitPrice(t){this.checkProgramId(t.programId);const{microLamports:e}=ft(Ae.SetComputeUnitPrice,t.data);return{microLamports:e}}static checkProgramId(t){if(!t.equals(Xs.programId))throw new Error("invalid instruction; programId is not ComputeBudgetProgram")}}const Ae=Object.freeze({RequestUnits:{index:0,layout:E.struct([E.u8("instruction"),E.u32("units"),E.u32("additionalFee")])},RequestHeapFrame:{index:1,layout:E.struct([E.u8("instruction"),E.u32("bytes")])},SetComputeUnitLimit:{index:2,layout:E.struct([E.u8("instruction"),E.u32("units")])},SetComputeUnitPrice:{index:3,layout:E.struct([E.u8("instruction"),kr("microLamports")])}});class Xs{constructor(){}static requestUnits(t){const e=Ae.RequestUnits,r=at(e,t);return new pt({keys:[],programId:this.programId,data:r})}static requestHeapFrame(t){const e=Ae.RequestHeapFrame,r=at(e,t);return new pt({keys:[],programId:this.programId,data:r})}static setComputeUnitLimit(t){const e=Ae.SetComputeUnitLimit,r=at(e,t);return new pt({keys:[],programId:this.programId,data:r})}static setComputeUnitPrice(t){const e=Ae.SetComputeUnitPrice,r=at(e,{microLamports:BigInt(t.microLamports)});return new pt({keys:[],programId:this.programId,data:r})}}Xs.programId=new H("ComputeBudget111111111111111111111111111111");const so=64,io=32,oo=64,ao=E.struct([E.u8("numSignatures"),E.u8("padding"),E.u16("signatureOffset"),E.u16("signatureInstructionIndex"),E.u16("publicKeyOffset"),E.u16("publicKeyInstructionIndex"),E.u16("messageDataOffset"),E.u16("messageDataSize"),E.u16("messageInstructionIndex")]);class Sn{constructor(){}static createInstructionWithPublicKey(t){const{publicKey:e,message:r,signature:i,instructionIndex:s}=t;ct(e.length===io,`Public Key must be ${io} bytes but received ${e.length} bytes`),ct(i.length===oo,`Signature must be ${oo} bytes but received ${i.length} bytes`);const o=ao.span,h=o+e.length,l=h+i.length,y=1,S=nt.Buffer.alloc(l+r.length),I=s??65535;return ao.encode({numSignatures:y,padding:0,signatureOffset:h,signatureInstructionIndex:I,publicKeyOffset:o,publicKeyInstructionIndex:I,messageDataOffset:l,messageDataSize:r.length,messageInstructionIndex:I},S),S.fill(e,o),S.fill(i,h),S.fill(r,l),new pt({keys:[],programId:Sn.programId,data:S})}static createInstructionWithPrivateKey(t){const{privateKey:e,message:r,instructionIndex:i}=t;ct(e.length===so,`Private key must be ${so} bytes but received ${e.length} bytes`);try{const s=gr.fromSecretKey(e),o=s.publicKey.toBytes(),h=qs(r,s.secretKey);return this.createInstructionWithPublicKey({publicKey:o,message:r,signature:h,instructionIndex:i})}catch(s){throw new Error(`Error creating instruction; ${s}`)}}}Sn.programId=new H("Ed25519SigVerify111111111111111111111111111");const Eh=(n,t)=>{const e=Ks.sign(n,t);return[e.toCompactRawBytes(),e.recovery]};Ks.utils.isValidPrivateKey;const Ih=Ks.getPublicKey,co=32,ps=20,uo=64,Ah=11,gs=E.struct([E.u8("numSignatures"),E.u16("signatureOffset"),E.u8("signatureInstructionIndex"),E.u16("ethAddressOffset"),E.u8("ethAddressInstructionIndex"),E.u16("messageDataOffset"),E.u16("messageDataSize"),E.u8("messageInstructionIndex"),E.blob(20,"ethAddress"),E.blob(64,"signature"),E.u8("recoveryId")]);class yr{constructor(){}static publicKeyToEthAddress(t){ct(t.length===uo,`Public key must be ${uo} bytes but received ${t.length} bytes`);try{return nt.Buffer.from(Hi(it(t))).slice(-ps)}catch(e){throw new Error(`Error constructing Ethereum address: ${e}`)}}static createInstructionWithPublicKey(t){const{publicKey:e,message:r,signature:i,recoveryId:s,instructionIndex:o}=t;return yr.createInstructionWithEthAddress({ethAddress:yr.publicKeyToEthAddress(e),message:r,signature:i,recoveryId:s,instructionIndex:o})}static createInstructionWithEthAddress(t){const{ethAddress:e,message:r,signature:i,recoveryId:s,instructionIndex:o=0}=t;let h;typeof e=="string"?e.startsWith("0x")?h=nt.Buffer.from(e.substr(2),"hex"):h=nt.Buffer.from(e,"hex"):h=e,ct(h.length===ps,`Address must be ${ps} bytes but received ${h.length} bytes`);const l=1+Ah,y=l,S=l+h.length,I=S+i.length+1,x=1,k=nt.Buffer.alloc(gs.span+r.length);return gs.encode({numSignatures:x,signatureOffset:S,signatureInstructionIndex:o,ethAddressOffset:y,ethAddressInstructionIndex:o,messageDataOffset:I,messageDataSize:r.length,messageInstructionIndex:o,signature:it(i),ethAddress:it(h),recoveryId:s},k),k.fill(it(r),gs.span),new pt({keys:[],programId:yr.programId,data:k})}static createInstructionWithPrivateKey(t){const{privateKey:e,message:r,instructionIndex:i}=t;ct(e.length===co,`Private key must be ${co} bytes but received ${e.length} bytes`);try{const s=it(e),o=Ih(s,!1).slice(1),h=nt.Buffer.from(Hi(it(r))),[l,y]=Eh(h,s);return this.createInstructionWithPublicKey({publicKey:o,message:r,signature:l,recoveryId:y,instructionIndex:i})}catch(s){throw new Error(`Error creating instruction; ${s}`)}}}yr.programId=new H("KeccakSecp256k11111111111111111111111111111");var Ra;const Ma=new H("StakeConfig11111111111111111111111111111111");class Ta{constructor(t,e){this.staker=void 0,this.withdrawer=void 0,this.staker=t,this.withdrawer=e}}class Fr{constructor(t,e,r){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=t,this.epoch=e,this.custodian=r}}Ra=Fr;Fr.default=new Ra(0,0,H.default);class Bh{constructor(){}static decodeInstructionType(t){this.checkProgramId(t.programId);const r=E.u32("instruction").decode(t.data);let i;for(const[s,o]of Object.entries(ie))if(o.index==r){i=s;break}if(!i)throw new Error("Instruction type incorrect; not a StakeInstruction");return i}static decodeInitialize(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,2);const{authorized:e,lockup:r}=ft(ie.Initialize,t.data);return{stakePubkey:t.keys[0].pubkey,authorized:new Ta(new H(e.staker),new H(e.withdrawer)),lockup:new Fr(r.unixTimestamp,r.epoch,new H(r.custodian))}}static decodeDelegate(t){return this.checkProgramId(t.programId),this.checkKeyLength(t.keys,6),ft(ie.Delegate,t.data),{stakePubkey:t.keys[0].pubkey,votePubkey:t.keys[1].pubkey,authorizedPubkey:t.keys[5].pubkey}}static decodeAuthorize(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,3);const{newAuthorized:e,stakeAuthorizationType:r}=ft(ie.Authorize,t.data),i={stakePubkey:t.keys[0].pubkey,authorizedPubkey:t.keys[2].pubkey,newAuthorizedPubkey:new H(e),stakeAuthorizationType:{index:r}};return t.keys.length>3&&(i.custodianPubkey=t.keys[3].pubkey),i}static decodeAuthorizeWithSeed(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,2);const{newAuthorized:e,stakeAuthorizationType:r,authoritySeed:i,authorityOwner:s}=ft(ie.AuthorizeWithSeed,t.data),o={stakePubkey:t.keys[0].pubkey,authorityBase:t.keys[1].pubkey,authoritySeed:i,authorityOwner:new H(s),newAuthorizedPubkey:new H(e),stakeAuthorizationType:{index:r}};return t.keys.length>3&&(o.custodianPubkey=t.keys[3].pubkey),o}static decodeSplit(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,3);const{lamports:e}=ft(ie.Split,t.data);return{stakePubkey:t.keys[0].pubkey,splitStakePubkey:t.keys[1].pubkey,authorizedPubkey:t.keys[2].pubkey,lamports:e}}static decodeMerge(t){return this.checkProgramId(t.programId),this.checkKeyLength(t.keys,3),ft(ie.Merge,t.data),{stakePubkey:t.keys[0].pubkey,sourceStakePubKey:t.keys[1].pubkey,authorizedPubkey:t.keys[4].pubkey}}static decodeWithdraw(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,5);const{lamports:e}=ft(ie.Withdraw,t.data),r={stakePubkey:t.keys[0].pubkey,toPubkey:t.keys[1].pubkey,authorizedPubkey:t.keys[4].pubkey,lamports:e};return t.keys.length>5&&(r.custodianPubkey=t.keys[5].pubkey),r}static decodeDeactivate(t){return this.checkProgramId(t.programId),this.checkKeyLength(t.keys,3),ft(ie.Deactivate,t.data),{stakePubkey:t.keys[0].pubkey,authorizedPubkey:t.keys[2].pubkey}}static checkProgramId(t){if(!t.equals(xn.programId))throw new Error("invalid instruction; programId is not StakeProgram")}static checkKeyLength(t,e){if(t.length<e)throw new Error(`invalid instruction; found ${t.length} keys, expected at least ${e}`)}}const ie=Object.freeze({Initialize:{index:0,layout:E.struct([E.u32("instruction"),Pf(),Lf()])},Authorize:{index:1,layout:E.struct([E.u32("instruction"),ot("newAuthorized"),E.u32("stakeAuthorizationType")])},Delegate:{index:2,layout:E.struct([E.u32("instruction")])},Split:{index:3,layout:E.struct([E.u32("instruction"),E.ns64("lamports")])},Withdraw:{index:4,layout:E.struct([E.u32("instruction"),E.ns64("lamports")])},Deactivate:{index:5,layout:E.struct([E.u32("instruction")])},Merge:{index:7,layout:E.struct([E.u32("instruction")])},AuthorizeWithSeed:{index:8,layout:E.struct([E.u32("instruction"),ot("newAuthorized"),E.u32("stakeAuthorizationType"),Je("authoritySeed"),ot("authorityOwner")])}}),Rh=Object.freeze({Staker:{index:0},Withdrawer:{index:1}});class xn{constructor(){}static initialize(t){const{stakePubkey:e,authorized:r,lockup:i}=t,s=i||Fr.default,o=ie.Initialize,h=at(o,{authorized:{staker:it(r.staker.toBuffer()),withdrawer:it(r.withdrawer.toBuffer())},lockup:{unixTimestamp:s.unixTimestamp,epoch:s.epoch,custodian:it(s.custodian.toBuffer())}}),l={keys:[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:vr,isSigner:!1,isWritable:!1}],programId:this.programId,data:h};return new pt(l)}static createAccountWithSeed(t){const e=new ut;e.add(oe.createAccountWithSeed({fromPubkey:t.fromPubkey,newAccountPubkey:t.stakePubkey,basePubkey:t.basePubkey,seed:t.seed,lamports:t.lamports,space:this.space,programId:this.programId}));const{stakePubkey:r,authorized:i,lockup:s}=t;return e.add(this.initialize({stakePubkey:r,authorized:i,lockup:s}))}static createAccount(t){const e=new ut;e.add(oe.createAccount({fromPubkey:t.fromPubkey,newAccountPubkey:t.stakePubkey,lamports:t.lamports,space:this.space,programId:this.programId}));const{stakePubkey:r,authorized:i,lockup:s}=t;return e.add(this.initialize({stakePubkey:r,authorized:i,lockup:s}))}static delegate(t){const{stakePubkey:e,authorizedPubkey:r,votePubkey:i}=t,s=ie.Delegate,o=at(s);return new ut().add({keys:[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!1},{pubkey:_e,isSigner:!1,isWritable:!1},{pubkey:Jr,isSigner:!1,isWritable:!1},{pubkey:Ma,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:o})}static authorize(t){const{stakePubkey:e,authorizedPubkey:r,newAuthorizedPubkey:i,stakeAuthorizationType:s,custodianPubkey:o}=t,h=ie.Authorize,l=at(h,{newAuthorized:it(i.toBuffer()),stakeAuthorizationType:s.index}),y=[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:_e,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}];return o&&y.push({pubkey:o,isSigner:!0,isWritable:!1}),new ut().add({keys:y,programId:this.programId,data:l})}static authorizeWithSeed(t){const{stakePubkey:e,authorityBase:r,authoritySeed:i,authorityOwner:s,newAuthorizedPubkey:o,stakeAuthorizationType:h,custodianPubkey:l}=t,y=ie.AuthorizeWithSeed,S=at(y,{newAuthorized:it(o.toBuffer()),stakeAuthorizationType:h.index,authoritySeed:i,authorityOwner:it(s.toBuffer())}),I=[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1},{pubkey:_e,isSigner:!1,isWritable:!1}];return l&&I.push({pubkey:l,isSigner:!0,isWritable:!1}),new ut().add({keys:I,programId:this.programId,data:S})}static splitInstruction(t){const{stakePubkey:e,authorizedPubkey:r,splitStakePubkey:i,lamports:s}=t,o=ie.Split,h=at(o,{lamports:s});return new pt({keys:[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:h})}static split(t,e){const r=new ut;return r.add(oe.createAccount({fromPubkey:t.authorizedPubkey,newAccountPubkey:t.splitStakePubkey,lamports:e,space:this.space,programId:this.programId})),r.add(this.splitInstruction(t))}static splitWithSeed(t,e){const{stakePubkey:r,authorizedPubkey:i,splitStakePubkey:s,basePubkey:o,seed:h,lamports:l}=t,y=new ut;return y.add(oe.allocate({accountPubkey:s,basePubkey:o,seed:h,space:this.space,programId:this.programId})),e&&e>0&&y.add(oe.transfer({fromPubkey:t.authorizedPubkey,toPubkey:s,lamports:e})),y.add(this.splitInstruction({stakePubkey:r,authorizedPubkey:i,splitStakePubkey:s,lamports:l}))}static merge(t){const{stakePubkey:e,sourceStakePubKey:r,authorizedPubkey:i}=t,s=ie.Merge,o=at(s);return new ut().add({keys:[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:_e,isSigner:!1,isWritable:!1},{pubkey:Jr,isSigner:!1,isWritable:!1},{pubkey:i,isSigner:!0,isWritable:!1}],programId:this.programId,data:o})}static withdraw(t){const{stakePubkey:e,authorizedPubkey:r,toPubkey:i,lamports:s,custodianPubkey:o}=t,h=ie.Withdraw,l=at(h,{lamports:s}),y=[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!1,isWritable:!0},{pubkey:_e,isSigner:!1,isWritable:!1},{pubkey:Jr,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}];return o&&y.push({pubkey:o,isSigner:!0,isWritable:!1}),new ut().add({keys:y,programId:this.programId,data:l})}static deactivate(t){const{stakePubkey:e,authorizedPubkey:r}=t,i=ie.Deactivate,s=at(i);return new ut().add({keys:[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:_e,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:s})}}xn.programId=new H("Stake11111111111111111111111111111111111111");xn.space=200;class Pa{constructor(t,e,r,i){this.nodePubkey=void 0,this.authorizedVoter=void 0,this.authorizedWithdrawer=void 0,this.commission=void 0,this.nodePubkey=t,this.authorizedVoter=e,this.authorizedWithdrawer=r,this.commission=i}}class Mh{constructor(){}static decodeInstructionType(t){this.checkProgramId(t.programId);const r=E.u32("instruction").decode(t.data);let i;for(const[s,o]of Object.entries(Be))if(o.index==r){i=s;break}if(!i)throw new Error("Instruction type incorrect; not a VoteInstruction");return i}static decodeInitializeAccount(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,4);const{voteInit:e}=ft(Be.InitializeAccount,t.data);return{votePubkey:t.keys[0].pubkey,nodePubkey:t.keys[3].pubkey,voteInit:new Pa(new H(e.nodePubkey),new H(e.authorizedVoter),new H(e.authorizedWithdrawer),e.commission)}}static decodeAuthorize(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,3);const{newAuthorized:e,voteAuthorizationType:r}=ft(Be.Authorize,t.data);return{votePubkey:t.keys[0].pubkey,authorizedPubkey:t.keys[2].pubkey,newAuthorizedPubkey:new H(e),voteAuthorizationType:{index:r}}}static decodeAuthorizeWithSeed(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,3);const{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:e,currentAuthorityDerivedKeySeed:r,newAuthorized:i,voteAuthorizationType:s}}=ft(Be.AuthorizeWithSeed,t.data);return{currentAuthorityDerivedKeyBasePubkey:t.keys[2].pubkey,currentAuthorityDerivedKeyOwnerPubkey:new H(e),currentAuthorityDerivedKeySeed:r,newAuthorizedPubkey:new H(i),voteAuthorizationType:{index:s},votePubkey:t.keys[0].pubkey}}static decodeWithdraw(t){this.checkProgramId(t.programId),this.checkKeyLength(t.keys,3);const{lamports:e}=ft(Be.Withdraw,t.data);return{votePubkey:t.keys[0].pubkey,authorizedWithdrawerPubkey:t.keys[2].pubkey,lamports:e,toPubkey:t.keys[1].pubkey}}static checkProgramId(t){if(!t.equals(Er.programId))throw new Error("invalid instruction; programId is not VoteProgram")}static checkKeyLength(t,e){if(t.length<e)throw new Error(`invalid instruction; found ${t.length} keys, expected at least ${e}`)}}const Be=Object.freeze({InitializeAccount:{index:0,layout:E.struct([E.u32("instruction"),Cf()])},Authorize:{index:1,layout:E.struct([E.u32("instruction"),ot("newAuthorized"),E.u32("voteAuthorizationType")])},Withdraw:{index:3,layout:E.struct([E.u32("instruction"),E.ns64("lamports")])},UpdateValidatorIdentity:{index:4,layout:E.struct([E.u32("instruction")])},AuthorizeWithSeed:{index:10,layout:E.struct([E.u32("instruction"),Of()])}}),Th=Object.freeze({Voter:{index:0},Withdrawer:{index:1}});class Er{constructor(){}static initializeAccount(t){const{votePubkey:e,nodePubkey:r,voteInit:i}=t,s=Be.InitializeAccount,o=at(s,{voteInit:{nodePubkey:it(i.nodePubkey.toBuffer()),authorizedVoter:it(i.authorizedVoter.toBuffer()),authorizedWithdrawer:it(i.authorizedWithdrawer.toBuffer()),commission:i.commission}}),h={keys:[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:vr,isSigner:!1,isWritable:!1},{pubkey:_e,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:o};return new pt(h)}static createAccount(t){const e=new ut;return e.add(oe.createAccount({fromPubkey:t.fromPubkey,newAccountPubkey:t.votePubkey,lamports:t.lamports,space:this.space,programId:this.programId})),e.add(this.initializeAccount({votePubkey:t.votePubkey,nodePubkey:t.voteInit.nodePubkey,voteInit:t.voteInit}))}static authorize(t){const{votePubkey:e,authorizedPubkey:r,newAuthorizedPubkey:i,voteAuthorizationType:s}=t,o=Be.Authorize,h=at(o,{newAuthorized:it(i.toBuffer()),voteAuthorizationType:s.index}),l=[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:_e,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}];return new ut().add({keys:l,programId:this.programId,data:h})}static authorizeWithSeed(t){const{currentAuthorityDerivedKeyBasePubkey:e,currentAuthorityDerivedKeyOwnerPubkey:r,currentAuthorityDerivedKeySeed:i,newAuthorizedPubkey:s,voteAuthorizationType:o,votePubkey:h}=t,l=Be.AuthorizeWithSeed,y=at(l,{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:it(r.toBuffer()),currentAuthorityDerivedKeySeed:i,newAuthorized:it(s.toBuffer()),voteAuthorizationType:o.index}}),S=[{pubkey:h,isSigner:!1,isWritable:!0},{pubkey:_e,isSigner:!1,isWritable:!1},{pubkey:e,isSigner:!0,isWritable:!1}];return new ut().add({keys:S,programId:this.programId,data:y})}static withdraw(t){const{votePubkey:e,authorizedWithdrawerPubkey:r,lamports:i,toPubkey:s}=t,o=Be.Withdraw,h=at(o,{lamports:i}),l=[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}];return new ut().add({keys:l,programId:this.programId,data:h})}static safeWithdraw(t,e,r){if(t.lamports>e-r)throw new Error("Withdraw will leave vote account with insufficient funds.");return Er.withdraw(t)}static updateValidatorIdentity(t){const{votePubkey:e,authorizedWithdrawerPubkey:r,nodePubkey:i}=t,s=Be.UpdateValidatorIdentity,o=at(s),h=[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:i,isSigner:!0,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}];return new ut().add({keys:h,programId:this.programId,data:o})}}Er.programId=new H("Vote111111111111111111111111111111111111111");Er.space=3762;const La=new H("Va1idator1nfo111111111111111111111111111111"),Ph=F({name:V(),website:et(V()),details:et(V()),iconUrl:et(V()),keybaseUsername:et(V())});class Js{constructor(t,e){this.key=void 0,this.info=void 0,this.key=t,this.info=e}static fromConfigData(t){let e=[...t];if(ye(e)!==2)return null;const i=[];for(let s=0;s<2;s++){const o=new H(me(e,0,Re)),h=Ie(e)===1;i.push({publicKey:o,isSigner:h})}if(i[0].publicKey.equals(La)&&i[1].isSigner){const s=Je().decode(nt.Buffer.from(e)),o=JSON.parse(s);return $o(o,Ph),new Js(i[1].publicKey,o)}return null}}const Lh=new H("Vote111111111111111111111111111111111111111"),Ch=E.struct([ot("nodePubkey"),ot("authorizedWithdrawer"),E.u8("commission"),E.nu64(),E.seq(E.struct([E.nu64("slot"),E.u32("confirmationCount")]),E.offset(E.u32(),-8),"votes"),E.u8("rootSlotValid"),E.nu64("rootSlot"),E.nu64(),E.seq(E.struct([E.nu64("epoch"),ot("authorizedVoter")]),E.offset(E.u32(),-8),"authorizedVoters"),E.struct([E.seq(E.struct([ot("authorizedPubkey"),E.nu64("epochOfLastAuthorizedSwitch"),E.nu64("targetEpoch")]),32,"buf"),E.nu64("idx"),E.u8("isEmpty")],"priorVoters"),E.nu64(),E.seq(E.struct([E.nu64("epoch"),E.nu64("credits"),E.nu64("prevCredits")]),E.offset(E.u32(),-8),"epochCredits"),E.struct([E.nu64("slot"),E.nu64("timestamp")],"lastTimestamp")]);class Qs{constructor(t){this.nodePubkey=void 0,this.authorizedWithdrawer=void 0,this.commission=void 0,this.rootSlot=void 0,this.votes=void 0,this.authorizedVoters=void 0,this.priorVoters=void 0,this.epochCredits=void 0,this.lastTimestamp=void 0,this.nodePubkey=t.nodePubkey,this.authorizedWithdrawer=t.authorizedWithdrawer,this.commission=t.commission,this.rootSlot=t.rootSlot,this.votes=t.votes,this.authorizedVoters=t.authorizedVoters,this.priorVoters=t.priorVoters,this.epochCredits=t.epochCredits,this.lastTimestamp=t.lastTimestamp}static fromAccountData(t){const r=Ch.decode(it(t),4);let i=r.rootSlot;return r.rootSlotValid||(i=null),new Qs({nodePubkey:new H(r.nodePubkey),authorizedWithdrawer:new H(r.authorizedWithdrawer),commission:r.commission,votes:r.votes,rootSlot:i,authorizedVoters:r.authorizedVoters.map(Oh),priorVoters:Nh(r.priorVoters),epochCredits:r.epochCredits,lastTimestamp:r.lastTimestamp})}}function Oh({authorizedVoter:n,epoch:t}){return{epoch:t,authorizedVoter:new H(n)}}function fo({authorizedPubkey:n,epochOfLastAuthorizedSwitch:t,targetEpoch:e}){return{authorizedPubkey:new H(n),epochOfLastAuthorizedSwitch:t,targetEpoch:e}}function Nh({buf:n,idx:t,isEmpty:e}){return e?[]:[...n.slice(t+1).map(fo),...n.slice(0,t).map(fo)]}const lo={http:{devnet:"http://api.devnet.solana.com",testnet:"http://api.testnet.solana.com","mainnet-beta":"http://api.mainnet-beta.solana.com/"},https:{devnet:"https://api.devnet.solana.com",testnet:"https://api.testnet.solana.com","mainnet-beta":"https://api.mainnet-beta.solana.com/"}};function Uh(n,t){const e=t===!1?"http":"https";if(!n)return lo[e].devnet;const r=lo[e][n];if(!r)throw new Error(`Unknown ${e} cluster: ${n}`);return r}async function zh(n,t,e,r){let i,s;e&&Object.prototype.hasOwnProperty.call(e,"lastValidBlockHeight")||e&&Object.prototype.hasOwnProperty.call(e,"nonceValue")?(i=e,s=r):s=e;const o=s&&{skipPreflight:s.skipPreflight,preflightCommitment:s.preflightCommitment||s.commitment,minContextSlot:s.minContextSlot},h=await n.sendRawTransaction(t,o),l=s&&s.commitment,S=(await(i?n.confirmTransaction(i,l):n.confirmTransaction(h,l))).value;if(S.err)throw h!=null?new Cr({action:o?.skipPreflight?"send":"simulate",signature:h,transactionMessage:`Status: (${JSON.stringify(S)})`}):new Error(`Raw transaction ${h} failed (${JSON.stringify(S)})`);return h}const Kh=1e9,Vh=Object.freeze(Object.defineProperty({__proto__:null,Account:Rf,AddressLookupTableAccount:Ss,AddressLookupTableInstruction:xh,AddressLookupTableProgram:Ys,Authorized:Ta,BLOCKHASH_CACHE_TIMEOUT_MS:wa,BPF_LOADER_DEPRECATED_PROGRAM_ID:Mf,BPF_LOADER_PROGRAM_ID:Gf,BpfLoader:Zf,COMPUTE_BUDGET_INSTRUCTION_LAYOUTS:Ae,ComputeBudgetInstruction:_h,ComputeBudgetProgram:Xs,Connection:Sh,Ed25519Program:Sn,Enum:Af,EpochSchedule:ma,FeeCalculatorLayout:ga,Keypair:gr,LAMPORTS_PER_SOL:Kh,LOOKUP_TABLE_INSTRUCTION_LAYOUTS:Ue,Loader:rr,Lockup:Fr,MAX_SEED_LENGTH:la,Message:Se,MessageAccountKeys:Lr,MessageV0:er,NONCE_ACCOUNT_LENGTH:ks,NonceAccount:wn,PACKET_DATA_SIZE:$e,PUBLIC_KEY_LENGTH:Re,PublicKey:H,SIGNATURE_LENGTH_IN_BYTES:Pr,SOLANA_SCHEMA:Rr,STAKE_CONFIG_ID:Ma,STAKE_INSTRUCTION_LAYOUTS:ie,SYSTEM_INSTRUCTION_LAYOUTS:yt,SYSVAR_CLOCK_PUBKEY:_e,SYSVAR_EPOCH_SCHEDULE_PUBKEY:qf,SYSVAR_INSTRUCTIONS_PUBKEY:Df,SYSVAR_RECENT_BLOCKHASHES_PUBKEY:Xr,SYSVAR_RENT_PUBKEY:vr,SYSVAR_REWARDS_PUBKEY:Ff,SYSVAR_SLOT_HASHES_PUBKEY:Wf,SYSVAR_SLOT_HISTORY_PUBKEY:Vf,SYSVAR_STAKE_HISTORY_PUBKEY:Jr,Secp256k1Program:yr,SendTransactionError:Cr,SolanaJSONRPCError:tt,SolanaJSONRPCErrorCode:Hf,StakeAuthorizationLayout:Rh,StakeInstruction:Bh,StakeProgram:xn,Struct:Ds,SystemInstruction:$f,SystemProgram:oe,Transaction:ut,TransactionExpiredBlockheightExceededError:Fs,TransactionExpiredNonceInvalidError:hr,TransactionExpiredTimeoutError:Ws,TransactionInstruction:pt,TransactionMessage:Hs,TransactionStatus:Ce,VALIDATOR_INFO_KEY:La,VERSION_PREFIX_MASK:mn,VOTE_PROGRAM_ID:Lh,ValidatorInfo:Js,VersionedMessage:Vs,VersionedTransaction:$s,VoteAccount:Qs,VoteAuthorizationLayout:Th,VoteInit:Pa,VoteInstruction:Mh,VoteProgram:Er,clusterApiUrl:Uh,sendAndConfirmRawTransaction:zh,sendAndConfirmTransaction:vs},Symbol.toStringTag,{value:"Module"}));export{gr as K,E as L,H as P,oe as S,pt as T,ut as a,Re as b,vr as c,Vh as i,vs as s};
